## Active Model

之前已经接触到了`Active Record`这个框架, 它可以帮助我们构建强大的Model模型. 

思考一种情况, 当我们的Model需要大量的校验逻辑, 回调等内容时, 一个Model类就会变得非常的拥挤和难以维护.

`Active Model`就是为了解决这一问题而出现的, 它能将`Active Record`类的校验等逻辑拆出来, 以`mixin`的形式存在, 让`Active Record`能转为`POROs`(纯Ruby对象)以更好的完成业务逻辑.

### A Tour of Active Model

`Active Model`从用途上来理解, 类似于一个拥有完整功能的工具箱, 其中又按照用途分为了不同的`Module`, 下面分开介绍常用的一些.

#### ActiveModel::Attributes

来看个例子

```ruby
class Car
  include ActiveModel::AttributeAssignment

  attr_accessor :make, :model, :year, :color

  def initialize(attributes = {})
    assign_attributes(attributes) if attributes 

    super()
  end

  def paint(new_color)
    self.color = new_color
  end
end
```

上述代码中, 与普通的类不同的地方在于, 我们在一个标准的Ruby类里通过`include`方法混入了一个`module`类`ActiveModel::AttributeAssignment`, 通过混入的形式, 拿到了`assign_attributes`方法, 该方法类似于`merge`方法和Java的`BeanUtils.CopyProperties`方法, 会在用户传入任何参数时自动覆盖或者追加.

接着我们调用了`super()`方法, 该方法会自动调用继承的父类的同名方法, 在这个类里, 同名方法为`initialize`, 如果在其他方法里调用`super`, 则同名方法也会被调用.

`super()`在这里我们用了带`()`的形式, 如果不带`()`,直接写`super`, 则意味着**会将当前方法里的参数也同时发送给父类进行调用**, 如果带了`()`, 则表示无参数调用父类方法.

#### ActiveModel::Callbacks

接下来来看另外一个Module, 直接上代码

```ruby
class Car
  include ActiveModel::AttributeAssignment
  extend ActiveModel::Callbacks

  attr_accessor :make, :model, :year, :color

  define_model_callbacks :paint

  before_paint :keep_it_waxed
  after_paint :notify_dmv

  def initialize(attributes = {})
    assign_attributes(attributes) if attributes

    super()
  end

  def paint(new_color)
    run_callbacks :paint do
      Rails.logger.info "Painting the car #{new_color}"
      self.color = new_color
    end
  end

  private

  def keep_it_waxed
    Rails.logger.warn 'Be sure to keep your new paint job waxed!'
  end

  def notify_dmv
    Rails.logger.warn 'Be sure to notify the DMV about this color change!'
  end
end
```

上面的代码我们做了很多事情, 分别如下

1. 首先我们`extend`了另外一个module, 这个module叫做`ActiveModel::Callbacks`. 这里我们使用了`extend`而不是`include`, 是因为`ActiveModel::Callbacks`的目的是增加**class方法**到我们的class上, `extend`可以做到. 而`include`则是增加**`instance实例方法`**, 比如说在哪个`def`方法里调用.
2. 接着我们调用了`define_model_callbacks`这个回调, 注册了一个新的生命周期事件`:paint`, 这样我们便能获得`before/after/around_paint`三个生命周期.
3. 然后我们给生命周期配置了2个方法, 分开调用
4. 最后, 我们配置了生命周期方法的逻辑, 通过`Rails.logger.*`的形式输出出来.

执行一下, 可以发现完全符合预期

```sh
3.0.0 :006 > c.paint('gray')
Be sure to keep your new paint job waxed!
Painting the car gray                          
Be sure to notify the DMV about this color change!
 => "gray"  
```

#### ActiveModel::Dirty