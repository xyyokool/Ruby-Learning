### net/http 库

基本使用1：

```ruby
require 'net/http'

Net::HTTP.start("www.baidu.com", use_ssl: false) do
  req = Net::HTTP::Get.new('/sitemap.xml')
  body = http.request(req).body
  puts body.force_encoding("UTF-8")
end
```

基本使用2：

URI.parse转字符串为URI对象

```ruby
require 'net/http'

url = URI.parse("https:www.qq.com/news")

Net::HTTP.start(url.host, url.port, use_ssl: true) do |http|
  req = Net::HTTP::Get.new(url.path)
  body = http.request(req).body
  puts body.force_encoding("UTF-8")
end
```

基本使用3：

get_response 简化上面的写法

```ruby
require 'net/http'

uri = URI.parse("https:www.qq.com/news")
response = Net::HTTP.get_response(uri)
puts response.body.force_encoding("UTF-8")
```

基本使用4：

按请求结果区分行为

当请求成功时，解析， 当请求被重定向时， 解析重定向地址

```ruby
require 'net/http'

def get_web_document(url)
  uri = URI.parse(url)
  response = Net::HTTP.get_response(uri)
  
  case response
  when Net::HTTPSuccess
    return response.body.force_encoding("UTF-8")
  when Net::HTTPRedirection
    return get_web_document(response['Location'])
  else
    return nil 
  end
end

puts get_web_document('https://www.apress.com/sitemap.xml')
puts get_web_document('https://www.apress.com/doesnotexist.xml')
puts get_web_document('https://ruby-doc.org/core')
```

基本使用5：

网络授权的例子, 在访问需要提供账号密码授权的场景， 可以使用basic_auth方法进行授权提交。

```ruby
require 'net/http'

url = URI.parse('http://browserspy.dk/password-ok.php')

Net::HTTP.start(url.host, url.port) do |http|
  req = Net::HTTP::Get.new(url.path)
  req.basic_auth('test','test')
  puts http.request(req).body
end
```

基本使用6：

通过表单提交数据1

```ruby
require 'net/http'

uri = URI.parse("www.bidu.com/create")
response = Net::HTTP.post_form(uri, {:username => 'zhangsan', :password => '2asdasd'})
puts response.body
```

基本使用7：

通过表单提交数据2：

不同于上面的直接Post形式， 提供更多的校验与附加信息提供的操作。

```ruby
require 'net/http'

uri = URI.parse('www,baiodu.com/create')
Net::HTTP.start(uri.host, uri.port) do |http|
  req = Net::HTTP.Post.new(url.path)
  req.set_form_data({:name => 'zhangsan', :age => 12})
  puts http.request(req).body
end
```

> 使用Proxy代理

基本使用8：

下方例子首先创建了一个Proxy代理实例， 然后通过代来进行请求

```ruby
web_proxy = Net::HTTP::Proxy('xxx.proxy.com', 8080)
url = URI.parse('https://www.naodix.ca/ax.xml')

web_proxy.start(url.host, url.port, use_ssl: true) do |http|
  req = Net::HTTP::Get.new(url.path)
  puts http.request(req).body.force_encoding("UTF-8")
end
```

基本使用9：

在按需来进行是否要代理请求的情况下， 可以判断执行

```ruby
require 'net/http'

http_class = ARGV.first ? Net::HTTP::Proxy(ARGV[0], ARGV[1]) : Net::HTTP
url = URI.parse('https://www.asd.com/st.xml')
response = http_class.get_response(url)

puts response.body.force_encoding("UTF-8")
```

> https

基本使用10

SSL： Secure Socket Layer。 直接见代码， 一见便知如何使用

```ruby
require 'net/http'

url = URI.parse("https://www.naodu.com/abc.xml")
http = Net::HTTP.new(url.host, url.port)
# 只要设置一下use_ssl即可
http.use_ssl = true if url.scheme == 'https'

request = Net::HTTP::Get.new(url.path)
puts http.request(request).body.force_encoding("UTF-8")
```

### Open-Uri 库

将ruby的 `net/http, net/https, net/ftp` 这几个库打包在一起的再封装， 用起来的感觉和Python很像. 该库是内置的

基本例子1：

```ruby
require 'open-uri'

# 网络请求的文件就跟本地一样轻松使用
f = open('https://abc.apress.com/sitemap.xml')
puts f.readlines.join
```

基本例子2：

由于HTTP， HTTPS， FTP三者之间底层都是同样的协议， 因此`open`方法不需要考虑具体使用的协议是什么

```ruby
require 'open-uri'

url = URI.parse("https://asd.com/saz.xml")
url.open {|f| puts f.read}
```

基本例子3：

当然， 也能加上一大堆头信息模拟请求. 如果有做爬虫的需求， 可以转向了解一下 `HTTParty` 这个 gem， 更容易使用。

```ruby
require 'open-uri'
# 假装一下user-agent
f = URI.open('https://www.apress.com/sitemap.xml',
         {'User-Agent' => 'Mozilla/5.0 (platform; rv:geckoversion) Gecko/
          geckotrail Firefox/firefoxversion'})
puts f.read
```

### 网络内容处理

该部分关注在ruby中如何对HTML和XML类型的数据进行处理与解析

> 使用 Nokogiri 来处理 HTML

`Nokogiri` 是ruby专门用来做 HTML结构解析用的gem， 需要额外安装， 功效类似于Java的DOM4J

基本使用1：

```ruby
html = <<END_OF_HTML
<html>
<head>
<title>This is the page title</title>
</head>
<body>
<h1>Big heading!</h1>
<p>A paragraph of text.</p>
<ul><li>Item 1 in a list</li><li>Item 2</li><li class="highlighted">Item
3</li></ul>
</body>
</html>
END_OF_HTML

body = Nokogiri::HTML(html)
puts body.css("h1").first.inner_html # Big heading!
```

基本使用2：

配合`open-uri` 一起使用

```ruby
require 'nokogiri'
require 'open-uri'

doc = Nokogiri::HTML(URI.open('https://www.apress.com/us/about'))
puts doc.css("h1").first.inner_html
```

基本使用3：

还能加上标签选择器， 弄在一起就能按需解析目标DOM的内容了

```ruby
require 'nokogiri'
require 'open-uri'

doc = Nokogiri::HTML(URI.open('https://www.apress.com/us/about'))
puts doc.css("h1").first.inner_html

# select with tag selector
list = doc.css("ul").first
list.css('li').each do |node|
  puts node.inner_html
end
```

除了以上的解析HTML之外， nokogiri也能直接拿来解析 `xml` 与 `css` 表达式。 ruby这里的css方法， 理解为选择器会容易理解些。

> 解析JSON

ruby 内置了 `json` 这个模块专门用来解析json数据, API和JS长一模一样。

基本例子1：

```ruby
require 'json'

json = <<END_JSON
[
  {
    "name": "Peter Cooper",
    "gender": "Male"
}, {
    "name": "Carleton DiLeo",
    "gender": "Male"
  }
] 
END_JSON

# symbolize_names: 开启key symbol化
data = JSON.parse(json, symbolize_names: true)

data.each do |person|
  puts "#{person[:name]} : #{person[:gender]}"
end

# Peter Cooper : Male
# Carleton DiLeo : Male
```

### Email

POP3: Post Office Protocol 3, 是目前最主流的用于从邮件服务器获取邮件的协议。GMAIL等主流软件都是用这个协议进行邮件方面的沟通，
在ruby中，可以使用 `net/pop` 库来实现邮件与SMTP服务器进行交互的需求。

基本使用1：

```ruby
require 'net/pop'

mail_server = Net::POP3.new('xxxmail.server.com')

# recap: 还记得begin...rescue...end代码块吗， 就是try...catch
begin
  mail_server.start('username', 'password')
  if mail_server.mails.empty?
    puts "No mails"
  else
    puts "#{mail_server.mails.length} mails exist"
  end
rescue
  puts "connection error"
end
```

基本使用2：

按需清除邮件

```ruby
require 'net/pop'
mail_server = Net::POP3.new('xxxmail.server.com')

mail_server.each do |m|
  m.delete if m.header =~ /Subject:.+?medicines\b/i
end
```

基本使用3：

上面几个例子都是接收邮件， 发送邮件的也是可行的。

SMTP: Simple Mail Transfer Protocol, ruby 提供了 `net/smtp` 包来实现SMTP的邮件收发

```ruby
require 'net/smtp'

message = <<MESSAGE_END
From: Private Person <me@privacy.net>
  To: Authors of Beginning Ruby <test@rubyinside.com>
  Subject: SMTP email test
  This is a test email message. 
MESSAGE_END

Net::SMTP.start('localhost', 20) do |smtp|
  smtp.send_message message, 'me@privacy.net', 'test@rubyinside.com'
end
```

### FTP 文件传输

FTP: File Transfer Protocol

文件传输方面的问题也可以使用`open-uri` 来解决。 专门解决ftp问题的库是`net/ftp`

基本用法1:

```ruby
require 'open-uri'

output = File.new('xxx.txt', 'wb')
URI.open('ftp://cdi.xxx.xx.xx.x') do |f|
  output.print f.read
end

output.close
```

基本用法2：

```ruby
require 'net/ftp'
require 'uri'

uri = URI.parse("ftp://cdimage.debian.org/debian-cd/current'")

Net::FTP.open(uri.host) do |ftp|
  ftp.login 'anonymous', 'me@privacy.net'
  ftp.passive = true
  ftp.list(uri.path) {|path| puts path}
end
```

基本用法3：

远程操作文件

```ruby
#1. 登录
require 'net/ftp'

ftp = Net::FTP.new

ftp.login(username, password)

# 改变文件夹路径
ftp.chdir('debian-cd/aaa')
# 创建文件夹
ftp.mkdir("test")
# 重新命名
ftp.rename(filename, new_name)
ftp.delete(filename)
```

基本用法4：

下载文件

支持二进制文件下载和文本文件下载

```ruby
require 'net/ftp'

ftp = Net::FTP.new('cdimage.debian.org')
ftp.passive = true
ftp.login
ftp.chdir("test/current/")
# 下载二进制文件（图片，文件音视频，应用等）
ftp.getbinaryfile('xxx.exe')
# 下载文本文件
ftp.gettextfile('xxx.txt')
ftp.close

# 下载方法会阻塞线程， 可以传入代码块进行异步提醒
ftp.getbinaryfile('MD5SUMS', 'local-filename', 1024) do |blk|
  puts "A 100KB block of the file has been downloaded"
end
```

基本用法5：

上传文件

get -> put

```ruby
require 'net/ftp'

ftp = New::FTP.new('ftp.xxx.com')
ftp.passive = true
ftp.login
ftp.chdir('/xasd/sdwd/aa')
count = 0
ftp.putbinaryfile('local_file') do |blk|
  count += 1000
  puts "#{count} bytes uploaded"
end
ftp.close
```

基本用法6：

上传临时文件, 需要创建临时文件来保存内容

```ruby
require 'net/ftp'
require 'tempfile'

tempfile = Tempfile.new('text')
my_data = 'abcdefg'
tempfile.puts my_data

ftp = Net::FTP.new('ftp.xxx.com')
ftp.passive = true
ftp.login
ftp.chdir('xasd/name/test')

ftp.puttextfile(tempfile.path, 'my_data')
ftp.close
tempfile.close
```