### 项目创建

创建新项目： rails new xxx, 会创建一个xxx项目， 然后执行bundle install 安装gems依赖。

启动rails项目： rails server。 服务器启动相关的配置能在config文件夹下的environments文件夹下找到。

> 细节

1. 版本上：`>= 2.15` 意思是需要安装至少>=2.15版本的gem， `~> 6.0.2.1` 意思是只接收小版本的修复，会安装 6.0.2~6.0.9版本， 但是不会安装6.1.0版本。
如果此时是 `~> 6.0` 那么就会安装 6.0~6.9的版本， 但是不会安装7.0以上的版本。

### MVC模型

- rails采用的是MVC模式开发web应用。
- 采用rails自带的脚手架生成器能非常快速的完成MVC的搭建。

命令1： rails g scaffold User(表名) name:string email:string

上述命令能够直接创建一个完整的MVC链路， 在创建完成后， 可以执行如下命令进行表的迁移（类似于django的migrate）

命令2： rails db:migrate

执行上述命令后，rails会直接在对应的数据库下创建一个叫做users的表（注意命名，创建时因为表示的是一条记录，所以是单数， 但是表保存了很多的记录，所以表名会自动变为复数）

MVC交互流程：

- 首先用户访问rails服务器， 服务器会获取到用户访问的url， 然后转给rails router
- rails router在接收到后会通过保存的map找到对应的controller
- 此时controller会调用其所管理的方法与model进行交互，比如User.all去获取所有的User信息
- model层此时会与数据库进行交互（查询），然后返回结果给controller
- controller在接收到查询后的结果后， 会转给Views层用于模版渲染
- 模版渲染完毕后，返回html给浏览器使用。

使用scaffolding之后会自动生成的RESTFUL路由列表

| HTTP Request | URL           | Action  | Purpose           |
|--------------|---------------|---------|-------------------|
| GET          | /users        | index   | 展示User表所有数据       |
| GET          | /users/1      | show    | `展示User表里id为1的数据` |
 | GET          | /users/new    | new     | `前往创建用户页面`        |
 | POST         | /users        | create  | 创建一个新用户           |              
| GET          | /users/1/edit | edit    | `前往修改id为1的用户页面`   |
| PATCH        | /users/1      | update  | 更新一个id为1的用户的信息    |
| DELETE       | /users/1      | destroy | 删除id为1的用户         |

上述路由表基本对应了RESTFUL的CRUD4种需求, 除去上面的斜体标注的show, new, edit 3个用户页面展示之外， 剩下4个都对应了接口的功能。
并且能看到URL的路径都是一样的（严格对应RESTFUL风格对resource的定义）

> model 字段校验

1. validates字段校验

对于创建表单时的字段校验， rails提供了非常方便快速的校验能力，从下面的代码可以看到， 在model层， 只需要加上内置的
`validates` 方法， 并将需要做校验的字段和校验的内容放在后面就能快速的完成后端对表单提交的校验工作。（比起Java每一个都要加注解的方式来说快太多了）
`presence` 关键字表示该字段不能为空
```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  validates :name, length: {maximum: 10}
  validates :email, presence: true
end
```

2. has_many 表关系校验

除了对表的字段能快速进行校验工作外， 还有`has_many` 这种对表关系进行约束的方法能快速的实现表与表之间的绑定关系。 比如如下
下方的model代码， 可以看到， Guest表通过`has_many` 绑定了book表， book表通过`belongs_to`绑定了Guest表， 并且两者
之间是一对多，还是多对一的关系都能通过英文表达反馈出来。

至于外键字段绑定的问题， rails会自动在运行时做处理。无需用户关心。 注意命名方式的讲究。 这里绑定时是单数， 代表的是记录

```ruby
class Guest < ApplicationRecord
 # constraint guest name to be at most 10 characters
 validates :name, length: {maximum: 10}

 has_many :book
end

class Book < ApplicationRecord
 belongs_to :guest
end

```

我们可以快速的通过 rails 的 console来对表进行操作， 比如

```ruby
#! /usr/local/bin/sh

rails console

first_guest = Guest.first # 通过model名.first快速拿到该表第一条记录, 返回类型是Guest

first_guest_book = first_guest.books; 
```

3. 创建静态页面

使用命令： rails g controller StaticPages home help

执行上述命令后， 会生成名为`static_pages_controller`的rb文件， 该文件即单controller文件。 相比较于 g scaffolding 这个命令，
g controller不会管到Model层， 只会生成Controller和View， 方便用于没有状态的静态页面的生成.(注意命令的命名方式一定要是大驼峰)

执行后，会生成如下文件

- controllers
  - static_pages_controller.rb
- views
  - static_pages
    - help.html.erb
    - home.html.erb

注意： 

- 可以执行 `rails destroy [controller/model] StaticPages[大驼峰对应内容] home help`的形式undo通过CLI创建的文件。

- 可以执行 `rails db:rollback` 来undo一次migration操作

- 可以执行 `rails db:migrate VERSION=0` 来undo所有的migration操作

ruby当中的html模版为`x.html.erb`文件, 其模版语法形式类似于ejs, jsp, 能直接在html模版里嵌套ruby语法. 当中只需要知道2个书写样式就行, 一个是`<% %>`, 表示执行ruby语句, 另一个是 `<%= %>`, 表示不仅执行还要把结果返回.  比如见如下例子

```ruby
# home.html.erb

<% provide(:title, "Home") %> # ruby函数 provide,直接提供一个哈希给到该模版使用
<title><%= yield(:title) %></title> # yield函数, 拿到provide的值, 并且返回渲染出来.
<h1>Sample App</h1> <p>
This is the home page for the
<a href="https://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application.
</p>
```

除了标准的erb模版之外, rails还支持其他的模版语法, 比如haml, 其模版样式如下

```ruby
%section.container
  %h1= post.title
  %h2= post.subtitle
  .content
    = post.content
```

从上能看到, haml的语法基本就是markdown语法, 不过现在可选项多, 了解一下即可.

对于全局性的模版, 在laytous文件夹下有application.html.erb文件, 用于提供全局重复的渲染模版, 见如下代码

```ruby
 <!DOCTYPE html>
<html> <head>
<title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title>
<meta charset="utf-8"> 
# 下方tag都是standard pipeline, 必须要启用, 能帮助做很多事情.
<%= csrf_meta_tags %>  # cross-site request forgery, 用于规避csrf跨站请求攻击.
<%= csp_meta_tag %> # Content Security Policy, 用于规避XSS攻击
<%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %> # 加载CSS文件
<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %> </head> # 加载JS文件
<body>
<%= yield %>
</body> </html>
```

路由改变.

当页面不断增多时, 可以看到路由如下

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  get 'static_pages/help'
  get 'static_pages/about'
  get 'static_pages/contact'
  resources :guests
  resources :entries
end
```

上面的路由表里, root与get指定的路由方式不一样, 当为root时, 使用的#, 但是get时则是/.

自动化测试:

可以使用`guard` 这个gem进行rails项目的自动化测试, 该gem需要额外安装, 并需要在项目根目录提供Guardfile, 内容如下.

```ruby
require 'active_support/core_ext/string'
# Defines the matching rules for Guard.
guard :minitest, spring: 'bin/rails test', all_on_start: false do
  watch(%r{^test/(.*)/?(.*)_test\.rb$})
  watch('test/test_helper.rb') { 'test' }
  watch('config/routes.rb') { interface_tests }
  watch(%r{app/views/layouts/*}) { interface_tests }
  watch(%r{^app/models/(.*?)\.rb$}) do |matches|
    ["test/models/#{matches[1]}_test.rb",
     'test/integration/microposts_interface_test.rb']
  end
  watch(%r{^test/fixtures/(.*?)\.yml$}) do |matches|
    "test/models/#{matches[1].singularize}_test.rb"
  end
  watch(%r{^app/mailers/(.*?)\.rb$}) do |matches|
    "test/mailers/#{matches[1]}_test.rb"
  end
  watch(%r{^app/views/(.*)_mailer/.*$}) do |matches|
    "test/mailers/#{matches[1]}_mailer_test.rb"
  end
  watch(%r{^app/controllers/(.*?)_controller\.rb$}) do |matches|
    resource_tests(matches[1])
  end
  watch(%r{^app/views/([^/]*?)/.*\.html\.erb$}) do |matches|
    ["test/controllers/#{matches[1]}_controller_test.rb"] +
      integration_tests(matches[1])
  end
  watch(%r{^app/helpers/(.*?)_helper\.rb$}) do |matches|
    integration_tests(matches[1])
  end
  watch('app/views/layouts/application.html.erb') do
    'test/integration/site_layout_test.rb'
  end
  watch('app/helpers/sessions_helper.rb') do
    integration_tests << 'test/helpers/sessions_helper_test.rb'
  end
  watch('app/controllers/sessions_controller.rb') do
    ['test/controllers/sessions_controller_test.rb',
     'test/integration/users_login_test.rb']
  end
  watch('app/controllers/account_activations_controller.rb') do
    'test/integration/users_signup_test.rb'
  end
  watch(%r{app/views/users/*}) do
    resource_tests('users') +
      ['test/integration/microposts_interface_test.rb']
  end
end

# Returns the integration tests corresponding to the given resource.
def integration_tests(resource = :all)
  if resource == :all
    Dir['test/integration/*']
  else
    Dir["test/integration/#{resource}_*.rb"]
  end
end

# Returns all tests that hit the interface.
def interface_tests
  integration_tests << 'test/controllers'
end

# Returns the controller tests corresponding to the given resource.
def controller_test(resource)
  "test/controllers/#{resource}_controller_test.rb"
end

# Returns all tests for the given resource.
def resource_tests(resource)
  integration_tests(resource) << controller_test(resource)
end
```

当配置之后, 即可以在控制台执行 `bundle exec guard` 命令执行, 之后每当controller进行改变之后, 就会重新跑一次整合测试, 保证程序没有问题.

guard的文档: `https://github.com/guard/guard/wiki`

如果碰到报错, 可以尝试执行 `bin/spring stop` 进行停止(spring是rails里用于测试的包, 它会预先加载测试的消息以加速测试的进程). 之后再执行 `bundle exec guard`

#### 模版自定义helpers

上述的内容看到了一些能够直接在模版文件里使用的helper函数, 比如`stylesheet_link_tag` 用来帮助处理在模版渲染中的一些问题, 那如果要自己创建一个能用在模版里的函数应该如何做呢?

在rails里可以在app/helpers文件夹下进行函数的增加, 比如

```ruby
module ApplicationHelper
  # Return the full title
  def full_title(page_title = '')
    base_title = "Yahaha, Helper"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end
```

上面的代码在ApplicaitonHelper里增加了, 那么所有的模版文件都能用到. 如下

```ruby
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    # 这里用到自定义helper函数
    <title><%= full_title(yield(:title)) %></title>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

rails模式的函数书写方式

```ruby
def string_message(str = '')
  return "empty string!" if str.empty?
  return "nonempty"
end

# 相比较于if else, 一眼就能看出优劣
def string_message(str = '')
  if str.empty?
    'empty string!'
  else
    'nonempty'
  end
end

# 对于?号的书写方式, 还有带!的方法, 这类带!(叫bang)号的方法, 会mutate原来的数组,
# 而不是返回一个新的数组

# 还有个代码块传入的速写方式经常看见, 如下
%w[A B C].map(&:downcase)  # 叫做 symbol-to-proc, 是rails独有的,不是ruby的特性,(2.7版本才加入ruby core)

# 等价于
%[A B C].map {|c| c.downcase} # 上述带&:的方式省略了取值的重复代码

# 哈希数据结构里的 => (叫做hashrocket)
user = {'first_name' => 'aaa', 'last_name' => 'bbb'}

# symbol -> 唯一,不带任何方法的string对象. 用得极多, 基本参数都用, 哈希的key也基本都用symbol
:name
user = {:first_name => 'aaa', :last_name => 'bbb'}
# 取值: 
user[:first_name]
# 普通的json格式也是可以用的, 效果一样.(ruby1.9以后) 
# 其本质还是转为了symbol就是了, rails里还是推荐写成symbol的形式, 因为取值还是要写symbol
user = {first_name: 'aaa', last_name: 'bbb'}

# 此外有一个hash结构常用的方法merge需要注意一下
{ :a => 100, :b => 200 }.merge({ :b => 300  })
# {:a=>100, :b=>300} 
# 该方法和JS的Object.assign类似, 会合并传入到merge里的对象的内容, 而其他没有写的内容则不变, 该方法在表单处十分有用.

{ :a => 100, :b => 200 }.merge({ :b => 300, :c => 400  })
# {:a=>100, :b=>300, :c=>400} 
```

重新检查 `stylesheet_link_tag` 方法有什么用.

```ruby
 <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %>

 # 拆开后实际为, 神奇的地方在于rails里有大量这样的代码, 没有括号,只有方法名和参数
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 实际上, 括号在ruby里是可以被省略的, 上面的代码等价于
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')

# 并且上述的代码可以看到 media: 那个位置的数据结构明显是hash, 那哈希结构的{}去哪了?
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }

# 实际上, 在ruby里, 如果hash数据结构是方法的最后一个参数的话, 则哈希的{}括号可以被省略. 因此最终就看到了大量的方法写成了这个样子.
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 并且ruby解释器在这样的写法上不会去区分换行符和空格啥的, 因此就能看到某些方法写成下面这样也是合法的
fork_method :aaa, :bbb, :ccc, :ddd
            :eee, :fff, :ggg, :ttt

# 实际stylesheet_link_tag 这个方法会在html里转换为如下内容
# 其传入的参数的意义是, 让所有的css文件在任何屏幕适配下, 如果重新部署修改了css文件, 则重新加载新的css文件(reload, rails4.0加入的功能), 
<link rel="stylesheet" media="all" href="/assets/application.self- f0d704deea029cf000697e2c0181ec173a1b474645466ed843eb5ee7bb215794.css?body=1" data-turbolinks-track="reload" />
```

解释一下类

```ruby
class User
  attr_accessor :name, :email
  def initialize(attributes = {}) 
    @name = attributes[:name] 
    @email = attributes[:email]
  end
  def formatted_email 
    "#{@name} <#{@email}>"
  end
end
# attr_accessor : attribute accessors 即getter + setter
# initialize : 即类的构造方法
# @name, @email 即this.name, this.email
```

解释一下html模版创建

```ruby
<%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %> </div>
# link_to方法接收3个参数, 1,显示的内容, 2,跳转的位置, 3,class名字
# 会生成一个 <a></a>标签

<%= link_to image_tag("456.jpeg", alt: "Rails logo", width: "200"), "https://rubyonrails.org/" %>
# image_tag方法会生成一个<image />标签, 
# 接收3个参数, 1,image所在的位置(默认定位在app/assets/images下), 2,无法展示时显示的文字, 3,style属性
```

rails的静态资源pipeline天生支持scss编译, 无需其他的gem,如果想找使用bootsrap, 可以添加如下gem

`gem 'bootstrap-sass', '3.4.1'`

app/assets目录下的所有文件, 都会在rails服务器进行编译时自动输出, 包括下面的stylesheets文件夹, 都会自动被server引用, 因此不需要显示的在html模版里调. 所以类似于custom.scss之类的全局都要的文件, 直接丢到stylesheets文件夹里就得了,会自动生效. 比如

```scss
@import "bootstrap-sprockets";
@import "bootstrap";

body {
  padding-top: 60px;
  }
  section { overflow: auto;
  }
  textarea {
  resize: vertical;
  }
  .center {
  text-align: center;
  }
  .center h1 { margin-bottom: 10px;
  }
```

**asset pipeline** 是rails的一大特色, 这些放在assets文件夹下的images和stylesheets, 在前后端分离的场景下也能和Webpack一起使用, 当然, webpack默认是被rails支持的, 前端包管理工具则是yarn.

在rails的项目里, assets文件夹有3个, 在server进行静态资源打包时都会默认被用到, 分别如下

- app/assets: 当前app的静态资源
- lib/assets: 自己开发的依赖的静态资源
- vendor/assets: 第三方依赖的静态资源,默认不会被展示

详解一下app/assets文件夹(asset pipeline会使用到下面三个文件夹里的内容)

- config : 下面有manifest.js, 可以在其中手动指定rails服务器还需要去哪里加载css文件和js文件(或者文件夹)(通过使用Sprockets gem来完成), 不能指定图片
- images : 项目全局图片
- stylesheets : 项目全局css文件加载

需要注意的是 asset pipeline 会自动完成发布到生产时的CSS资源处理工作, 会组合所有的CSS文件为一个CSS文件(application.css),并最小化处理. 而scss文件则也会自动编译然后组合


关于短链接:

在渲染<a>标签时, 会有route相关的内容需要指定, rails提供了快速匹配route的别名形式, 只要在每个route对应的小写字母后加上_path, 就能调用到对应的url.

比如 /about , 那么在模版里渲染路由的时候, 在link_to方法里, 使用about_path作为参数就能匹配到 /about 路由. 具体是什么参考rails routes下controller对应给出的Prefix, 即 prefix + "_path" 就ok. 此外还有一个 + "_url" 的写法, 差别如下

root_path -> '/'
root_url  -> 'http://www.example.com/'

root_url 只会在重定向到站外资源时用到, 因为带全url地址.

基于上述的认知, 路由可以优化为如下样式

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  # get 'static_pages/help'
  # get 'static_pages/about'
  # get 'static_pages/contact'
  # 参数1: url查找显示用的url, 参数2: to: 具体查找的controller下的方法, 参数3: as: 起别名, 在模版里引入时要改成helf_path, 而不是help_path(看着没啥用)
  get '/help', to: 'static_pages#help', as: 'helf'
  get '/about', to: 'static_pages#about'
  get '/contact', to: 'static_pages#contact'
  resources :guests
  resources :entries
end
```

记得生成整合测试: `rails generate integration_test site_layout`, 试试routes的修改是否正确, `rails test:integration` 执行E2E测试

```ruby
require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest
  test 'layout links' do
    get root_path
    # assert_template 会渲染整个html模版出来
    assert_template 'static_pages/home'
    # assert_select 是dom选择器, 会通过querySelector查找, 每执行一次,就往下诺
    assert_select 'a[href=?]', root_path, count: 2
    assert_select 'a[href=?]', help_path
    assert_select 'a[href=?]', about_path
    assert_select 'a[href=?]', contact_path
  end
end
```