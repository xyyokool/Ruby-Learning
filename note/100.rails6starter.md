### 项目创建

创建新项目： rails new xxx, 会创建一个xxx项目， 然后执行bundle install 安装gems依赖。

启动rails项目： rails server。 服务器启动相关的配置能在config文件夹下的environments文件夹下找到。

> 细节

1. 版本上：`>= 2.15` 意思是需要安装至少>=2.15版本的gem， `~> 6.0.2.1` 意思是只接收小版本的修复，会安装 6.0.2~6.0.9版本， 但是不会安装6.1.0版本。
如果此时是 `~> 6.0` 那么就会安装 6.0~6.9的版本， 但是不会安装7.0以上的版本。

### MVC模型

- rails采用的是MVC模式开发web应用。
- 采用rails自带的脚手架生成器能非常快速的完成MVC的搭建。

命令1： rails g scaffold User(表名) name:string email:string

上述命令能够直接创建一个完整的MVC链路， 在创建完成后， 可以执行如下命令进行表的迁移（类似于django的migrate）

命令2： rails db:migrate

执行上述命令后，rails会直接在对应的数据库下创建一个叫做users的表（注意命名，创建时因为表示的是一条记录，所以是单数， 但是表保存了很多的记录，所以表名会自动变为复数）

MVC交互流程：

- 首先用户访问rails服务器， 服务器会获取到用户访问的url， 然后转给rails router
- rails router在接收到后会通过保存的map找到对应的controller
- 此时controller会调用其所管理的方法与model进行交互，比如User.all去获取所有的User信息
- model层此时会与数据库进行交互（查询），然后返回结果给controller
- controller在接收到查询后的结果后， 会转给Views层用于模版渲染
- 模版渲染完毕后，返回html给浏览器使用。

使用scaffolding之后会自动生成的RESTFUL路由列表

| HTTP Request | URL           | Action  | Purpose           |
|--------------|---------------|---------|-------------------|
| GET          | /users        | index   | 展示User表所有数据       |
| GET          | /users/1      | show    | `展示User表里id为1的数据` |
 | GET          | /users/new    | new     | `前往创建用户页面`        |
 | POST         | /users        | create  | 创建一个新用户           |              
| GET          | /users/1/edit | edit    | `前往修改id为1的用户页面`   |
| PATCH        | /users/1      | update  | 更新一个id为1的用户的信息    |
| DELETE       | /users/1      | destroy | 删除id为1的用户         |

上述路由表基本对应了RESTFUL的CRUD4种需求, 除去上面的斜体标注的show, new, edit 3个用户页面展示之外， 剩下4个都对应了接口的功能。
并且能看到URL的路径都是一样的（严格对应RESTFUL风格对resource的定义）

> model 字段校验

1. validates字段校验

对于创建表单时的字段校验， rails提供了非常方便快速的校验能力，从下面的代码可以看到， 在model层， 只需要加上内置的
`validates` 方法， 并将需要做校验的字段和校验的内容放在后面就能快速的完成后端对表单提交的校验工作。（比起Java每一个都要加注解的方式来说快太多了）
`presence` 关键字表示该字段不能为空
```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  validates :name, length: {maximum: 10}
  validates :email, presence: true
end
```

2. has_many 表关系校验

除了对表的字段能快速进行校验工作外， 还有`has_many` 这种对表关系进行约束的方法能快速的实现表与表之间的绑定关系。 比如如下
下方的model代码， 可以看到， Guest表通过`has_many` 绑定了book表， book表通过`belongs_to`绑定了Guest表， 并且两者
之间是一对多，还是多对一的关系都能通过英文表达反馈出来。

至于外键字段绑定的问题， rails会自动在运行时做处理。无需用户关心。 注意命名方式的讲究。 这里绑定时是单数， 代表的是记录

```ruby
class Guest < ApplicationRecord
 # constraint guest name to be at most 10 characters
 validates :name, length: {maximum: 10}

 has_many :book
end

class Book < ApplicationRecord
 belongs_to :guest
end

```

我们可以快速的通过 rails 的 console来对表进行操作， 比如

```ruby
#! /usr/local/bin/sh

rails console

first_guest = Guest.first # 通过model名.first快速拿到该表第一条记录, 返回类型是Guest

first_guest_book = first_guest.books; 
```

3. 创建静态页面

使用命令： rails g controller StaticPages home help

执行上述命令后， 会生成名为`static_pages_controller`的rb文件， 该文件即单controller文件。 相比较于 g scaffolding 这个命令，
g controller不会管到Model层， 只会生成Controller和View， 方便用于没有状态的静态页面的生成.(注意命令的命名方式一定要是大驼峰)

执行后，会生成如下文件

- controllers
  - static_pages_controller.rb
- views
  - static_pages
    - help.html.erb
    - home.html.erb

注意： 

- 可以执行 `rails destroy [controller/model] StaticPages[大驼峰对应内容] home help`的形式undo通过CLI创建的文件。

- 可以执行 `rails db:rollback` 来undo一次migration操作

- 可以执行 `rails db:migrate VERSION=0` 来undo所有的migration操作

ruby当中的html模版为`x.html.erb`文件, 其模版语法形式类似于ejs, jsp, 能直接在html模版里嵌套ruby语法. 当中只需要知道2个书写样式就行, 一个是`<% %>`, 表示执行ruby语句, 另一个是 `<%= %>`, 表示不仅执行还要把结果返回.  比如见如下例子

```ruby
# home.html.erb

<% provide(:title, "Home") %> # ruby函数 provide,直接提供一个哈希给到该模版使用
<title><%= yield(:title) %></title> # yield函数, 拿到provide的值, 并且返回渲染出来.
<h1>Sample App</h1> <p>
This is the home page for the
<a href="https://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application.
</p>
```

除了标准的erb模版之外, rails还支持其他的模版语法, 比如haml, 其模版样式如下

```ruby
%section.container
  %h1= post.title
  %h2= post.subtitle
  .content
    = post.content
```

从上能看到, haml的语法基本就是markdown语法, 不过现在可选项多, 了解一下即可.

对于全局性的模版, 在laytous文件夹下有application.html.erb文件, 用于提供全局重复的渲染模版, 见如下代码

```ruby
 <!DOCTYPE html>
<html> <head>
<title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title>
<meta charset="utf-8"> 
# 下方tag都是standard pipeline, 必须要启用, 能帮助做很多事情.
<%= csrf_meta_tags %>  # cross-site request forgery, 用于规避csrf跨站请求攻击.
<%= csp_meta_tag %> # Content Security Policy, 用于规避XSS攻击
<%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %> # 加载CSS文件
<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %> </head> # 加载JS文件
<body>
<%= yield %>
</body> </html>
```

路由改变.

当页面不断增多时, 可以看到路由如下

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  get 'static_pages/help'
  get 'static_pages/about'
  get 'static_pages/contact'
  resources :guests
  resources :entries
end
```

上面的路由表里, root与get指定的路由方式不一样, 当为root时, 使用的#, 但是get时则是/.

自动化测试:

可以使用`guard` 这个gem进行rails项目的自动化测试, 该gem需要额外安装, 并需要在项目根目录提供Guardfile, 内容如下.

```ruby
require 'active_support/core_ext/string'
# Defines the matching rules for Guard.
guard :minitest, spring: 'bin/rails test', all_on_start: false do
  watch(%r{^test/(.*)/?(.*)_test\.rb$})
  watch('test/test_helper.rb') { 'test' }
  watch('config/routes.rb') { interface_tests }
  watch(%r{app/views/layouts/*}) { interface_tests }
  watch(%r{^app/models/(.*?)\.rb$}) do |matches|
    ["test/models/#{matches[1]}_test.rb",
     'test/integration/microposts_interface_test.rb']
  end
  watch(%r{^test/fixtures/(.*?)\.yml$}) do |matches|
    "test/models/#{matches[1].singularize}_test.rb"
  end
  watch(%r{^app/mailers/(.*?)\.rb$}) do |matches|
    "test/mailers/#{matches[1]}_test.rb"
  end
  watch(%r{^app/views/(.*)_mailer/.*$}) do |matches|
    "test/mailers/#{matches[1]}_mailer_test.rb"
  end
  watch(%r{^app/controllers/(.*?)_controller\.rb$}) do |matches|
    resource_tests(matches[1])
  end
  watch(%r{^app/views/([^/]*?)/.*\.html\.erb$}) do |matches|
    ["test/controllers/#{matches[1]}_controller_test.rb"] +
      integration_tests(matches[1])
  end
  watch(%r{^app/helpers/(.*?)_helper\.rb$}) do |matches|
    integration_tests(matches[1])
  end
  watch('app/views/layouts/application.html.erb') do
    'test/integration/site_layout_test.rb'
  end
  watch('app/helpers/sessions_helper.rb') do
    integration_tests << 'test/helpers/sessions_helper_test.rb'
  end
  watch('app/controllers/sessions_controller.rb') do
    ['test/controllers/sessions_controller_test.rb',
     'test/integration/users_login_test.rb']
  end
  watch('app/controllers/account_activations_controller.rb') do
    'test/integration/users_signup_test.rb'
  end
  watch(%r{app/views/users/*}) do
    resource_tests('users') +
      ['test/integration/microposts_interface_test.rb']
  end
end

# Returns the integration tests corresponding to the given resource.
def integration_tests(resource = :all)
  if resource == :all
    Dir['test/integration/*']
  else
    Dir["test/integration/#{resource}_*.rb"]
  end
end

# Returns all tests that hit the interface.
def interface_tests
  integration_tests << 'test/controllers'
end

# Returns the controller tests corresponding to the given resource.
def controller_test(resource)
  "test/controllers/#{resource}_controller_test.rb"
end

# Returns all tests for the given resource.
def resource_tests(resource)
  integration_tests(resource) << controller_test(resource)
end
```

当配置之后, 即可以在控制台执行 `bundle exec guard` 命令执行, 之后每当controller进行改变之后, 就会重新跑一次整合测试, 保证程序没有问题.

guard的文档: `https://github.com/guard/guard/wiki`

如果碰到报错, 可以尝试执行 `bin/spring stop` 进行停止(spring是rails里用于测试的包, 它会预先加载测试的消息以加速测试的进程). 之后再执行 `bundle exec guard`
