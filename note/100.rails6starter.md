### 项目创建

创建新项目： rails new xxx, 会创建一个xxx项目， 然后执行bundle install 安装gems依赖。

启动rails项目： rails server。 服务器启动相关的配置能在config文件夹下的environments文件夹下找到。

> 细节

1. 版本上：`>= 2.15` 意思是需要安装至少>=2.15版本的gem， `~> 6.0.2.1` 意思是只接收小版本的修复，会安装 6.0.2~6.0.9版本， 但是不会安装6.1.0版本。
如果此时是 `~> 6.0` 那么就会安装 6.0~6.9的版本， 但是不会安装7.0以上的版本。

### MVC模型

- rails采用的是MVC模式开发web应用。
- 采用rails自带的脚手架生成器能非常快速的完成MVC的搭建。

命令1： rails g scaffold User(表名) name:string email:string

上述命令能够直接创建一个完整的MVC链路， 在创建完成后， 可以执行如下命令进行表的迁移（类似于django的migrate）

命令2： rails db:migrate

执行上述命令后，rails会直接在对应的数据库下创建一个叫做users的表（注意命名，创建时因为表示的是一条记录，所以是单数， 但是表保存了很多的记录，所以表名会自动变为复数）

MVC交互流程：

- 首先用户访问rails服务器， 服务器会获取到用户访问的url， 然后转给rails router
- rails router在接收到后会通过保存的map找到对应的controller
- 此时controller会调用其所管理的方法与model进行交互，比如User.all去获取所有的User信息
- model层此时会与数据库进行交互（查询），然后返回结果给controller
- controller在接收到查询后的结果后， 会转给Views层用于模版渲染
- 模版渲染完毕后，返回html给浏览器使用。

使用scaffolding之后会自动生成的RESTFUL路由列表

| HTTP Request | URL           | Action  | Purpose           |
|--------------|---------------|---------|-------------------|
| GET          | /users        | index   | 展示User表所有数据       |
| GET          | /users/1      | show    | `展示User表里id为1的数据` |
 | GET          | /users/new    | new     | `前往创建用户页面`        |
 | POST         | /users        | create  | 创建一个新用户           |              
| GET          | /users/1/edit | edit    | `前往修改id为1的用户页面`   |
| PATCH        | /users/1      | update  | 更新一个id为1的用户的信息    |
| DELETE       | /users/1      | destroy | 删除id为1的用户         |

上述路由表基本对应了RESTFUL的CRUD4种需求, 除去上面的斜体标注的show, new, edit 3个用户页面展示之外， 剩下4个都对应了接口的功能。
并且能看到URL的路径都是一样的（严格对应RESTFUL风格对resource的定义）

> model 字段校验

1. validates字段校验

对于创建表单时的字段校验， rails提供了非常方便快速的校验能力，从下面的代码可以看到， 在model层， 只需要加上内置的
`validates` 方法， 并将需要做校验的字段和校验的内容放在后面就能快速的完成后端对表单提交的校验工作。（比起Java每一个都要加注解的方式来说快太多了）
`presence` 关键字表示该字段不能为空
```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  validates :name, length: {maximum: 10}
  validates :email, presence: true
end
```

2. has_many 表关系校验

除了对表的字段能快速进行校验工作外， 还有`has_many` 这种对表关系进行约束的方法能快速的实现表与表之间的绑定关系。 比如如下
下方的model代码， 可以看到， Guest表通过`has_many` 绑定了book表， book表通过`belongs_to`绑定了Guest表， 并且两者
之间是一对多，还是多对一的关系都能通过英文表达反馈出来。

至于外键字段绑定的问题， rails会自动在运行时做处理。无需用户关心。 注意命名方式的讲究。 这里绑定时是单数， 代表的是记录

```ruby
class Guest < ApplicationRecord
 # constraint guest name to be at most 10 characters
 validates :name, length: {maximum: 10}

 has_many :book
end

class Book < ApplicationRecord
 belongs_to :guest
end

```

我们可以快速的通过 rails 的 console来对表进行操作， 比如

```ruby
#! /usr/local/bin/sh

rails console

first_guest = Guest.first # 通过model名.first快速拿到该表第一条记录, 返回类型是Guest

first_guest_book = first_guest.books; 
```




