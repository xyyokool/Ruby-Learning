### 项目创建

创建新项目： rails new xxx, 会创建一个xxx项目， 然后执行bundle install 安装gems依赖。

启动rails项目： rails server。 服务器启动相关的配置能在config文件夹下的environments文件夹下找到。

> 细节

1. 版本上：`>= 2.15` 意思是需要安装至少>=2.15版本的gem， `~> 6.0.2.1` 意思是只接收小版本的修复，会安装 6.0.2~6.0.9版本， 但是不会安装6.1.0版本。
如果此时是 `~> 6.0` 那么就会安装 6.0~6.9的版本， 但是不会安装7.0以上的版本。

### MVC模型

- rails采用的是MVC模式开发web应用。
- 采用rails自带的脚手架生成器能非常快速的完成MVC的搭建。

命令1： rails g scaffold User(表名) name:string email:string

上述命令能够直接创建一个完整的MVC链路， 在创建完成后， 可以执行如下命令进行表的迁移（类似于django的migrate）

命令2： rails db:migrate

执行上述命令后，rails会直接在对应的数据库下创建一个叫做users的表（注意命名，创建时因为表示的是一条记录，所以是单数， 但是表保存了很多的记录，所以表名会自动变为复数）

MVC交互流程：

- 首先用户访问rails服务器， 服务器会获取到用户访问的url， 然后转给rails router
- rails router在接收到后会通过保存的map找到对应的controller
- 此时controller会调用其所管理的方法与model进行交互，比如User.all去获取所有的User信息
- model层此时会与数据库进行交互（查询），然后返回结果给controller
- controller在接收到查询后的结果后， 会转给Views层用于模版渲染
- 模版渲染完毕后，返回html给浏览器使用。

使用scaffolding之后会自动生成的RESTFUL路由列表

| HTTP Request | URL           | Action  | Purpose           |
|--------------|---------------|---------|-------------------|
| GET          | /users        | index   | 展示User表所有数据       |
| GET          | /users/1      | show    | `展示User表里id为1的数据` |
 | GET          | /users/new    | new     | `前往创建用户页面`        |
 | POST         | /users        | create  | 创建一个新用户           |              
| GET          | /users/1/edit | edit    | `前往修改id为1的用户页面`   |
| PATCH        | /users/1      | update  | 更新一个id为1的用户的信息    |
| DELETE       | /users/1      | destroy | 删除id为1的用户         |

上述路由表基本对应了RESTFUL的CRUD4种需求, 除去上面的斜体标注的show, new, edit 3个用户页面展示之外， 剩下4个都对应了接口的功能。
并且能看到URL的路径都是一样的（严格对应RESTFUL风格对resource的定义）

> model 字段校验

1. validates字段校验

对于创建表单时的字段校验， rails提供了非常方便快速的校验能力，从下面的代码可以看到， 在model层， 只需要加上内置的
`validates` 方法， 并将需要做校验的字段和校验的内容放在后面就能快速的完成后端对表单提交的校验工作。（比起Java每一个都要加注解的方式来说快太多了）
`presence` 关键字表示该字段不能为空
```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  validates :name, length: {maximum: 10}
  validates :email, presence: true
end
```

2. has_many 表关系校验

除了对表的字段能快速进行校验工作外， 还有`has_many` 这种对表关系进行约束的方法能快速的实现表与表之间的绑定关系。 比如如下
下方的model代码， 可以看到， Guest表通过`has_many` 绑定了book表， book表通过`belongs_to`绑定了Guest表， 并且两者
之间是一对多，还是多对一的关系都能通过英文表达反馈出来。

至于外键字段绑定的问题， rails会自动在运行时做处理。无需用户关心。 注意命名方式的讲究。 这里绑定时是单数， 代表的是记录

```ruby
class Guest < ApplicationRecord
 # constraint guest name to be at most 10 characters
 validates :name, length: {maximum: 10}

 has_many :book
end

class Book < ApplicationRecord
 belongs_to :guest
end

```

我们可以快速的通过 rails 的 console来对表进行操作， 比如

```ruby
#! /usr/local/bin/sh

rails console

first_guest = Guest.first # 通过model名.first快速拿到该表第一条记录, 返回类型是Guest

first_guest_book = first_guest.books; 
```

3. 创建静态页面

使用命令： rails g controller StaticPages home help

执行上述命令后， 会生成名为`static_pages_controller`的rb文件， 该文件即单controller文件。 相比较于 g scaffolding 这个命令，
g controller不会管到Model层， 只会生成Controller和View， 方便用于没有状态的静态页面的生成.(注意命令的命名方式一定要是大驼峰)

执行后，会生成如下文件

- controllers
  - static_pages_controller.rb
- views
  - static_pages
    - help.html.erb
    - home.html.erb

注意： 

- 可以执行 `rails destroy [controller/model] StaticPages[大驼峰对应内容] home help`的形式undo通过CLI创建的文件。

- 可以执行 `rails db:rollback` 来undo一次migration操作

- 可以执行 `rails db:migrate VERSION=0` 来undo所有的migration操作

ruby当中的html模版为`x.html.erb`文件, 其模版语法形式类似于ejs, jsp, 能直接在html模版里嵌套ruby语法. 当中只需要知道2个书写样式就行, 一个是`<% %>`, 表示执行ruby语句, 另一个是 `<%= %>`, 表示不仅执行还要把结果返回.  比如见如下例子

```ruby
# home.html.erb

<% provide(:title, "Home") %> # ruby函数 provide,直接提供一个哈希给到该模版使用
<title><%= yield(:title) %></title> # yield函数, 拿到provide的值, 并且返回渲染出来.
<h1>Sample App</h1> <p>
This is the home page for the
<a href="https://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application.
</p>
```

除了标准的erb模版之外, rails还支持其他的模版语法, 比如haml, 其模版样式如下

```ruby
%section.container
  %h1= post.title
  %h2= post.subtitle
  .content
    = post.content
```

从上能看到, haml的语法基本就是markdown语法, 不过现在可选项多, 了解一下即可.

对于全局性的模版, 在laytous文件夹下有application.html.erb文件, 用于提供全局重复的渲染模版, 见如下代码

```ruby
 <!DOCTYPE html>
<html> <head>
<title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title>
<meta charset="utf-8"> 
# 下方tag都是standard pipeline, 必须要启用, 能帮助做很多事情.
<%= csrf_meta_tags %>  # cross-site request forgery, 用于规避csrf跨站请求攻击.
<%= csp_meta_tag %> # Content Security Policy, 用于规避XSS攻击
<%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %> # 加载CSS文件
<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %> </head> # 加载JS文件
<body>
<%= yield %>
</body> </html>
```

路由改变.

当页面不断增多时, 可以看到路由如下

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  get 'static_pages/help'
  get 'static_pages/about'
  get 'static_pages/contact'
  resources :guests
  resources :entries
end
```

上面的路由表里, root与get指定的路由方式不一样, 当为root时, 使用的#, 但是get时则是/.

自动化测试:

可以使用`guard` 这个gem进行rails项目的自动化测试, 该gem需要额外安装, 并需要在项目根目录提供Guardfile, 内容如下.

```ruby
require 'active_support/core_ext/string'
# Defines the matching rules for Guard.
guard :minitest, spring: 'bin/rails test', all_on_start: false do
  watch(%r{^test/(.*)/?(.*)_test\.rb$})
  watch('test/test_helper.rb') { 'test' }
  watch('config/routes.rb') { interface_tests }
  watch(%r{app/views/layouts/*}) { interface_tests }
  watch(%r{^app/models/(.*?)\.rb$}) do |matches|
    ["test/models/#{matches[1]}_test.rb",
     'test/integration/microposts_interface_test.rb']
  end
  watch(%r{^test/fixtures/(.*?)\.yml$}) do |matches|
    "test/models/#{matches[1].singularize}_test.rb"
  end
  watch(%r{^app/mailers/(.*?)\.rb$}) do |matches|
    "test/mailers/#{matches[1]}_test.rb"
  end
  watch(%r{^app/views/(.*)_mailer/.*$}) do |matches|
    "test/mailers/#{matches[1]}_mailer_test.rb"
  end
  watch(%r{^app/controllers/(.*?)_controller\.rb$}) do |matches|
    resource_tests(matches[1])
  end
  watch(%r{^app/views/([^/]*?)/.*\.html\.erb$}) do |matches|
    ["test/controllers/#{matches[1]}_controller_test.rb"] +
      integration_tests(matches[1])
  end
  watch(%r{^app/helpers/(.*?)_helper\.rb$}) do |matches|
    integration_tests(matches[1])
  end
  watch('app/views/layouts/application.html.erb') do
    'test/integration/site_layout_test.rb'
  end
  watch('app/helpers/sessions_helper.rb') do
    integration_tests << 'test/helpers/sessions_helper_test.rb'
  end
  watch('app/controllers/sessions_controller.rb') do
    ['test/controllers/sessions_controller_test.rb',
     'test/integration/users_login_test.rb']
  end
  watch('app/controllers/account_activations_controller.rb') do
    'test/integration/users_signup_test.rb'
  end
  watch(%r{app/views/users/*}) do
    resource_tests('users') +
      ['test/integration/microposts_interface_test.rb']
  end
end

# Returns the integration tests corresponding to the given resource.
def integration_tests(resource = :all)
  if resource == :all
    Dir['test/integration/*']
  else
    Dir["test/integration/#{resource}_*.rb"]
  end
end

# Returns all tests that hit the interface.
def interface_tests
  integration_tests << 'test/controllers'
end

# Returns the controller tests corresponding to the given resource.
def controller_test(resource)
  "test/controllers/#{resource}_controller_test.rb"
end

# Returns all tests for the given resource.
def resource_tests(resource)
  integration_tests(resource) << controller_test(resource)
end
```

当配置之后, 即可以在控制台执行 `bundle exec guard` 命令执行, 之后每当controller进行改变之后, 就会重新跑一次整合测试, 保证程序没有问题.

guard的文档: `https://github.com/guard/guard/wiki`

如果碰到报错, 可以尝试执行 `bin/spring stop` 进行停止(spring是rails里用于测试的包, 它会预先加载测试的消息以加速测试的进程). 之后再执行 `bundle exec guard`

#### 模版自定义helpers

上述的内容看到了一些能够直接在模版文件里使用的helper函数, 比如`stylesheet_link_tag` 用来帮助处理在模版渲染中的一些问题, 那如果要自己创建一个能用在模版里的函数应该如何做呢?

在rails里可以在app/helpers文件夹下进行函数的增加, 比如

```ruby
module ApplicationHelper
  # Return the full title
  def full_title(page_title = '')
    base_title = "Yahaha, Helper"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end
```

上面的代码在ApplicaitonHelper里增加了, 那么所有的模版文件都能用到. 如下

```ruby
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    # 这里用到自定义helper函数
    <title><%= full_title(yield(:title)) %></title>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

rails模式的函数书写方式

```ruby
def string_message(str = '')
  return "empty string!" if str.empty?
  return "nonempty"
end

# 相比较于if else, 一眼就能看出优劣
def string_message(str = '')
  if str.empty?
    'empty string!'
  else
    'nonempty'
  end
end

# 对于?号的书写方式, 还有带!的方法, 这类带!(叫bang)号的方法, 会mutate原来的数组,
# 而不是返回一个新的数组

# 还有个代码块传入的速写方式经常看见, 如下
%w[A B C].map(&:downcase)  # 叫做 symbol-to-proc, 是rails独有的,不是ruby的特性,(2.7版本才加入ruby core)

# 等价于
%[A B C].map {|c| c.downcase} # 上述带&:的方式省略了取值的重复代码

# 哈希数据结构里的 => (叫做hashrocket)
user = {'first_name' => 'aaa', 'last_name' => 'bbb'}

# symbol -> 唯一,不带任何方法的string对象. 用得极多, 基本参数都用, 哈希的key也基本都用symbol
:name
user = {:first_name => 'aaa', :last_name => 'bbb'}
# 取值: 
user[:first_name]
# 普通的json格式也是可以用的, 效果一样.(ruby1.9以后) 
# 其本质还是转为了symbol就是了, rails里还是推荐写成symbol的形式, 因为取值还是要写symbol
user = {first_name: 'aaa', last_name: 'bbb'}

# 此外有一个hash结构常用的方法merge需要注意一下
{ :a => 100, :b => 200 }.merge({ :b => 300  })
# {:a=>100, :b=>300} 
# 该方法和JS的Object.assign类似, 会合并传入到merge里的对象的内容, 而其他没有写的内容则不变, 该方法在表单处十分有用.

{ :a => 100, :b => 200 }.merge({ :b => 300, :c => 400  })
# {:a=>100, :b=>300, :c=>400} 
```

重新检查 `stylesheet_link_tag` 方法有什么用.

```ruby
 <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %>

 # 拆开后实际为, 神奇的地方在于rails里有大量这样的代码, 没有括号,只有方法名和参数
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 实际上, 括号在ruby里是可以被省略的, 上面的代码等价于
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')

# 并且上述的代码可以看到 media: 那个位置的数据结构明显是hash, 那哈希结构的{}去哪了?
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }

# 实际上, 在ruby里, 如果hash数据结构是方法的最后一个参数的话, 则哈希的{}括号可以被省略. 因此最终就看到了大量的方法写成了这个样子.
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 并且ruby解释器在这样的写法上不会去区分换行符和空格啥的, 因此就能看到某些方法写成下面这样也是合法的
fork_method :aaa, :bbb, :ccc, :ddd
            :eee, :fff, :ggg, :ttt

# 实际stylesheet_link_tag 这个方法会在html里转换为如下内容
# 其传入的参数的意义是, 让所有的css文件在任何屏幕适配下, 如果重新部署修改了css文件, 则重新加载新的css文件(reload, rails4.0加入的功能), 
<link rel="stylesheet" media="all" href="/assets/application.self- f0d704deea029cf000697e2c0181ec173a1b474645466ed843eb5ee7bb215794.css?body=1" data-turbolinks-track="reload" />
```

解释一下类

```ruby
class User
  attr_accessor :name, :email
  def initialize(attributes = {}) 
    @name = attributes[:name] 
    @email = attributes[:email]
  end
  def formatted_email 
    "#{@name} <#{@email}>"
  end
end
# attr_accessor : attribute accessors 即getter + setter
# initialize : 即类的构造方法
# @name, @email 即this.name, this.email
```

解释一下html模版创建

```ruby
<%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %> </div>
# link_to方法接收3个参数, 1,显示的内容, 2,跳转的位置, 3,class名字
# 会生成一个 <a></a>标签

<%= link_to image_tag("456.jpeg", alt: "Rails logo", width: "200"), "https://rubyonrails.org/" %>
# image_tag方法会生成一个<image />标签, 
# 接收3个参数, 1,image所在的位置(默认定位在app/assets/images下), 2,无法展示时显示的文字, 3,style属性
```

rails的静态资源pipeline天生支持scss编译, 无需其他的gem,如果想找使用bootsrap, 可以添加如下gem

`gem 'bootstrap-sass', '3.4.1'`

app/assets目录下的所有文件, 都会在rails服务器进行编译时自动输出, 包括下面的stylesheets文件夹, 都会自动被server引用, 因此不需要显示的在html模版里调. 所以类似于custom.scss之类的全局都要的文件, 直接丢到stylesheets文件夹里就得了,会自动生效. 比如

```scss
@import "bootstrap-sprockets";
@import "bootstrap";

body {
  padding-top: 60px;
  }
  section { overflow: auto;
  }
  textarea {
  resize: vertical;
  }
  .center {
  text-align: center;
  }
  .center h1 { margin-bottom: 10px;
  }
```

**asset pipeline** 是rails的一大特色, 这些放在assets文件夹下的images和stylesheets, 在前后端分离的场景下也能和Webpack一起使用, 当然, webpack默认是被rails支持的, 前端包管理工具则是yarn.

在rails的项目里, assets文件夹有3个, 在server进行静态资源打包时都会默认被用到, 分别如下

- app/assets: 当前app的静态资源
- lib/assets: 自己开发的依赖的静态资源
- vendor/assets: 第三方依赖的静态资源,默认不会被展示

详解一下app/assets文件夹(asset pipeline会使用到下面三个文件夹里的内容)

- config : 下面有manifest.js, 可以在其中手动指定rails服务器还需要去哪里加载css文件和js文件(或者文件夹)(通过使用Sprockets gem来完成), 不能指定图片
- images : 项目全局图片
- stylesheets : 项目全局css文件加载

需要注意的是 asset pipeline 会自动完成发布到生产时的CSS资源处理工作, 会组合所有的CSS文件为一个CSS文件(application.css),并最小化处理. 而scss文件则也会自动编译然后组合


关于短链接:

在渲染<a>标签时, 会有route相关的内容需要指定, rails提供了快速匹配route的别名形式, 只要在每个route对应的小写字母后加上_path, 就能调用到对应的url.

比如 /about , 那么在模版里渲染路由的时候, 在link_to方法里, 使用about_path作为参数就能匹配到 /about 路由. 具体是什么参考rails routes下controller对应给出的Prefix, 即 prefix + "_path" 就ok. 此外还有一个 + "_url" 的写法, 差别如下

root_path -> '/'
root_url  -> 'http://www.example.com/'

root_url 只会在重定向到站外资源时用到, 因为带全url地址.

基于上述的认知, 路由可以优化为如下样式

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  # get 'static_pages/help'
  # get 'static_pages/about'
  # get 'static_pages/contact'
  # 参数1: url查找显示用的url, 参数2: to: 具体查找的controller下的方法, 参数3: as: 起别名, 在模版里引入时要改成helf_path, 而不是help_path(看着没啥用)
  get '/help', to: 'static_pages#help', as: 'helf'
  get '/about', to: 'static_pages#about'
  get '/contact', to: 'static_pages#contact'
  resources :guests
  resources :entries
end
```

记得生成整合测试: `rails generate integration_test site_layout`, 试试routes的修改是否正确, `rails test:integration` 执行E2E测试

```ruby
require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest
  test 'layout links' do
    get root_path
    # assert_template 会渲染整个html模版出来
    assert_template 'static_pages/home'
    # assert_select 是dom选择器, 会通过querySelector查找, 每执行一次,就往下诺
    assert_select 'a[href=?]', root_path, count: 2
    assert_select 'a[href=?]', help_path
    assert_select 'a[href=?]', about_path
    assert_select 'a[href=?]', contact_path
  end
end
```

#### Model层

使用命令: `rails g model Guest name:string email:string` 创建一个model层. 当然也能手动创建,还记得创建一个controller层怎么打吗? `rails g controller Guests new`

命名规则: Model层创建使用单数, 而controller层使用复数. 因为Model表示的是一条记录(但是数据库里的表会自动变成复数)

rails提供的migration功能减少了用户需要去学复杂sql的成本, 并且migration每次都是基于创建的时间戳进行的递增操作, 时间戳记录(UTC标准)的设定规避了多个开发者进行migration操作会重复的可能,便于多人协作. 来看下migrate的代码

```ruby
class CreateGuests < ActiveRecord::Migration[7.0]
  def change
    # create_table方法接收参数为表名, 然后接收一个code block做具体字段的设定
    create_table :guests do |t|
      t.string :name
      t.string :email
      # timestamps方法会创建created_at, updated_at两个字段.
      t.timestamps
    end
  end
end
```

上述代码为执行migration后自动生成的, 其中实现了change方法, chang方法决定了migration时如何对数据库进行操作. 当创建后, 执行 `rails db:migrate` 即可进行migration操作.

在db目录下, 除了migrate文件夹外, 还有schema.rb文件, 该文件作用如下

1. rails会使用该文件追踪整个db的结构, 其代码内容为每次执行`create model`后就会往里面添加.

2. 由于该文件的存在,因此大多数的migration操作都是可逆的, 通过`rails db:rollback`实现. 其原理是通过migration当中的change方法实现的, 而如果需要进行不可逆的操作, 则可以实现up, down方法来替换change方法, 以分别对应migrate(up)时的操作与rollback(down)时的操作.

对于在控制台进行rails操作, 可以执行 `rails console --sandbox`来进入沙盒环境, 这样的话,所有的操作都会在退出控制台时回滚, 而不必担心对数据造成影响.

控制台操作时, Guest.new + Guest.save  == Guest.create. 要求传入一个哈希, 因此可以把{}拆掉,直接写成

```ruby
foo = Guest.create(name: "Foo", email: "foo@bar.com")
```

就能在控制台完成表操作. 其他简单的操作如下(这些操作虽然是在控制台完成的, 实际代码中也能通过这些代码与数据库完成CRUD操作)

- 如果需要删除, 则执行`Guest.destroy`, 
- 如果需要具体查某一个id的记录 `Guest.find(id)`
- 如果需要拿第一条记录 `Guest.first`
- 如果需要拿第二条记录 `Guest.second`
- 如果需要拿最后一条记录 `Guest.last`
- 如果需要拿全部的记录 `Guest.all` : 返回内容是假数组, 实际为Guest::ActiveRecord_Relation
- 具体通过某个字段查 `Guest.find_by_<字段名>` , 比如 Guest.find_by_name
- 通过手写自定义SQL查 `Guest.find_by_sql(<传sql字符串>)`
- 如果需要修改记录, 则通过修改model对象实例的属性后, 再实例.save进行保存. 比如: `qq.name = 'bad' ; qq.save`
- 或者嫌麻烦, 则可以通过实例.update方法进行修改, 比如 `qq.update(name: "wao")` , 会自动去修改传入部分的字段属性, 不会全部修改. 返回值为true/false. 当然, 实际也是设定 + .save的组合
- update方法在修改时会进行字段全校验, 如果需要跳过校验只修改某些字段,可以使用`qq.update_attribute(:name, "asas")` 方法, (注意此时是2个参数, 分别对应key, value)


> 来看下字段校验相关的东西

小技巧: 在测试的时候, 通过`rails test:<test文件夹下目标文件夹名>`会自动跑目标文件夹下的所有test

- valid? : 该记录是否通过了所有的校验
- guest.errors.messages : 返回hash格式的所有校验错误信息
- guest.errors.full_messages : 返回数组格式的所有校验错误信息
- presence : 校验字段是否为空
- length : 校验字段长度
- format : 正则校验,有Rubular这个网站可以提供ruby的正则校验功能.
- uniqueness : 校验字段值是否在表里唯一
  - 对于唯一性校验而言,其做法是扫描全表, 因此会出现效率问题, 可以通过增加索引解决.
  - 增加索引可以通过`rails g migration add_index_to_guests_email` 来对表进行操作
  - 上面的命令能看到, add_字段/索引_to_表名_字段名 是脚手架的格式, 能立即创建migrate文件, 之后可以往migrate文件里加上新增index的语句,如下(注意,如果打开了rails的sandbox模式,migration会强制失败)


```ruby
class AddIndexToGuestsEmail < ActiveRecord::Migration[7.0]
  def change
    # 新增索引, 参数1: 表名, 参数2: 字段名, 参数3: 属性特征
    add_index :guests, :email, unique: true
  end
end
```

```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  # validates :name, length: {maximum: 10}
  # callback for model, mutate email attr with downcase method
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  # Constant with capital letter
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 200 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  has_many :book
end
```

> 来看下密码加密

除了校验之外, 一般保存到数据的密码都需要做加密操作, rails提供了has_secure_password方法,只需要在model层里添加该方法, 即会做以下几个动作

1. 会自动将密码哈希后保存到数据库, 表字段名为`password_digest`(该字段必须有以启用has_secure_password方法), 可执行脚本命令创建migration `rails g migration add_password_digest_to_guests password_di
gest:string`, 执行后会生成如下migration
```ruby
class AddPasswordDigestToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :password_digest, :string
  end
end
```
2. 会自动增加2个虚拟属性 `password` `password_confirmation`, 两个虚拟属性自带非空与匹配判断. 虚拟的意思是在rails里有,但是在数据库里不存在
3. 会自动增加一个`authenticate`方法, 如果密码正确, 该方法将返回目标Model实例, 否则返回false

如上在增加了`password_digest`之后, 只要`db:migrate`了, 会立刻要求增加`bcrypt`这个gem包,该包提供了哈希算法, 就算被黑掉被搞走整个数据库, 也难以破解密码.

**简单来说, 就是数据库保存的字段是password_digest, 但是实际上是通过了bcrypt这个gem, 在对应的Model下新增了password, password_confirmation 两个字段进行前端的填充, 当哈希算法匹配password与数据库的password_digest一致时, 则放行通过. 这样就做到了数据库保存的密码其实都是哈希之后的密码, 具体怎么哈希的没人知道,rails只需要做参数收集和算法匹配的动作**

此时Guest Model变成如下

```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  # validates :name, length: {maximum: 10}
  # callback for model, mutate email attr with downcase method
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  # Constant with capital letter
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 200 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }

  # only offer the presence validation, only work with empty.
  has_secure_password
  # therefore, we need another validates to validate password field
  validates :password, presence: true, length: { minimum: 6 }
  has_many :book
end
```

实际数据库保存的记录如下

```ruby
 id: 1,                                                      
 name: "zhangsan",                                           
 email: "abc@gmail.com",                                     
 created_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00, 
 updated_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00, 
 password_digest: "[FILTERED]"> 

 Guest.first[:password_digest]
 "$2a$12$0EJjT1MT8FX.E/5mM27SUea0oQn/nLIRkeS7GWmS/KpZZKqSOtITK" 
```

增加到了model层的has_secure_password方法, 自动增加了`authenticate`方法给到了目标的Model的对象上, 此时如果输错密码和输成功密码如下显示.

```ruby
3.0.0 :014 > abc = Guest.first
  Guest Load (0.8ms)  SELECT `guests`.* FROM `guests` ORDER BY `guests`.`id` ASC LIMIT 1
 =>                                                                
#<Guest:0x00007ff6b23c3c68                                         
...                                                                
3.0.0 :015 > abc.authenticate("yoho")
 => false # 登录输错返回false
3.0.0 :016 > abc.authenticate("yohooo")
 => false 
3.0.0 :017 > abc.authenticate("aaaaaa")
 => # 登录正确返回用户表记录信息
    # 如果只需要返回true, 那就 !!abc.authenticate("aaaaaa") 就好了, 方便快速.
#<Guest:0x00007ff6b23c3c68                                         
 id: 1,                                                            
 name: "zhangsan",                                                 
 email: "abc@gmail.com",                                           
 created_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00,       
 updated_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00,
 password_digest: "[FILTERED]">   
```

#### Rails环境问题

rails 项目默认自带三个环境, 分别是 test, development, production, 当中默认的环境是development, 可以通过 Rails.env 来获取当前环境信息, 并可以通过 Rails.env.development? 来判断是否是目标环境.

在启动时可以指定环境来修改启动的目标环境, 如下

`rails server --environment production`

此时db的migration动作也应该修改为production, 默认不输入环境变量的话, 则都是development

`rails db:migrate RAILS_ENV=production`

某些云平台对ruby项目支持良好的, 会自动切换为production模式, 比如heroku.

获取参数打印

```ruby
  <%= debug(params) if Rails.env.development? %>

  # 同时model对象的属性可以.to_yaml输出
  puts abc.attributes.to_yaml
```

#### Route resources 资源

在前面已经提到过了这一特殊的route类型, 即resources,  当标记某一个model层时, 会自动往routes添加所有常用的RESTFUL路由以及其controller匹配. 当然, 并不是所有情况下都需要使用脚手架来生成代码, 如果我们手动添加routes相关的内容, 则可以手动自己配置controller的实现方法.

见一个例子

```ruby
# routes.rb
  resources :guests

# controller
  def show
    @guest = Guest.find(params[:id])
  end

# view
<%= @user.name %>, <%= @user.email %>
```

如果需要在代码里debugger, 可以在具体代码位置加上debugger,来进行debugger调试, 所有报错信息会在控制台打印出来, 包括具体哪一行错了(需要byebug gem的支持,如果加了没用的话,确认看看是否装了这个gem).

```ruby
  def show
    @guest = Guest.find(params[:id])
    debugger
  end
```

渲染erb模版时, 每个helper对应的都是模版里独自能调用的方法, 比如渲染avatar
这里的例子用了gravatar, 提供的图片保存功能, 会将邮箱和图片进行映射显示.

```ruby
module GuestsHelper
  def gravatar_for(guest)
    gravatar_id = Digest::MD5.hexdigest(guest.email.downcase)
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"
    image_tag(gravatar_url, alt: guest.name, class: 'gravatar', size: 50)
  end
end

# 在模版里的使用
<% provide(:title, @guest.name) %> 
<div class="row">
  <aside class="col-md-4"> 
    <section class="user_info">
      <h1>
      <%= gravatar_for @guest %> 
      <%= @guest.name %>
      </h1> 
  </section>
  </aside> 
</div>
```

ruby2.0版本之后, 对于函数的传参, 有以下优化

```ruby
# 1. 原模式
module UsersHelper
  # Returns the Gravatar for the given user.
def gravatar_for(user, options = { size: 80 })
  size = options[:size]
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}" image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end 
end

# 2. 优化模式
module UsersHelper
  # Returns the Gravatar for the given user.
def gravatar_for(user, size: 80)
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}" image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end 
end

# 能看到参数传递的位置确实有了变化, 不需要再取值和用hash明显传递参数即可拿到默认参数
```

erb模版提供了form_with的内置方法, 用于动态构建一个目标model层的表单内容

```ruby
<% provide(:title, 'Sign up') %> <h1>Sign up</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
# form_with内置函数, 参数1: 目标model, 参数2: local: true, 发送ajax请求
<%= form_with(model: @guest, local: true) do |f| %> 
  # f.label 会构建<label>标签, f.text_field, 会构建<input type='text' />标签.
  # 并且会自动与指定的model绑定
  <%= f.label :name %>
  <%= f.text_field :name %>
  <%= f.label :email %>
  <%= f.email_field :email %>
  <%= f.label :password %>
  <%= f.password_field :password %>
  <%= f.label :password_confirmation, "Confirmation" %> 
  <%= f.password_field :password_confirmation %>
  <%= f.submit "Create my account", class: "btn btn-primary" %>
<% end %>
</div> 
</div>

#除了上面的常规内容外, 还会构建一个隐藏的input框
<input type="hidden" name="authenticity_token" value="KxgJwmTX9IXB8BkMktfWq_9P_RvASMTS9Yy2-rqv6exL_fiBI4aGjtssoiD9fFfGw6kazZLcdtc-BcqnUFakVQ" autocomplete="off">

# 该input框会带授权的token, 专门用于避免csrf攻击提供. 开发者不需要关注, rails会全自动处理好这些
```

关于表单提交处理方法要详细解释一下

下方代码通过初始化**params**的形式是异常危险的, 初始化params会将用户输入的所有内容都提交给后台处理, 这也就意味着如果攻击者想要输入一些bug代码也是无法被阻止的, 因此也就无法防止XSS攻击.

在某些4.0版本之前的rails项目中, 还能在model层看到**attr_accessible**用来解决注入攻击问题, 但是在4.0版本后, 官方推荐全部在view层使用强类型参数来解决这个问题.

```ruby
 # POST /guests or /guests.json
  def create
    # 等价于 @user = User.new(name: "Foo Bar", email: "foo@invalid", password: "foo", password_confirmation: "bar")
    @guest = Guest.new(params[:guest]) # 这种写法是rails版本迭代的产物, 当然能用, 但是4.0版本后容易引起安全问题
    if @guest.save
      # rails内置的erb模版的方法, 就是一个会自动消失的提示
      flash[:success] = "Welcome to the Sample App"
      # 等价于 redirect_to guest_url(@guest), 会自动导到详情页
      redirect_to @guest
    else
      render 'new'
    end
  end
```

强类型参数的写法如下

```ruby
# 把guest对象丢进来, 但是permit,只允许指定这几个字段放行
params.require(:guest).permit(:name, :email, :password, :password_confirmation)

# 但这样直接写在controller里对应的方法内的话就太丑了, 这里可以将其抽离为一个private的方法
  # Only allow a list of trusted parameters through.
  def guest_params
    params.require(:guest).permit(:name, :email, :password_confirmation)
  end

# 然后实际使用时, 
def create
  @guest = Guest.new(guest_params)
  if @user.save
    # Handle a successful save.
  else
    render 'new' 
  end
end
```

注册提交时一般都会有报错的处理, 此时可以在views文件夹里新增shared文件夹来保存共用的内容, 比如

```ruby
# _error.html.erb
<% if @guest.errors.any? %> <div id="error_explanation">
<div class="alert alert-danger">
The form contains <%= pluralize(@guest.errors.count, "error") %>.
</div>
<ul>
<% @guest.errors.full_messages.each do |msg| %>
<li><%= msg %></li> <% end %>
</ul>
</div> <% end %>

# pluralize 是一个很有用的函数, 属于ralis内置的helper类, 能直接调用. 
# >> helper.pluralize(3, "erratum") => "3 errata" 会自动将单词进行复数化.
```

除了提交之外, 一般还会有提示, 此时可以用内置的flash方法, 模版如下

```ruby
# 加到application.html.erb里
  <% flash.each do |message_type, message| %>
    <%= content_tag(:div, message, class: "alert alert-#{message_type}") %>
  <% end %>
```

此时controller如下

```ruby
  def create
    # 等价于 @user = User.new(name: "Foo Bar", email: "foo@invalid", password: "foo", password_confirmation: "bar")
    @guest = Guest.new(guest_params) # 这种写法是rails版本迭代的产物, 当然能用, 但是4.0版本后容易引起安全问题
    if @guest.save
      flash[:success] = "welcome to Sample App #{@guest[:name]}"
      redirect_to @guest
    else
      render 'new'
    end
  end
```

#### 生产环境的一些问题

1. 如果需要设定rails开启ssl,可以在项目的production.rb里,修改如下内容

```ruby
config.force_ssl = true
```

2. 生产环境Puma服务器比WEBrick服务器好, 5版本后默认是Puma, 老版本如果要更改, 先增加puma依赖,然后在config文件夹下使用如下puma.rb配置

```ruby
# Puma configuration file.
max_threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 } 
min_threads_count = ENV.fetch("RAILS_MIN_THREADS") { max_threads_count } 
threads min_threads_count, max_threads_count
port ENV.fetch("PORT") { 3000 }
environment ENV.fetch("RAILS_ENV") { ENV['RACK_ENV'] || "development" } 
pidfile ENV.fetch("PIDFILE") { "tmp/pids/server.pid" }
workers ENV.fetch("WEB_CONCURRENCY") { 2 }
preload_app!
plugin :tmp_restart
```

3. Procfile是rails项目里的标配, 用于告诉生产的机器如何运行Puma服务器启动项目, 它应该在项目根目录下

```ruby
# Procfile
web: bundle exec puma -C config/puma.rb
```

4. 生产数据库的配置, 需要在config/database.yml下修改, 比如如下
   
```yaml
default: &default
  adapter: mysql2
  encoding: utf8mb4
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  username: root
  password: yangyang123
  host: localhost
  port: 3306

development:
  <<: *default
  database: mydiary_development

test:
  <<: *default
  database: mydiary_test

production:
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  database: sample_app_production
  username: sample_app
  password: <%= ENV['SAMPLE_APP_DATABASE_PASSWORD'] %>
```

### 登录功能

路由准备: `rails g controller Sessions new`

登录功能只需考虑登录确认, 注册, 和登出功能, 因此可以做如下3个路由(注: RESTFUL)

```ruby
  get '/login', to: 'sessions#new'
  post '/login', to: 'sessions#create'
  delete '/logout', to: 'sessions#destroy'
```

这里只考虑传统的session登录形式, 来准备一下登录页面

```ruby
<% provide(:title, "Log in") %> 
<h1>Log in</h1>
<div class="row">
  <div class="col-md-6 col-md-offset-3">
  # 注意这里的scope参数, form_with已经内置提供了session登录
  <%= form_with(url: login_path, scope: :session, local: true) do |f| %>
    <%= f.label :email %>
    <%= f.email_field :email, class: 'form-control' %>
    <%= f.label :password %>
    <%= f.password_field :password, class: 'form-control' %>
    <%= f.submit "Log in", class: "btn btn-primary" %> 
  <% end %>
  <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div>
</div>
```

上述代码中以form_with方法渲染出来表单, 传到controller时会以`params`被controller方法接收使用. 比如`params[:session]`

当进行登录操作时, 服务器会得到下面的内容

```ruby
Started POST "/login" for ::1 at 2022-09-13 22:43:27 +0800
Processing by SessionsController#create as HTML
  Parameters: {"authenticity_token"=>"[FILTERED]", "session"=>{"email"=>"stan@gmail.com", "password"=>"[FILTERED]"}, "commit"=>"Log in"}
```

从Parameters能看到, controller使用的Params本质其实就是哈希, 用户提交的敏感信息会自动过滤,并在session当中保存提交. 等价于 params[:session], 因此用户登录即可以如下实现

```ruby
class SessionsController < ApplicationController
  def new; end

  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    # 只要验证结果,所以!!取boolean
    if guest && !!guest.authenticate(params[:session][:password])
      log_in guest
      # rails提供的重定向方法, 会自动转成 guest_url(guest)
      redirect_to guest
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end

  def destroy; end
end
```

登录涉及重要逻辑,记得写E2E测试 `rails g integration_test guests_login`

```ruby
require 'test_helper'

class GuestsLoginTest < ActionDispatch::IntegrationTest
  test 'login with invalid information' do
    get login_path
    assert_template 'sessions/new'
    post login_path, params: { session: { email: '', password: '' } }
    assert_template 'sessions/new'
    assert_not flash.empty?
    get root_path
    assert flash.empty?
  end
end
```

小技巧1: 在rails中常用的&&符判断可以用ruby独有的格式 `&&=` `||=` 进行替换, JS在ES10引入了这个特性, 用于改善 A = A && B, A = A || C 这样冗余的写法, 比如如下

```ruby
# 如果@foo不为空, 那就用foo, 比如已经查出了某个用户时的操作.
# 如果@foo为空, 则默认用'bar'
# ||= 读法: or equals
@foo = @foo || 'bar' 
@foo ||= 'bar'
# 如果@foo不为空, 那就不用foo, 用'baz'
# 如果@foo为空, 那就用foo, 不用'baz'
@foo = @foo && 'baz'
@foo &&= 'baz'
```

这样的话, 就变成了高手写rails的样子, 见如下代码

```ruby
module SessionsHelper
  def log_in(guest)
    session[:guest_id] = guest.id
  end

  def current_guest
    # 如果@current_guest为空, 则去查用户, 如果不为空, 则不去查,用现成的.
    # 因为查不到的话, 返回的是nil, 所以这种写法能保证不出空指针异常, 并且能保证查询数据不会出错
    @current_guest ||= Guest.find_by(id: session[:guest_id]) if session[:guest_id]
  end
end
```

小技巧2: rails里有一个叫做 `safe navigation` 的操作符, 写作 **&.**, 它是 obj && obj.method 的一种简写方式, 可以省略为 obj&.method的格式, 比如

```ruby
  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    # 注意这里的写法, 其实就是 guest && guest.authenticate
    if guest&.authenticate(params[:session][:password])
      log_in guest
      # rails提供的重定向方法, 会自动转成 guest_url(guest)
      redirect_to guest
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end
```

> 使用webpakcer进行前端资源的自动加载打包

rails里除了自带的(7.0以前)Sprockets 可以用于自动打包app/assets目录下的静态资源外, 也能同时使用webpack来对前端资源进行打包优化处理

这里需要注意的是, rails+webpacker的模式, 其本质还是服务端渲染, 只是webpacker将打出来的静态资源绑在了html.erb文件上, 然后再通过rails的views层渲染成html然后返回给用户展示. 因此, 就有点类似于在JSP里+了前端框架的运行时环境来实现服务端渲染.

当然, 由于目前前后端分离已经成为了主流, 因此就算是通过rails开发项目, 很多场景下其实也只会 `rails new xxxx项目 --api` 的形式, 只写api而已, 而静态资源则是分开开发的. 

所以这里要理清楚为什么有些rails项目它里面会有webpack这种东西, 而有些又没有. 而之所以需要运行webpack的devServer, 是因为在开发阶段希望让webpack去监听所有前端资源的变化, 以及时进行再打包. 因此, rails + webpacker的项目, 其生产环境并不需要node服务器的支持, 因为所有的资源最后其实都是通过rails的服务器的模版渲染放出去的.

使用webpacker:

1. 既有项目: Gemfile里新增 `webpacker` 这个 gem, (注意,随着7.0版本的发布, 该gem已经deprecated, 但是老项目依旧很多在用), 之后执行 `bundle install` 安装gem包, 安装完成后, 执行`rails webpacker:install` 完成webpacker的安装.
2. 新项目: `rails new xxx --webpack` 即可自带

安装后会增加以下几个文件夹/文件

1. app/javascript , 用于前端代码的保存
2. config/webpacker.yml, 用于配制Webpacker
3. babel.config.js, 配置Babel编译器
4. postcss.config.js, 配置PostCss的编译器
5. .browserslistrc, 配置适配浏览器
6. package.json, 会自动执行yarn命令进行依赖安装

同时会增加以下几个方法用来在.erb模版文件里引入相关静态资源文件

1. javascript_pack_tag  : 对应 Sprockets(默认) 的 javascript_include_tag
2. stylesheet_pack_tag : 对应 stylesheet_link_tag
3. image_pack_tag : 对应 image_url
4. asset_pack_tag : 对应 asset_url

之后即可通过yarn add来安装需要的前端资源.

安装完后, 还需要到config/webpack/environment.js里对需要用的资源进行导出工作给到模版使用.

```javascript
// config/webpack/environment
const { environment } = require("@rails/webpacker");

const webpack = require("webpack");
environment.plugins.prepend(
  "Provide",
  // 这些js的包会被加载到erb模版的全局变量里.
  new webpack.ProvidePlugin({
    $: "jquery/src/jquery",
    jQuery: "jquery/src/jquery",
  })
);

module.exports = environment;
```

如果项目下有app/javascript/packs/application.js 的话,webpacker会自动创建一个前端pack资源叫做application, 此时前端模版写成如下即可引用资源. 

所有资源都会被rails代为启动webpack自动进行打包, 不需要专门启动webpack devServer进行处理, 所有打包生成的资源, 都会丢到public/packs文件夹下管理.

```javascript
// 此时 packs/application.js如下内容
require("@rails/ujs").start();
require("turbolinks").start();
require("@rails/activestorage").start();
require("channels");
require("jquery");
// import的内容会被直接执行.
import "bootstrap";
```

```ruby
<%= csrf_meta_tags %>
<%= csp_meta_tag %>
<%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %>
<%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
# js只需要这一个就好了, 上面两个都是sprockets提供的, 可以不用.
# 这个ruby方法的作用是, 去加载一个叫做application的webpack的资源包
# 该资源包对应app/javascript/packs/application.js
<%= javascript_pack_tag "application" %>
<%= stylesheet_pack_tag "application" %>
```

这里注意packs文件夹可以只保存统一入口文件, 没必要所有文件都往这里堆, 只要引用关系能被找到就行, 比如如下结构在实际项目里比较合理

此外,关于CSS文件还需要额外注意一下, webpacker本身内部使用PostCSS解析器, 因此可以使用SCSS框架来做CSS资源. 但是为了让webpack能加载到scss资源, 这里需要在packs/application.js里统一对scss文件进行导入才可以被正常的加载使用.

- app/javascript
  - packs:
    - application.js (entry, scss文件的import也要写在这里面)
  - src:
    - mycomponent
      - component_1.js
      - component_2.js
    - index.js(统一导入js资源)
    - my_styles
      - my_style_1.scss
      - my_style_2.scss
    - index.scss (用于统一加载my_styles里所有的资源, 然后再在application.js里import导入后使用)
  - images:
    - logo.svg
    - xxx.png

关于静态资源的加载(图片,文件等), 也需要在application.js里统一导入, 如上面的images文件夹, 如下进行全量图片导入

```javascript
const images = require.context("../images", true)
const imagePath = name => images(name, true);
```

之后webpack会将静态资源打包输出到项目的public/packs/media文件夹里, 

举个例子: 某张图片位于 app/javascript/images/my-image.jpg, 则上述加载后, 会被输出到 public/packs/media/images/my-image-xxxx123.jpg. 实际在erb模版里使用的话, 可以使用 `image_pack_tag media/images/my-image.jpg` 即可引用, 如果是icon, 则 `favicon_pack_tag media/images/my-image.icon` , 如果嫌麻烦, 也能使用 `asset_pack_path`

此外,webpack加载的配置, 可以在config/webpacker.yml里手动设定.


> 解释一下fixtures

fixtures处在test(或者spec)文件夹下, 是测试用的预载数据, 默认格式都是yml, 当然, json, xml, excel文件啥的都应该是放在fixtures文件夹里面的.

yml里支持嵌入ruby语法, 可以直接拿到Model层里的类方法, 比如如下通过手动设定digest来拿到登录用户的信息

```ruby
# models/guest.rb
  def self.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end
```

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
```

之后在test文件里就能通过如下形式代码对yml文件里的数据进行加载

```ruby
  def setup
    @guest = guests(:michael)
  end
```

具体E2E测试如下, 执行 `rails test test/integration/guests_login_test.rb`

```ruby
require 'test_helper'

class GuestsLoginTest < ActionDispatch::IntegrationTest
  def setup
    @guest = guests(:michael)
  end

  test 'login with invalid information' do
    # get访问/login
    get login_path
    # post /login, 参数为后面的内容
    post login_path, params: { session: { email: @guest.email, password: 'password' } }
    # 重定向到 get /guest(id: guest[:id]), 即guest_path(@guest)
    assert_redirected_to @guest
    # 确认是否发生了重定向
    follow_redirect!
    # 重定向如果成功, 断言会渲染html模版, guests/show
    assert_template 'guests/show'
    # querySelector选目标标签, /login的 a标签数量应该为0
    assert_select 'a[href=?]', login_path, count: 0
    # querySelctor选目标标签, a标签应该为/logout
    assert_select 'a[href=?]', logout_path
    # querySelector选目标标签, 目标应该为 /guest/id
    assert_select 'a[href=?]', guest_path(@guest)
  end
end
```

### 退出功能

清除掉session的数据, 并且置当前user为nil即可

```ruby
module SessionsHelper
  def log_in(guest)
    session[:guest_id] = guest.id
  end

  def current_guest
    @current_guest ||= Guest.find_by(id: session[:guest_id]) if session[:guest_id]
  end

  def logged_in?
    !current_guest.nil?
  end

  # logout方法
  def log_out
    session.delete(:guest_id)
    @current_guest = nil
  end
end


# 然后controller里加上路由匹配方法进行调用就好了
  def destroy
    log_out
    redirect_to root_url
  end


 # 功能加完记得写测试方法
   test 'login with valid information followed by logout' do
    get login_path
    post login_path, params: { session: { email: @guest.email,
                                          password: 'password' } }
    assert is_logged_in?
    assert_redirected_to @guest
    follow_redirect!
    assert_template 'guests/show'
    assert_select 'a[href=?]', login_path, count: 0
    assert_select 'a[href=?]', logout_path
    assert_select 'a[href=?]', guest_path(@guest)
    delete logout_path
    assert_not is_logged_in?
    assert_redirected_to root_url
    follow_redirect!
    assert_select 'a[href=?]', login_path
    assert_select 'a[href=?]', logout_path, count: 0
    assert_select 'a[href=?]', guest_path(@guest), count: 0
  end
```

### remember me 功能

记住登录用户功能是一个容易被骇客的功能, 为了用户安全, 持久性的sessions可以遵循如下几条规则

1. 创建随机的字符串token用于用户本地持久化使用
2. 设定持久化过期时间
3. 将token的hash digest保存到数据库里
4. 本地保存的用户id进行加密
5. 使用本地加密的id与token数据去和数据库进行匹配

> 获取随机字符串

为了实现上述要求, 首先需要给表新增一个remember的字段,用于记录用户使用过的token

`rails g migration add_remember_digest_to_guests remember_digest:string`

然后给到用户使用的token, 可以使用base64实现, ruby标准库默认提供了`SecureRandom` 模块用于处理字符串的base6转换, 如下

```ruby
# 返回一个随机的token
SecureRandom.urlsafe_base64


# 之后为了提供随机token给到数据库, 可以往目标可以往目标Model里加入方法
  # 下方2个方法给数据库提供随机token
  def self.new_token
    SecureRandom.urlsafe_base64
  end

  # 从这可以看到, remember功能实际上保存的并不是用户的密码, 而是用户访问时
  # 所生成的一堆随机的base64字符串而已
  def remember
    # self是实例方法, Guest.x是类方法
    self.remember_token = Guest.new_token
    # 这个方法为ActiveRecord提供的,即update SQL
    update_attribute(:remember_digest, Guest.digest(remember_token))
  end
```

小技巧: 上述写法中同时出现了self与Guest, 这在代码中是非常容易混淆的, 因此有如下写法进行self方法的拆分

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token
  ...
  # class里再来一个class, 
  # 这个写法是rails里才有的写法, 相当于是将所有要以self.方法名命名的实例方法都转到一起写了, 其等价于
  # def self.digest; end   def self.new_token; encoding
  class << self
    def digest(string)
      cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost
      BCrypt::Password.create(string, cost: cost)
    end

    def new_token
      SecureRandom.urlsafe_base64
    end
  end

  def remember
    self.remember_token = Guest.new_token
    update_attribute(:remember_digest, Guest.digest(remember_token))
  end
end
```

> 其他步骤

在随机的base64字符串生成后, 然后就需要考虑设定过期时间的问题, ruby当中内置了非常丰富的时间/数据存储单位相关的方法. 无需引入任何第三方gem就能完成时间方面的设定

```ruby
# 比如
1.year.ago
10.weeks.from_now

1.kilobyte # 1024
5.megabytes # 5242880
```

之后便可以着眼回到controller的helper做一些登录时的修改

```ruby
module SessionsHelper
  def log_in(guest)
    session[:guest_id] = guest.id
  end

  # 修改了这里
  def current_guest
    if (guest_id = session[:guest_id])
      @current_guest ||= Guest.find_by(id: cookies.encrypted[:guest_id])
    elsif (guest_id = cookies.encrypted[:guest_id])
      # 如果remember me勾选的情况下加密的信息匹配,则继续往下查找
      guest = Guest.find_by(id: guest_id)
      if guest&.authenticated?(cookies[:remember_token])
        log_in guest
        @current_guest = guest
      end
    end
  end

  def logged_in?
    !current_guest.nil?
  end

  # 增加了忘记方法
  def forget(guest)
    guest.forget
    cookies.delete(:guest_id)
    cookies.delete(:remember_token)
  end

  def log_out
    forget(current_guest)
    session.delete(:guest_id)
    @current_guest = nil
  end

  # 增加了记住方法
  def remember(guest)
    guest.remember
    cookies.permanent.encrypted[:guest_id] = guest.id
    cookies.permanent[:remember_token] = guest.remember_token
    cookies[:remember_token] = { value: remember_token, expires: 5.years.from_now.utc }
  end
end
```

model层则需要把新的字段拿出来用于匹配

```ruby
attr_accessor :remember_token

  # 以下代码发生了修改
  def remember
    self.remember_token = Guest.new_token
    update_attribute(:remember_digest, Guest.digest(remember_token))
  end

  def authenticated?(remember_token)
    return false if remember_digest.nil?

    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end

  def forget(_guest)
    update_attribute(:remember_digest, nil)
  end
```

逻辑写好以后, 就可以往页面添加内容了

```ruby
# 登录表单添加如下内容
# 1. 生成label
<%= f.label :remember_me, class: "checkbox inline" do %> 
# 2. 生成label后, 生成一个checkbox标签, 字段名为remember_me
  <%= f.check_box :remember_me %>
  <span>Remember me on this computer</span>
<% end %>

# 登录方法里增加remember_me字段的判断
params[:session][:remember_me] == '1' ? remember(user) : forget(user)
```

小技巧: 整合测试里常会看到 `assigns` 方法, 该方法的作用是从controller创造的实例对象里拿到值用于测试, 比如 assigns(:user), 此时如果controller有定义 `@user`的话, 就能拿到.

之后对应写完E2E测试就OK了.

remember me功能总结

1. rails可以通过内置的 `cookies` 方法来对访问的客户端进行cookies信息的设置, cookies信息的获取则通过 `params`方法获取
2. 持久化登录功能不需要记录用户的密码, 只需要记录一个用户勾选登录后随机生成的字符串并保存到数据库和cookies里, 下次打开页面时进行匹配就行.
3. 持久化登出功能不仅需要删除session里的用户id, 同时也要记得通过`cookies`方法移除保存在用户浏览器里的`cookies`
4. ruby也有三元表达式, 能精简代码, 此外`&.`(等价于a && a.xxx), `class << self`(即类中self.xxx方法的统一管理写法, 写在这个class里的方法都是实例方法) 这些rails给出的独有写法要记清.

### 登录用户删改查功能

#### edit 

先到controller里增加对应的响应方法

```ruby
  # GET /guests/1/edit
  def edit
    @guest = Guest.find(params[:id])
  end
```

增加view对应的模版

```ruby
<% provide(:title, "Edit user") %> 
  <h1>Update your profile</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(model: @user, local: true) do |f| %> 
  <%= render 'shared/error_messages' %>
  <%= f.label :name %>
  <%= f.text_field :name, class: 'form-control' %>
  <%= f.label :email %>
  <%= f.email_field :email, class: 'form-control' %>
  <%= f.label :password %>
  <%= f.password_field :password, class: 'form-control' %>
  <%= f.label :password_confirmation, "Confirmation" %>
  <%= f.password_field :password_confirmation, class: 'form-control' %>
  <%= f.submit "Save changes", class: "btn btn-primary" %> 
<% end %>
  <div class="gravatar_edit">
  <%= gravatar_for @user %>
  <a href="https://gravatar.com/emails" target="_blank">change</a>
  </div> 
</div>
</div>
```

增加路由

```ruby
<li><%= link_to "Settings", edit_guest_path(current_guest) %></li>
```

#### auth授权

auth授权对于登录系统来说是必不可少的部分, 在rails当中可以直接在controller里完成类似于java的过滤器一类的功能, 比如 [before_action] 这个钩子方法. 见如下代码

```ruby
class GuestsController < ApplicationController
  # before_action 是一个钩子, 等价于java过滤器里的beforexxx
  # 参数1为需要执行的方法名称, 参数2为哪些请求url对应的操作需要执行方法
  before_action :logged_in_user, only: %i[edit update destroy]
  # 如果用户未登录,则提供后重定向到登录页
  def logged_in_user
    unless logged_in?
      flash[:danger] = 'Please log in.'
      redirect_to login_url
    end
  end
end
```

注意到上面的逻辑中我们只对登录的用户做了校验, 而并没有对身份进行校验, 此时可以修改为如下判断逻辑, 如下则会在查找对应的用户再做重定向

```ruby
class GuestsController < ApplicationController
  # before_action 是一个钩子, 等价于java过滤器里的beforexxx
  # 参数1为需要执行的方法名称, 参数2为哪些请求url对应的操作需要执行方法
  before_action :correct_user, only: %i[edit update destroy]
  # 如果用户未登录,则提供后重定向到登录页
  def logged_in_user
    unless logged_in?
      flash[:danger] = 'Please log in.'
      redirect_to login_url
    end
  end

  def correct_guest
    @guest = Guest.find(params[:id])
    redirect_to(root_url) unless @guest == current_guest
  end
end
```

为了优化上面correct_guest的主逻辑, 往helper里加一个函数

```ruby
# sessionHelper
  def current_guest?(guest)
    guest&.== current_guest
  end

# 之后 correct_guest方法可以优化为
  def correct_guest
    @guest = Guest.find(params[:id])
    redirect_to(root_url) unless current_guest?(@guest)
  end
```

#### 展示所有用户

为了实现展示用户功能, 需要明白前提是需要进行登录操作, 因此先在controller处增加判断的代码

```ruby
  before_action :logged_in_user, only: %i[index edit update]

  # 当用户登录后, 才允许执行all查询动作
  def index
    @guests = Guest.all
  end
```

当用户全部查询出来后, `Guest.all` 会以数组的形式返回给guests的变量, 此时即可以考虑增加view页面的内容

```ruby
<% provide(:title, 'All users') %> 
<h1>All users</h1>
<ul class="users">
# 遍历输出所有guest, 拿到头像和一个a标签
<% @guests.each do |guest| %>
  <li>
  <%= gravatar_for guest, size: 50 %>
  <%= link_to guest.name, guest %>
  </li> 
<% end %>
</ul>
```

为了完成查看全部的功能, 需要增加一些伪数据来实现, rails 里有 `faker` 这个gem可以用来做数据的增加工作. 

可以先往gemfile里增加 `gem 'faker'`这个gem, 然后执行 `bundle install` 完成安装.之后便可以在db/seeds.rb里进行假数据插入的逻辑

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar')

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                password_confirmation: password)
end
```

上述逻辑就是创建一个guest的model对象, 然后再往数据库里插入99次. 当中的[create!]方法和[create]方法效果一样, 都是插入数据库的操作, 区别只在于带!号的方法会在用户无效时抛出一个异常, 而不是单纯的返回false.因此在调试上会方便不少

之后便可以执行 `rails db:migrate:reset`先重置数据库(会先删除原来的数据库,然后再按照migration文件依次重新创建), 然后再执行`rails db:seed`来插入数据了

> 分页功能

rails的erb模版里有现成的gem支持bootstrap库的分页功能, 分别是 `will_paginate`, `bootstrap-will_paginate`, 可以在gemfile里添加后执行 `bundle install` 安装

之后可以修改需要分页的页面, 

```ruby
<% provide(:title, 'All guests') %> 
<h1>All guests</h1>

# 使用该方法进行分页操作,  在新增了will_paginate这个gem后, 
# Model会自动挂载一个paginate的方法, 传递page: x 的参数进去即可进行分页(默认30)
# 而这里的will_paginate的使用,会自动给所有的model展示的数据加上可以进入详细页的跳转标签, 同时会自动添加上一个bootstrap的分页器(通过bootstrap-will_paginate实现)
<% provide(:title, 'All guests') %> 
<h1>All guests</h1>

<%= will_paginate  %>

<ul class="users">
<% @guests.each do |guest| %>
  <li>
  <%= gravatar_for guest %>
  <%= link_to guest.name, guest %>
  </li> 
<% end %>
</ul>

<%= will_paginate  %>

# 如上代码是常规逻辑的写法, 在rails中, 模版里的遍历动作无需显示的写出来也能完成遍历操作, 优化后如下
<% provide(:title, 'All guests') %> 
<h1>All guests</h1>

<%= will_paginate  %>

<ul class="users">
# render @guests会去拿到目标controller提供的数据集合, 然后通过render函数, 自动找到_guest组件,并进行渲染
  <%= render @guests %>
</ul>

<%= will_paginate  %>

# --- _guest.html.erb
  <li>
  <%= gravatar_for guest %>
  <%= link_to guest.name, guest %>
  </li> 
```

添加后可以在console控制台执行 `Guest.paginate(page: 1)`, 可以测试默认会返回30条guests表的数据, 一切ok, 则可以把这个方法写到路由对应的方法上, 完成分页返回工作

```ruby
# 修改rails里guests的controller
# 这样前端请求过来, rails能自动进行分页返回数据的动作
def index
  @guests = Guest.paginate(page: params[:page])
end
```

逻辑做完后记得测试, 由于涉及页面交互, 使用e2e测试来完成(记得在fixtures文件夹里对应的yaml里增加测试数据)

```ruby
require "test_helper"

class GuestsIndexTest < ActionDispatch::IntegrationTest
  def setup
    # 会在执行测试时,拿到fixtures文件夹下的guests.yml里的object
    @guest = guests(:michael)
  end

  test 'index including pagination' do
    # 测试用户先登录
    log_in_as(@guest)
    # 登录后获取index路径
    get guests_path
    # 声明渲染的模版是index
    assert_template 'guests/index'
    # 声明能选到div下的pagination类
    assert_select 'div.pagination'
    Guest.paginate(page: 1).each do |guest|
      assert_select 'a[href=?]', guest_path(guest), text: guest.name
    end
  end
end
```

#### 删除用户

从权限管理的角度来说, 该功能必须要admin来执行, 可以在这一部分考虑权限管理的问题.

如何增加管理员权限? 最为简单的方式就是给用户表增加一个是否是管理员的字段来进行, 因此追细选哪个如下命令生成一个追加column的migration

`rails g migration add_admin_to_guests admin:boolean`

```ruby
class AddAdminToGuests < ActiveRecord::Migration[7.0]
  def change
    # 为 guests表增加admin字段, 类行为boolean
    # default设定是自己加的, 没有default值的话, 默认会是nil
    add_column :guests, :admin, :boolean, default: false
  end
end
```

这类字段为boolean的属性, ActiveRecord都会免费赠送一个?号方法用来判断是否存在, 比如

```ruby
g = Guest.first
g.admin? # false
# 同时还会免费送一个toggle!方法, 来修改boolean值
g.toggle!(:admin)
g.admin? # true
```

记得要配上测试

```ruby
  test 'should not allow to edit admin attr via web request' do
    log_in_as(@other_guest)
    assert_not @other_guest.admin?
    patch guest_path(@other_guest), params: {
      guest: {
        password: 'password',
        password_confirmation: 'password',
        admin: true
      }
    }
    assert_not @other_guest.admin?
  end
```

> 添加delete Action

开放给admin的删除功能, 只能显示在admin权限的用户下, 因此先来改view

```ruby
  <li>
  <%= gravatar_for guest %>
  <%= link_to guest.name, guest %>
  # 用if包裹请求方式, 只允许admin属性为true的用户看到
  <% if current_guest.admin? && !current_guest?(guest) %>
    # 指定请求方式为delete, 相当于delete /guest/guest.id
   | <%= link_to "delete", guest, method: :delete, data: { confirm: "You Sure?"} %>
  <% end %>
  </li> 
```

注意到上述的代码中, rails里的模版没有办法直接发送get/post之外的RESTFUL请求, 因此如果使用的是erb模版的话, 经常就会看到类似于上述的在`link_to`的位置用method来指定其他的请求方式.

这里其实是rails在渲染模版时用内置的js改写了请求方式, 因此如果用户禁用了js,那么就没法使用. 因此在不能用js的场合,可以考虑使用form表单的post请求实现delete功能

然后可以在controller里增加对应的destroy方法, 记得destroy方法执行前要做登录校验+管理员权限校验

```ruby
  before_action :logged_in_guest, only: %i[index edit update destroy]
  before_action :admin_guest, only: %i[destroy]

  # DELETE /guests/1 or /guests/1.json
  def destroy
    # 找到目标记录并删除
    Guest.find(params[:id]).destroy
    # 给模版提供提示信息
    flash[:success] = "Guest deleted"
    # 重定向到 get /guest 
    redirect_to guest_url
  end

  private
  def admin_guest
    redirect_to(root_url) unless current_guest.admin?
  end
```

最后记得别忘了新增test case来对应新增的功能

```ruby
# fixtures/guest.yml准备数据
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  admin: true

# e2e
require 'test_helper'

class GuestsIndexTest < ActionDispatch::IntegrationTest
  def setup
    # 会在执行测试时,拿到fixtures文件夹下的guests.yml里的object
    @admin = guests(:michael)
    @non_admin = guests(:archer)
  end

  test 'index as admin including pagination and delete links' do
    log_in_as(@admin)
    get guests_path
    assert_template 'guests/index'
    assert_select 'div.pagination'
    first_page_of_guests = Guest.paginate(page: 1)
    first_page_of_guests.each do |guest|
      assert_select 'a[href=?]', guest_path(guest), text: guest.name
      assert_select 'a[href=?]', guest_path(guest), text: 'delete' unless guest == @admin
    end
    assert_difference 'Guest.count', -1 do
      delete guest_path(@non_admin)
    end
  end

  test 'index as non_admin' do
    log_in_as(@non_admin)
    get guests_path
    assert_select 'a', text: 'delete', count: 0
  end

  # test 'index including pagination' do
  #   # 测试用户先登录
  #   log_in_as(@guest)
  #   # 登录后获取index路径
  #   get guests_path
  #   # 声明渲染的模版是index
  #   assert_template 'guests/index'
  #   # 声明能选到div下的pagination类
  #   assert_select 'div.pagination'
  #   Guest.paginate(page: 1).each do |guest|
  #     assert_select 'a[href=?]', guest_path(guest), text: guest.name
  #   end
  # end
end
```

#### 登录部分总结

1. RESTFUL中通过Patch来完成update操作
2. 任何在rails项目中的写操作都必须要求使用`strong parameters`
3. 牢记controller里有before过滤器的存在, 善于使用这些过滤器实现Rest的前置校验等动作
4. 用户登录成功后记得配合重定向以提升用户体验
5. [will_paginate] 这个gem 能快速给model对象添加分页方法paginate, 提升开发速度
6. rails使用 `db/seeds.rb'文件来创造fake数据以用于本地测试, 可以配合`faker` 这个gem来创造一些伪内容, 并配合model插入数据库的方法来完成数据制造, 使用 `rails db:seed` 来造数据
7. model如果存在boolean属性, 则一定会附赠一个[属性?]的方法来快速实现判断, 比如 [:admin]字段, 就会附送一个 [admin?]方法.
8. 测试文件的所有数据均来自于测试文件夹下的fixtures, 所有test需要的数据都应该在这里被准备和编写