### 项目创建

创建新项目： rails new xxx, 会创建一个xxx项目， 然后执行bundle install 安装gems依赖。

启动rails项目： rails server。 服务器启动相关的配置能在config文件夹下的environments文件夹下找到。

> 细节

1. 版本上：`>= 2.15` 意思是需要安装至少>=2.15版本的gem， `~> 6.0.2.1` 意思是只接收小版本的修复，会安装 6.0.2~6.0.9版本， 但是不会安装6.1.0版本。
如果此时是 `~> 6.0` 那么就会安装 6.0~6.9的版本， 但是不会安装7.0以上的版本。

### MVC模型

- rails采用的是MVC模式开发web应用。
- 采用rails自带的脚手架生成器能非常快速的完成MVC的搭建。

命令1： rails g scaffold User(表名) name:string email:string

上述命令能够直接创建一个完整的MVC链路， 在创建完成后， 可以执行如下命令进行表的迁移（类似于django的migrate）

命令2： rails db:migrate

执行上述命令后，rails会直接在对应的数据库下创建一个叫做users的表（注意命名，创建时因为表示的是一条记录，所以是单数， 但是表保存了很多的记录，所以表名会自动变为复数）

MVC交互流程：

- 首先用户访问rails服务器， 服务器会获取到用户访问的url， 然后转给rails router
- rails router在接收到后会通过保存的map找到对应的controller
- 此时controller会调用其所管理的方法与model进行交互，比如User.all去获取所有的User信息
- model层此时会与数据库进行交互（查询），然后返回结果给controller
- controller在接收到查询后的结果后， 会转给Views层用于模版渲染
- 模版渲染完毕后，返回html给浏览器使用。

使用scaffolding之后会自动生成的RESTFUL路由列表

| HTTP Request | URL           | Action  | Purpose           |
|--------------|---------------|---------|-------------------|
| GET          | /users        | index   | 展示User表所有数据       |
| GET          | /users/1      | show    | `展示User表里id为1的数据` |
 | GET          | /users/new    | new     | `前往创建用户页面`        |
 | POST         | /users        | create  | 创建一个新用户           |              
| GET          | /users/1/edit | edit    | `前往修改id为1的用户页面`   |
| PATCH        | /users/1      | update  | 更新一个id为1的用户的信息    |
| DELETE       | /users/1      | destroy | 删除id为1的用户         |

上述路由表基本对应了RESTFUL的CRUD4种需求, 除去上面的斜体标注的show, new, edit 3个用户页面展示之外， 剩下4个都对应了接口的功能。
并且能看到URL的路径都是一样的（严格对应RESTFUL风格对resource的定义）

> model 字段校验

1. validates字段校验

对于创建表单时的字段校验， rails提供了非常方便快速的校验能力，从下面的代码可以看到， 在model层， 只需要加上内置的
`validates` 方法， 并将需要做校验的字段和校验的内容放在后面就能快速的完成后端对表单提交的校验工作。（比起Java每一个都要加注解的方式来说快太多了）
`presence` 关键字表示该字段不能为空
```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  validates :name, length: {maximum: 10}
  validates :email, presence: true
end
```

2. has_many 表关系校验

除了对表的字段能快速进行校验工作外， 还有`has_many` 这种对表关系进行约束的方法能快速的实现表与表之间的绑定关系。 比如如下
下方的model代码， 可以看到， Guest表通过`has_many` 绑定了book表， book表通过`belongs_to`绑定了Guest表， 并且两者
之间是一对多，还是多对一的关系都能通过英文表达反馈出来。

至于外键字段绑定的问题， rails会自动在运行时做处理。无需用户关心。 注意命名方式的讲究。 这里绑定时是单数， 代表的是记录

```ruby
class Guest < ApplicationRecord
 # constraint guest name to be at most 10 characters
 validates :name, length: {maximum: 10}

 has_many :book
end

class Book < ApplicationRecord
 belongs_to :guest
end

```

我们可以快速的通过 rails 的 console来对表进行操作， 比如

```ruby
#! /usr/local/bin/sh

rails console

first_guest = Guest.first # 通过model名.first快速拿到该表第一条记录, 返回类型是Guest

first_guest_book = first_guest.books; 
```

3. 创建静态页面

使用命令： rails g controller StaticPages home help

执行上述命令后， 会生成名为`static_pages_controller`的rb文件， 该文件即单controller文件。 相比较于 g scaffolding 这个命令，
g controller不会管到Model层， 只会生成Controller和View， 方便用于没有状态的静态页面的生成.(注意命令的命名方式一定要是大驼峰)

执行后，会生成如下文件

- controllers
  - static_pages_controller.rb
- views
  - static_pages
    - help.html.erb
    - home.html.erb

注意： 

- 可以执行 `rails destroy [controller/model] StaticPages[大驼峰对应内容] home help`的形式undo通过CLI创建的文件。

- 可以执行 `rails db:rollback` 来undo一次migration操作

- 可以执行 `rails db:migrate VERSION=0` 来undo所有的migration操作

ruby当中的html模版为`x.html.erb`文件, 其模版语法形式类似于ejs, jsp, 能直接在html模版里嵌套ruby语法. 当中只需要知道2个书写样式就行, 一个是`<% %>`, 表示执行ruby语句, 另一个是 `<%= %>`, 表示不仅执行还要把结果返回.  比如见如下例子

```ruby
# home.html.erb

<% provide(:title, "Home") %> # ruby函数 provide,直接提供一个哈希给到该模版使用
<title><%= yield(:title) %></title> # yield函数, 拿到provide的值, 并且返回渲染出来.
<h1>Sample App</h1> <p>
This is the home page for the
<a href="https://www.railstutorial.org/">Ruby on Rails Tutorial</a> sample application.
</p>
```

除了标准的erb模版之外, rails还支持其他的模版语法, 比如haml, 其模版样式如下

```ruby
%section.container
  %h1= post.title
  %h2= post.subtitle
  .content
    = post.content
```

从上能看到, haml的语法基本就是markdown语法, 不过现在可选项多, 了解一下即可.

对于全局性的模版, 在laytous文件夹下有application.html.erb文件, 用于提供全局重复的渲染模版, 见如下代码

```ruby
 <!DOCTYPE html>
<html> <head>
<title><%= yield(:title) %> | Ruby on Rails Tutorial Sample App</title>
<meta charset="utf-8"> 
# 下方tag都是standard pipeline, 必须要启用, 能帮助做很多事情.
<%= csrf_meta_tags %>  # cross-site request forgery, 用于规避csrf跨站请求攻击.
<%= csp_meta_tag %> # Content Security Policy, 用于规避XSS攻击
<%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %> # 加载CSS文件
<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %> </head> # 加载JS文件
<body>
<%= yield %>
</body> </html>
```

路由改变.

当页面不断增多时, 可以看到路由如下

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  get 'static_pages/help'
  get 'static_pages/about'
  get 'static_pages/contact'
  resources :guests
  resources :entries
end
```

上面的路由表里, root与get指定的路由方式不一样, 当为root时, 使用的#, 但是get时则是/.

自动化测试:

可以使用`guard` 这个gem进行rails项目的自动化测试, 该gem需要额外安装, 并需要在项目根目录提供Guardfile, 内容如下.

```ruby
require 'active_support/core_ext/string'
# Defines the matching rules for Guard.
guard :minitest, spring: 'bin/rails test', all_on_start: false do
  watch(%r{^test/(.*)/?(.*)_test\.rb$})
  watch('test/test_helper.rb') { 'test' }
  watch('config/routes.rb') { interface_tests }
  watch(%r{app/views/layouts/*}) { interface_tests }
  watch(%r{^app/models/(.*?)\.rb$}) do |matches|
    ["test/models/#{matches[1]}_test.rb",
     'test/integration/microposts_interface_test.rb']
  end
  watch(%r{^test/fixtures/(.*?)\.yml$}) do |matches|
    "test/models/#{matches[1].singularize}_test.rb"
  end
  watch(%r{^app/mailers/(.*?)\.rb$}) do |matches|
    "test/mailers/#{matches[1]}_test.rb"
  end
  watch(%r{^app/views/(.*)_mailer/.*$}) do |matches|
    "test/mailers/#{matches[1]}_mailer_test.rb"
  end
  watch(%r{^app/controllers/(.*?)_controller\.rb$}) do |matches|
    resource_tests(matches[1])
  end
  watch(%r{^app/views/([^/]*?)/.*\.html\.erb$}) do |matches|
    ["test/controllers/#{matches[1]}_controller_test.rb"] +
      integration_tests(matches[1])
  end
  watch(%r{^app/helpers/(.*?)_helper\.rb$}) do |matches|
    integration_tests(matches[1])
  end
  watch('app/views/layouts/application.html.erb') do
    'test/integration/site_layout_test.rb'
  end
  watch('app/helpers/sessions_helper.rb') do
    integration_tests << 'test/helpers/sessions_helper_test.rb'
  end
  watch('app/controllers/sessions_controller.rb') do
    ['test/controllers/sessions_controller_test.rb',
     'test/integration/users_login_test.rb']
  end
  watch('app/controllers/account_activations_controller.rb') do
    'test/integration/users_signup_test.rb'
  end
  watch(%r{app/views/users/*}) do
    resource_tests('users') +
      ['test/integration/microposts_interface_test.rb']
  end
end

# Returns the integration tests corresponding to the given resource.
def integration_tests(resource = :all)
  if resource == :all
    Dir['test/integration/*']
  else
    Dir["test/integration/#{resource}_*.rb"]
  end
end

# Returns all tests that hit the interface.
def interface_tests
  integration_tests << 'test/controllers'
end

# Returns the controller tests corresponding to the given resource.
def controller_test(resource)
  "test/controllers/#{resource}_controller_test.rb"
end

# Returns all tests for the given resource.
def resource_tests(resource)
  integration_tests(resource) << controller_test(resource)
end
```

当配置之后, 即可以在控制台执行 `bundle exec guard` 命令执行, 之后每当controller进行改变之后, 就会重新跑一次整合测试, 保证程序没有问题.

guard的文档: `https://github.com/guard/guard/wiki`

如果碰到报错, 可以尝试执行 `bin/spring stop` 进行停止(spring是rails里用于测试的包, 它会预先加载测试的消息以加速测试的进程). 之后再执行 `bundle exec guard`

#### 模版自定义helpers

上述的内容看到了一些能够直接在模版文件里使用的helper函数, 比如`stylesheet_link_tag` 用来帮助处理在模版渲染中的一些问题, 那如果要自己创建一个能用在模版里的函数应该如何做呢?

在rails里可以在app/helpers文件夹下进行函数的增加, 比如

```ruby
module ApplicationHelper
  # Return the full title
  def full_title(page_title = '')
    base_title = "Yahaha, Helper"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end
```

上面的代码在ApplicaitonHelper里增加了, 那么所有的模版文件都能用到. 如下

```ruby
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    # 这里用到自定义helper函数
    <title><%= full_title(yield(:title)) %></title>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

rails模式的函数书写方式

```ruby
def string_message(str = '')
  return "empty string!" if str.empty?
  return "nonempty"
end

# 相比较于if else, 一眼就能看出优劣
def string_message(str = '')
  if str.empty?
    'empty string!'
  else
    'nonempty'
  end
end

# 对于?号的书写方式, 还有带!的方法, 这类带!(叫bang)号的方法, 会mutate原来的数组,
# 而不是返回一个新的数组

# 还有个代码块传入的速写方式经常看见, 如下
%w[A B C].map(&:downcase)  # 叫做 symbol-to-proc, 是rails独有的,不是ruby的特性,(2.7版本才加入ruby core)

# 等价于
%[A B C].map {|c| c.downcase} # 上述带&:的方式省略了取值的重复代码

# 哈希数据结构里的 => (叫做hashrocket)
user = {'first_name' => 'aaa', 'last_name' => 'bbb'}

# symbol -> 唯一,不带任何方法的string对象. 用得极多, 基本参数都用, 哈希的key也基本都用symbol
:name
user = {:first_name => 'aaa', :last_name => 'bbb'}
# 取值: 
user[:first_name]
# 普通的json格式也是可以用的, 效果一样.(ruby1.9以后) 
# 其本质还是转为了symbol就是了, rails里还是推荐写成symbol的形式, 因为取值还是要写symbol
user = {first_name: 'aaa', last_name: 'bbb'}

# 此外有一个hash结构常用的方法merge需要注意一下
{ :a => 100, :b => 200 }.merge({ :b => 300  })
# {:a=>100, :b=>300} 
# 该方法和JS的Object.assign类似, 会合并传入到merge里的对象的内容, 而其他没有写的内容则不变, 该方法在表单处十分有用.

{ :a => 100, :b => 200 }.merge({ :b => 300, :c => 400  })
# {:a=>100, :b=>300, :c=>400} 
```

重新检查 `stylesheet_link_tag` 方法有什么用.

```ruby
 <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %>

 # 拆开后实际为, 神奇的地方在于rails里有大量这样的代码, 没有括号,只有方法名和参数
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 实际上, 括号在ruby里是可以被省略的, 上面的代码等价于
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')

# 并且上述的代码可以看到 media: 那个位置的数据结构明显是hash, 那哈希结构的{}去哪了?
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }

# 实际上, 在ruby里, 如果hash数据结构是方法的最后一个参数的话, 则哈希的{}括号可以被省略. 因此最终就看到了大量的方法写成了这个样子.
stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload'

# 并且ruby解释器在这样的写法上不会去区分换行符和空格啥的, 因此就能看到某些方法写成下面这样也是合法的
fork_method :aaa, :bbb, :ccc, :ddd
            :eee, :fff, :ggg, :ttt

# 实际stylesheet_link_tag 这个方法会在html里转换为如下内容
# 其传入的参数的意义是, 让所有的css文件在任何屏幕适配下, 如果重新部署修改了css文件, 则重新加载新的css文件(reload, rails4.0加入的功能), 
<link rel="stylesheet" media="all" href="/assets/application.self- f0d704deea029cf000697e2c0181ec173a1b474645466ed843eb5ee7bb215794.css?body=1" data-turbolinks-track="reload" />
```

解释一下类

```ruby
class User
  attr_accessor :name, :email
  def initialize(attributes = {}) 
    @name = attributes[:name] 
    @email = attributes[:email]
  end
  def formatted_email 
    "#{@name} <#{@email}>"
  end
end
# attr_accessor : attribute accessors 即getter + setter
# initialize : 即类的构造方法
# @name, @email 即this.name, this.email
```

解释一下html模版创建

```ruby
<%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %> </div>
# link_to方法接收3个参数, 1,显示的内容, 2,跳转的位置, 3,class名字
# 会生成一个 <a></a>标签

<%= link_to image_tag("456.jpeg", alt: "Rails logo", width: "200"), "https://rubyonrails.org/" %>
# image_tag方法会生成一个<image />标签, 
# 接收3个参数, 1,image所在的位置(默认定位在app/assets/images下), 2,无法展示时显示的文字, 3,style属性
```

rails的静态资源pipeline天生支持scss编译, 无需其他的gem,如果想找使用bootsrap, 可以添加如下gem

`gem 'bootstrap-sass', '3.4.1'`

app/assets目录下的所有文件, 都会在rails服务器进行编译时自动输出, 包括下面的stylesheets文件夹, 都会自动被server引用, 因此不需要显示的在html模版里调. 所以类似于custom.scss之类的全局都要的文件, 直接丢到stylesheets文件夹里就得了,会自动生效. 比如

```scss
@import "bootstrap-sprockets";
@import "bootstrap";

body {
  padding-top: 60px;
  }
  section { overflow: auto;
  }
  textarea {
  resize: vertical;
  }
  .center {
  text-align: center;
  }
  .center h1 { margin-bottom: 10px;
  }
```

**asset pipeline** 是rails的一大特色, 这些放在assets文件夹下的images和stylesheets, 在前后端分离的场景下也能和Webpack一起使用, 当然, webpack默认是被rails支持的, 前端包管理工具则是yarn.

在rails的项目里, assets文件夹有3个, 在server进行静态资源打包时都会默认被用到, 分别如下

- app/assets: 当前app的静态资源
- lib/assets: 自己开发的依赖的静态资源
- vendor/assets: 第三方依赖的静态资源,默认不会被展示

详解一下app/assets文件夹(asset pipeline会使用到下面三个文件夹里的内容)

- config : 下面有manifest.js, 可以在其中手动指定rails服务器还需要去哪里加载css文件和js文件(或者文件夹)(通过使用Sprockets gem来完成), 不能指定图片
- images : 项目全局图片
- stylesheets : 项目全局css文件加载

需要注意的是 asset pipeline 会自动完成发布到生产时的CSS资源处理工作, 会组合所有的CSS文件为一个CSS文件(application.css),并最小化处理. 而scss文件则也会自动编译然后组合


关于短链接:

在渲染<a>标签时, 会有route相关的内容需要指定, rails提供了快速匹配route的别名形式, 只要在每个route对应的小写字母后加上_path, 就能调用到对应的url.

比如 /about , 那么在模版里渲染路由的时候, 在link_to方法里, 使用about_path作为参数就能匹配到 /about 路由. 具体是什么参考rails routes下controller对应给出的Prefix, 即 prefix + "_path" 就ok. 此外还有一个 + "_url" 的写法, 差别如下

root_path -> '/'
root_url  -> 'http://www.example.com/'

root_url 只会在重定向到站外资源时用到, 因为带全url地址.

基于上述的认知, 路由可以优化为如下样式

```ruby
Rails.application.routes.draw do
  # get 'static_pages/home'
  root 'static_pages#home'
  # get 'static_pages/help'
  # get 'static_pages/about'
  # get 'static_pages/contact'
  # 参数1: url查找显示用的url, 参数2: to: 具体查找的controller下的方法, 参数3: as: 起别名, 在模版里引入时要改成helf_path, 而不是help_path(看着没啥用)
  get '/help', to: 'static_pages#help', as: 'helf'
  get '/about', to: 'static_pages#about'
  get '/contact', to: 'static_pages#contact'
  resources :guests
  resources :entries
end
```

记得生成整合测试: `rails generate integration_test site_layout`, 试试routes的修改是否正确, `rails test:integration` 执行E2E测试

```ruby
require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest
  test 'layout links' do
    get root_path
    # assert_template 会渲染整个html模版出来
    assert_template 'static_pages/home'
    # assert_select 是dom选择器, 会通过querySelector查找, 每执行一次,就往下诺
    assert_select 'a[href=?]', root_path, count: 2
    assert_select 'a[href=?]', help_path
    assert_select 'a[href=?]', about_path
    assert_select 'a[href=?]', contact_path
  end
end
```

#### Model层

使用命令: `rails g model Guest name:string email:string` 创建一个model层. 当然也能手动创建,还记得创建一个controller层怎么打吗? `rails g controller Guests new`

命名规则: Model层创建使用单数, 而controller层使用复数. 因为Model表示的是一条记录(但是数据库里的表会自动变成复数)

rails提供的migration功能减少了用户需要去学复杂sql的成本, 并且migration每次都是基于创建的时间戳进行的递增操作, 时间戳记录(UTC标准)的设定规避了多个开发者进行migration操作会重复的可能,便于多人协作. 来看下migrate的代码

```ruby
class CreateGuests < ActiveRecord::Migration[7.0]
  def change
    # create_table方法接收参数为表名, 然后接收一个code block做具体字段的设定
    create_table :guests do |t|
      t.string :name
      t.string :email
      # timestamps方法会创建created_at, updated_at两个字段.
      t.timestamps
    end
  end
end
```

上述代码为执行migration后自动生成的, 其中实现了change方法, chang方法决定了migration时如何对数据库进行操作. 当创建后, 执行 `rails db:migrate` 即可进行migration操作.

在db目录下, 除了migrate文件夹外, 还有schema.rb文件, 该文件作用如下

1. rails会使用该文件追踪整个db的结构, 其代码内容为每次执行`create model`后就会往里面添加.

2. 由于该文件的存在,因此大多数的migration操作都是可逆的, 通过`rails db:rollback`实现. 其原理是通过migration当中的change方法实现的, 而如果需要进行不可逆的操作, 则可以实现up, down方法来替换change方法, 以分别对应migrate(up)时的操作与rollback(down)时的操作.

对于在控制台进行rails操作, 可以执行 `rails console --sandbox`来进入沙盒环境, 这样的话,所有的操作都会在退出控制台时回滚, 而不必担心对数据造成影响.

控制台操作时, Guest.new + Guest.save  == Guest.create. 要求传入一个哈希, 因此可以把{}拆掉,直接写成

```ruby
foo = Guest.create(name: "Foo", email: "foo@bar.com")
```

就能在控制台完成表操作. 其他简单的操作如下(这些操作虽然是在控制台完成的, 实际代码中也能通过这些代码与数据库完成CRUD操作)

- 如果需要删除, 则执行`Guest.destroy`, 
- 如果需要具体查某一个id的记录 `Guest.find(id)`
- 如果需要拿第一条记录 `Guest.first`
- 如果需要拿第二条记录 `Guest.second`
- 如果需要拿最后一条记录 `Guest.last`
- 如果需要拿全部的记录 `Guest.all` : 返回内容是假数组, 实际为Guest::ActiveRecord_Relation
- 具体通过某个字段查 `Guest.find_by_<字段名>` , 比如 Guest.find_by_name
- 通过手写自定义SQL查 `Guest.find_by_sql(<传sql字符串>)`
- 如果需要修改记录, 则通过修改model对象实例的属性后, 再实例.save进行保存. 比如: `qq.name = 'bad' ; qq.save`
- 或者嫌麻烦, 则可以通过实例.update方法进行修改, 比如 `qq.update(name: "wao")` , 会自动去修改传入部分的字段属性, 不会全部修改. 返回值为true/false. 当然, 实际也是设定 + .save的组合
- update方法在修改时会进行字段全校验, 如果需要跳过校验只修改某些字段,可以使用`qq.update_attribute(:name, "asas")` 方法, (注意此时是2个参数, 分别对应key, value)


> 来看下字段校验相关的东西

小技巧: 在测试的时候, 通过`rails test:<test文件夹下目标文件夹名>`会自动跑目标文件夹下的所有test

- valid? : 该记录是否通过了所有的校验
- guest.errors.messages : 返回hash格式的所有校验错误信息
- guest.errors.full_messages : 返回数组格式的所有校验错误信息
- presence : 校验字段是否为空
- length : 校验字段长度
- format : 正则校验,有Rubular这个网站可以提供ruby的正则校验功能.
- uniqueness : 校验字段值是否在表里唯一
  - 对于唯一性校验而言,其做法是扫描全表, 因此会出现效率问题, 可以通过增加索引解决.
  - 增加索引可以通过`rails g migration add_index_to_guests_email` 来对表进行操作
  - 上面的命令能看到, add_字段/索引_to_表名_字段名 是脚手架的格式, 能立即创建migrate文件, 之后可以往migrate文件里加上新增index的语句,如下(注意,如果打开了rails的sandbox模式,migration会强制失败)


```ruby
class AddIndexToGuestsEmail < ActiveRecord::Migration[7.0]
  def change
    # 新增索引, 参数1: 表名, 参数2: 字段名, 参数3: 属性特征
    add_index :guests, :email, unique: true
  end
end
```

```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  # validates :name, length: {maximum: 10}
  # callback for model, mutate email attr with downcase method
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  # Constant with capital letter
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 200 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  has_many :book
end
```

> 来看下密码加密

除了校验之外, 一般保存到数据的密码都需要做加密操作, rails提供了has_secure_password方法,只需要在model层里添加该方法, 即会做以下几个动作

1. 会自动将密码哈希后保存到数据库, 表字段名为`password_digest`(该字段必须有以启用has_secure_password方法), 可执行脚本命令创建migration `rails g migration add_password_digest_to_guests password_di
gest:string`, 执行后会生成如下migration
```ruby
class AddPasswordDigestToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :password_digest, :string
  end
end
```
2. 会自动增加2个虚拟属性 `password` `password_confirmation`, 两个虚拟属性自带非空与匹配判断. 虚拟的意思是在rails里有,但是在数据库里不存在
3. 会自动增加一个`authenticate`方法, 如果密码正确, 该方法将返回目标Model实例, 否则返回false

如上在增加了`password_digest`之后, 只要`db:migrate`了, 会立刻要求增加`bcrypt`这个gem包,该包提供了哈希算法, 就算被黑掉被搞走整个数据库, 也难以破解密码.

**简单来说, 就是数据库保存的字段是password_digest, 但是实际上是通过了bcrypt这个gem, 在对应的Model下新增了password, password_confirmation 两个字段进行前端的填充, 当哈希算法匹配password与数据库的password_digest一致时, 则放行通过. 这样就做到了数据库保存的密码其实都是哈希之后的密码, 具体怎么哈希的没人知道,rails只需要做参数收集和算法匹配的动作**

此时Guest Model变成如下

```ruby
class Guest < ApplicationRecord
  # constraint guest name to be at most 10 characters
  # validates :name, length: {maximum: 10}
  # callback for model, mutate email attr with downcase method
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  # Constant with capital letter
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 200 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }

  # only offer the presence validation, only work with empty.
  has_secure_password
  # therefore, we need another validates to validate password field
  validates :password, presence: true, length: { minimum: 6 }
  has_many :book
end
```

实际数据库保存的记录如下

```ruby
 id: 1,                                                      
 name: "zhangsan",                                           
 email: "abc@gmail.com",                                     
 created_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00, 
 updated_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00, 
 password_digest: "[FILTERED]"> 

 Guest.first[:password_digest]
 "$2a$12$0EJjT1MT8FX.E/5mM27SUea0oQn/nLIRkeS7GWmS/KpZZKqSOtITK" 
```

增加到了model层的has_secure_password方法, 自动增加了`authenticate`方法给到了目标的Model的对象上, 此时如果输错密码和输成功密码如下显示.

```ruby
3.0.0 :014 > abc = Guest.first
  Guest Load (0.8ms)  SELECT `guests`.* FROM `guests` ORDER BY `guests`.`id` ASC LIMIT 1
 =>                                                                
#<Guest:0x00007ff6b23c3c68                                         
...                                                                
3.0.0 :015 > abc.authenticate("yoho")
 => false # 登录输错返回false
3.0.0 :016 > abc.authenticate("yohooo")
 => false 
3.0.0 :017 > abc.authenticate("aaaaaa")
 => # 登录正确返回用户表记录信息
    # 如果只需要返回true, 那就 !!abc.authenticate("aaaaaa") 就好了, 方便快速.
#<Guest:0x00007ff6b23c3c68                                         
 id: 1,                                                            
 name: "zhangsan",                                                 
 email: "abc@gmail.com",                                           
 created_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00,       
 updated_at: Sun, 11 Sep 2022 06:35:35.932065000 UTC +00:00,
 password_digest: "[FILTERED]">   
```

#### Rails环境问题

rails 项目默认自带三个环境, 分别是 test, development, production, 当中默认的环境是development, 可以通过 Rails.env 来获取当前环境信息, 并可以通过 Rails.env.development? 来判断是否是目标环境.

在启动时可以指定环境来修改启动的目标环境, 如下

`rails server --environment production`

此时db的migration动作也应该修改为production, 默认不输入环境变量的话, 则都是development

`rails db:migrate RAILS_ENV=production`

某些云平台对ruby项目支持良好的, 会自动切换为production模式, 比如heroku.

获取参数打印

```ruby
  <%= debug(params) if Rails.env.development? %>

  # 同时model对象的属性可以.to_yaml输出
  puts abc.attributes.to_yaml
```

#### Route resources 资源

在前面已经提到过了这一特殊的route类型, 即resources,  当标记某一个model层时, 会自动往routes添加所有常用的RESTFUL路由以及其controller匹配. 当然, 并不是所有情况下都需要使用脚手架来生成代码, 如果我们手动添加routes相关的内容, 则可以手动自己配置controller的实现方法.

见一个例子

```ruby
# routes.rb
  resources :guests

# controller
  def show
    @guest = Guest.find(params[:id])
  end

# view
<%= @user.name %>, <%= @user.email %>
```

如果需要在代码里debugger, 可以在具体代码位置加上debugger,来进行debugger调试, 所有报错信息会在控制台打印出来, 包括具体哪一行错了(需要byebug gem的支持,如果加了没用的话,确认看看是否装了这个gem).

```ruby
  def show
    @guest = Guest.find(params[:id])
    debugger
  end
```

渲染erb模版时, 每个helper对应的都是模版里独自能调用的方法, 比如渲染avatar
这里的例子用了gravatar, 提供的图片保存功能, 会将邮箱和图片进行映射显示.

```ruby
module GuestsHelper
  def gravatar_for(guest)
    gravatar_id = Digest::MD5.hexdigest(guest.email.downcase)
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"
    image_tag(gravatar_url, alt: guest.name, class: 'gravatar', size: 50)
  end
end

# 在模版里的使用
<% provide(:title, @guest.name) %> 
<div class="row">
  <aside class="col-md-4"> 
    <section class="user_info">
      <h1>
      <%= gravatar_for @guest %> 
      <%= @guest.name %>
      </h1> 
  </section>
  </aside> 
</div>
```

ruby2.0版本之后, 对于函数的传参, 有以下优化

```ruby
# 1. 原模式
module UsersHelper
  # Returns the Gravatar for the given user.
def gravatar_for(user, options = { size: 80 })
  size = options[:size]
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}" image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end 
end

# 2. 优化模式
module UsersHelper
  # Returns the Gravatar for the given user.
def gravatar_for(user, size: 80)
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}" image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end 
end

# 能看到参数传递的位置确实有了变化, 不需要再取值和用hash明显传递参数即可拿到默认参数
```

erb模版提供了form_with的内置方法, 用于动态构建一个目标model层的表单内容

```ruby
<% provide(:title, 'Sign up') %> <h1>Sign up</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
# form_with内置函数, 参数1: 目标model, 参数2: local: true, 发送ajax请求
<%= form_with(model: @guest, local: true) do |f| %> 
  # f.label 会构建<label>标签, f.text_field, 会构建<input type='text' />标签.
  # 并且会自动与指定的model绑定
  <%= f.label :name %>
  <%= f.text_field :name %>
  <%= f.label :email %>
  <%= f.email_field :email %>
  <%= f.label :password %>
  <%= f.password_field :password %>
  <%= f.label :password_confirmation, "Confirmation" %> 
  <%= f.password_field :password_confirmation %>
  <%= f.submit "Create my account", class: "btn btn-primary" %>
<% end %>
</div> 
</div>

#除了上面的常规内容外, 还会构建一个隐藏的input框
<input type="hidden" name="authenticity_token" value="KxgJwmTX9IXB8BkMktfWq_9P_RvASMTS9Yy2-rqv6exL_fiBI4aGjtssoiD9fFfGw6kazZLcdtc-BcqnUFakVQ" autocomplete="off">

# 该input框会带授权的token, 专门用于避免csrf攻击提供. 开发者不需要关注, rails会全自动处理好这些
```

关于表单提交处理方法要详细解释一下

下方代码通过初始化**params**的形式是异常危险的, 初始化params会将用户输入的所有内容都提交给后台处理, 这也就意味着如果攻击者想要输入一些bug代码也是无法被阻止的, 因此也就无法防止XSS攻击.

在某些4.0版本之前的rails项目中, 还能在model层看到**attr_accessible**用来解决注入攻击问题, 但是在4.0版本后, 官方推荐全部在view层使用强类型参数来解决这个问题.

```ruby
 # POST /guests or /guests.json
  def create
    # 等价于 @user = User.new(name: "Foo Bar", email: "foo@invalid", password: "foo", password_confirmation: "bar")
    @guest = Guest.new(params[:guest]) # 这种写法是rails版本迭代的产物, 当然能用, 但是4.0版本后容易引起安全问题
    if @guest.save
      # rails内置的erb模版的方法, 就是一个会自动消失的提示
      flash[:success] = "Welcome to the Sample App"
      # 等价于 redirect_to guest_url(@guest), 会自动导到详情页
      redirect_to @guest
    else
      render 'new'
    end
  end
```

强类型参数的写法如下

```ruby
# 把guest对象丢进来, 但是permit,只允许指定这几个字段放行
params.require(:guest).permit(:name, :email, :password, :password_confirmation)

# 但这样直接写在controller里对应的方法内的话就太丑了, 这里可以将其抽离为一个private的方法
  # Only allow a list of trusted parameters through.
  def guest_params
    params.require(:guest).permit(:name, :email, :password_confirmation)
  end

# 然后实际使用时, 
def create
  @guest = Guest.new(guest_params)
  if @user.save
    # Handle a successful save.
  else
    render 'new' 
  end
end
```

注册提交时一般都会有报错的处理, 此时可以在views文件夹里新增shared文件夹来保存共用的内容, 比如

```ruby
# _error.html.erb
<% if @guest.errors.any? %> <div id="error_explanation">
<div class="alert alert-danger">
The form contains <%= pluralize(@guest.errors.count, "error") %>.
</div>
<ul>
<% @guest.errors.full_messages.each do |msg| %>
<li><%= msg %></li> <% end %>
</ul>
</div> <% end %>

# pluralize 是一个很有用的函数, 属于ralis内置的helper类, 能直接调用. 
# >> helper.pluralize(3, "erratum") => "3 errata" 会自动将单词进行复数化.
```

除了提交之外, 一般还会有提示, 此时可以用内置的flash方法, 模版如下

```ruby
# 加到application.html.erb里
  <% flash.each do |message_type, message| %>
    <%= content_tag(:div, message, class: "alert alert-#{message_type}") %>
  <% end %>
```

此时controller如下

```ruby
  def create
    # 等价于 @user = User.new(name: "Foo Bar", email: "foo@invalid", password: "foo", password_confirmation: "bar")
    @guest = Guest.new(guest_params) # 这种写法是rails版本迭代的产物, 当然能用, 但是4.0版本后容易引起安全问题
    if @guest.save
      flash[:success] = "welcome to Sample App #{@guest[:name]}"
      redirect_to @guest
    else
      render 'new'
    end
  end
```

#### 生产环境的一些问题

1. 如果需要设定rails开启ssl,可以在项目的production.rb里,修改如下内容

```ruby
config.force_ssl = true
```

2. 生产环境Puma服务器比WEBrick服务器好, 5版本后默认是Puma, 老版本如果要更改, 先增加puma依赖,然后在config文件夹下使用如下puma.rb配置

```ruby
# Puma configuration file.
max_threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 } 
min_threads_count = ENV.fetch("RAILS_MIN_THREADS") { max_threads_count } 
threads min_threads_count, max_threads_count
port ENV.fetch("PORT") { 3000 }
environment ENV.fetch("RAILS_ENV") { ENV['RACK_ENV'] || "development" } 
pidfile ENV.fetch("PIDFILE") { "tmp/pids/server.pid" }
workers ENV.fetch("WEB_CONCURRENCY") { 2 }
preload_app!
plugin :tmp_restart
```

3. Procfile是rails项目里的标配, 用于告诉生产的机器如何运行Puma服务器启动项目, 它应该在项目根目录下

```ruby
# Procfile
web: bundle exec puma -C config/puma.rb
```

4. 生产数据库的配置, 需要在config/database.yml下修改, 比如如下
   
```yaml
default: &default
  adapter: mysql2
  encoding: utf8mb4
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  username: root
  password: yangyang123
  host: localhost
  port: 3306

development:
  <<: *default
  database: mydiary_development

test:
  <<: *default
  database: mydiary_test

production:
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  database: sample_app_production
  username: sample_app
  password: <%= ENV['SAMPLE_APP_DATABASE_PASSWORD'] %>
```

### 登录功能

路由准备: `rails g controller Sessions new`

登录功能只需考虑登录确认, 注册, 和登出功能, 因此可以做如下3个路由(注: RESTFUL)

```ruby
  get '/login', to: 'sessions#new'
  post '/login', to: 'sessions#create'
  delete '/logout', to: 'sessions#destroy'
```

这里只考虑传统的session登录形式, 来准备一下登录页面

```ruby
<% provide(:title, "Log in") %> 
<h1>Log in</h1>
<div class="row">
  <div class="col-md-6 col-md-offset-3">
  # 注意这里的scope参数, form_with已经内置提供了session登录
  <%= form_with(url: login_path, scope: :session, local: true) do |f| %>
    <%= f.label :email %>
    <%= f.email_field :email, class: 'form-control' %>
    <%= f.label :password %>
    <%= f.password_field :password, class: 'form-control' %>
    <%= f.submit "Log in", class: "btn btn-primary" %> 
  <% end %>
  <p>New user? <%= link_to "Sign up now!", signup_path %></p> 
  </div>
</div>
```

上述代码中以form_with方法渲染出来表单, 传到controller时会以`params`被controller方法接收使用. 比如`params[:session]`

当进行登录操作时, 服务器会得到下面的内容

```ruby
Started POST "/login" for ::1 at 2022-09-13 22:43:27 +0800
Processing by SessionsController#create as HTML
  Parameters: {"authenticity_token"=>"[FILTERED]", "session"=>{"email"=>"stan@gmail.com", "password"=>"[FILTERED]"}, "commit"=>"Log in"}
```

从Parameters能看到, controller使用的Params本质其实就是哈希, 用户提交的敏感信息会自动过滤,并在session当中保存提交. 等价于 params[:session], 因此用户登录即可以如下实现

```ruby
  def new; end

  def create
    guest = Guest.find_by(email: params[:session][:email].downcase
    # 如果用户存在且后续方法执行成功,则做啥
    # recap: authenticate是bcrypt提供的
    if guest&.(guest.authenticate(params[:session][:email]))
    else
      # flash.now不同于flash, 只会在当前页面出现一次,不会保留
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end

  def destroy; end
end

```

登录涉及重要逻辑,记得写E2E测试 `rails g integration_test guests_login`

```ruby
require 'test_helper'

class GuestsLoginTest < ActionDispatch::IntegrationTest
  test 'login with invalid information' do
    get login_path
    assert_template 'sessions/new'
    post login_path, params: { session: { email: '', password: '' } }
    assert_template 'sessions/new'
    assert_not flash.empty?
    get root_path
    assert flash.empty?
  end
end
```
