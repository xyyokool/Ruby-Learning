### 动态代码执行

该特性类似于JS代码中的`eval`， 当然这里也叫做`eval`, 使用该方法时， 能将字符串转换成ruby代码进行执行。

```ruby
# 1.
puts eval('2+2')
# 输出4

# 2.
my_number = 15
my_code = %{#{my_number} * 2}
puts eval(my_code)
# 30
```

> binding ruby中的术语， 指当前变量所处的上下文环境和变量本身值是有关的。

具体看个binding的例子吧

```ruby
def binding_elsewhere
  x = 20
  # binding是一个方法
  return binding
end

remote_binding = binding_elsewhere

x = 10
eval("puts x") # 10
eval("puts x", remote_binding) # 20
```

上面的例子中可以看出， 使用`binding`的技巧， 能在eval中绑定一个指定的上下文环境， 并读取目标上下文环境里的内容。

除了正常的`eval`之外， ruby还提供`class_eval`, `module_eval`, `instance_eval` 等方法在目标上下文内执行字符串代码

分别看下这几个例子

第一个例子是`class_eval`， 可以从下方代码中看到， 使用**Class.class_eval**， 能让用户以字符串的形式， 在程序运行的时候才决定类的成员变量和方法
这个机制非常重要， 和Java的反射技巧十分相似， 运行时才决定类的特性能极大扩展类的伸缩性，rails也是靠这个特性做起来的。

```ruby
# 1. class_eval
class Person
end

def add_accessor_to_person(accessor_name)
  Person.class_eval %{
  attr_accessor :#{accessor_name}
                    }
end

person = Person.new
add_accessor_to_person :name
add_accessor_to_person :age
person.name = "Stan"
person.age = 21
puts "#{person.name} is #{person.age}" # Stan is 2

# 2. 全局类运行时自定义的场景， 
# 给全局的Class类添加一个自定义的add_accessor方法， 专门用于访问权限的管理。
class Class
  def add_accessor(accessor_name)
    self.class_eval %{
    attr_accessor :#{accessor_name}
                    }
  end
end

class Teacher
end

teacher = Teacher.new
teacher.add_accessor :name
teacher.add_accessor :age
teacher.name = "Linda"
teacher.age = 12
puts "#{teacher.name} + #{teacher.age}"
```