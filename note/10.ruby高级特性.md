### 动态代码执行

该特性类似于JS代码中的`eval`， 当然这里也叫做`eval`, 使用该方法时， 能将字符串转换成ruby代码进行执行。

```ruby
# 1.
puts eval('2+2')
# 输出4

# 2.
my_number = 15
my_code = %{#{my_number} * 2}
puts eval(my_code)
# 30
```

> binding ruby中的术语， 指当前变量所处的上下文环境和变量本身值是有关的。

具体看个binding的例子吧

```ruby
def binding_elsewhere
  x = 20
  # binding是一个方法
  return binding
end

remote_binding = binding_elsewhere

x = 10
eval("puts x") # 10
eval("puts x", remote_binding) # 20
```

上面的例子中可以看出， 使用`binding`的技巧， 能在eval中绑定一个指定的上下文环境， 并读取目标上下文环境里的内容。

除了正常的`eval`之外， ruby还提供`class_eval`, `module_eval`, `instance_eval` 等方法在目标上下文内执行字符串代码

分别看下这几个例子

第一个例子是`class_eval`， 可以从下方代码中看到， 使用**Class.class_eval**， 能让用户以字符串的形式， 在程序运行的时候才决定类的成员变量和方法
这个机制非常重要， 和Java的反射技巧十分相似， 运行时才决定类的特性能极大扩展类的伸缩性，rails也是靠这个特性做起来的。

```ruby
# 1. class_eval
class Person
end

def add_accessor_to_person(accessor_name)
  Person.class_eval %{
  attr_accessor :#{accessor_name}
                    }
end

person = Person.new
add_accessor_to_person :name
add_accessor_to_person :age
person.name = "Stan"
person.age = 21
puts "#{person.name} is #{person.age}" # Stan is 2

# 2. 全局类运行时自定义的场景， 
# 给全局的Class类添加一个自定义的add_accessor方法， 专门用于访问权限的管理。
class Class
  def add_accessor(accessor_name)
    self.class_eval %{
    attr_accessor :#{accessor_name}
                    }
  end
end

class Teacher
end

teacher = Teacher.new
teacher.add_accessor :name
teacher.add_accessor :age
teacher.name = "Linda"
teacher.age = 12
puts "#{teacher.name} + #{teacher.age}"
```

`instance_eval` 如同它的名字， 它的上下文环境会被限制在一个对象实例里,
下方代码展示了一个例子， 可以看到此时能够对任何一个对象使用`instance_eval`来对对象的成员变量和方法为所欲为。

```ruby
class MyClass
  def initialize
    @my_variable = 'Hello, world!'
  end
end

obj = MyClass.new
obj.instance_eval {puts @my_variable}
```

> attr_accessor的原理

基于以上对`eval`的理解， 现在可以来解释一下类里面的attr_accessor是怎么实现的。

attr_accessor的本质其实就是getter + setter的结合， 如果没有这个属性， 那正常情况下要完成对某个属性的getter和setter
会是如下的代码

```ruby
class Person
  # getter
  def name
    @name
  end
  # setter
  def name=(name)
    @name = name
  end
end
```

如果此时用`class_eval`来全局添加一个attr_accessor，得如下代码，
下面用holy_accessor演示

```ruby
# holy_accessor 这里起到了和attr_accessor 一模一样的作用， 
# 而attr_accessor其实也就是这样对大量的代码做了字符串化进行抽取的结果，
# 熟练使用动态代码执行的技巧，对精简代码能有极大的帮助。
class Class
  def holy_accessor(accessor_name)
    self.class_eval %{
      def #{accessor_name}
        @#{accessor_name}
      end
      def #{accessor_name} = (value)
        @#{accessor_name} = value
      end
     }
  end
end

class Sheep
  holy_accessor :name
end

bbb = Sheep.new
bbb.name = "aaa"
puts bbb
```
