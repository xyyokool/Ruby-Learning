## ActiveRecord Associations

### 0. 大纲

- 理解如何在ActiveRecord的Models之间声明事务
- 理解ActiveRecord的Associations的types
- 理解如何通过创建Associations来使用models的关联方法

### 1. 为什么需要关联关系Associations

在Rails里, 关联关系Association描述了两个ActiveRecord models之间的联系. 为什么我们需要关联关系? 因为它们能将关联models之间的操作变得简单且有效. 举个例子, 假如有一个Rails应用拥有Author和Book两个Model, 每位Author可以拥有多个Books. 如果没有关联关系, 那么model的声明会长成这样

```ruby
class Author < ApplicationRecord
  
end

class Book < ApplicationRecord

end
```

现在, 假如我们想要添加一本新的书给到一位作者, 那么我们可能要做如下操作

```ruby
@book = Book.create(published_at: Time.now, author_id: @author.id)
```

当我们需要删除一位作者时, 同时需要删除属于该作者的所有书籍, 则可能如下

```ruby
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end

@author.destroy
```

如果我们切换为使用关联关系Associations, 则我们可以为上面的代码做一个明显的瘦身. 我们只需要告诉Rails两Models的关系就行, 下方是重构后的代码

```ruby
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```

通过上述的修改后, 我们可以非常简单的创建一本属于某位作者的书籍.

```ruby
@book = @author.books.create(published_at: Time.now)
```

当删除这位作者时, 只需要一行代码, 就能同时删除作者和属于该作者的所有书籍

```ruby
@author.destroy
```

通过上述的例子我们可以看到关联关系的便利性, 请阅读下面的章节来增进理解, 同时当中还包含了很多的技巧.

### 2. 关联关系的类型

Rails支持以下6种关联关系

- belongs_to
- has_one
- has_many
- has_many :through
- has_one :through
- has_and_belongs_to_many

关联关系也是通过宏模式进行调用, 因此你可以以声明的形式按需添加到你的Models里. 举个例子, 通过声明某个model`belongs_to`另外一个model, Rails会理解为维持一个`Primary Key - Foreign Key`的关系给到两个models, 同时你会自动获得很多好用的方法来使用这一关系.

在下面的章节里, 你会学到如何声明并且使用各种类型的关联关系. 但是首先请快速的来理解一下每种关联关系的含义.

#### 2.1 belongs_to

`belongs_to`关联关系会建立与另外一个model的联系, 也就是说每一个model实例都会属于(belongs_to)另外一个model的实例. 举个例子, 作者和书籍, 每本书籍都应该属于一位作者, 则代码如下

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

注意: `belongs_to`关联关系必须使用`单数名词`, 如果你使用了`复数名词`的话(比如通过Book.create(authors: @author)), 你可能会碰到`uninitialized constant Book::Authors`错误. 这是因为Rails是自动从关联关系的名称来推断类名的, 如果你的关联关系的名称错误的使用了复数, 那么推断的类名也会错误的被认为是复数.

对应的migration可能如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

当单独使用`belongs_to`的时候, 会生成一个单一方向的连接. 此时上面例子中的每本书都会有作者, 但是作者并不会知道他有这些书. 为了设定双向的联系, `belongs_to`需要组合使用`has_one`或者`has_many`到其他的model里.

光靠`belongs_to`不能确保引用一致性, 因此基于实际的业务逻辑你可能还需要添加一个数据库级别的外键约束到引用的字段上, 比如

```ruby
create_table :books do |t|
  t.belongs_to :author, foreign_key: true
end
```

#### 2.2 has_one

`has_one` 关联关系表达了一个model对另外一个model有一对一的引用关系. 而这个model可以通过关联关系被获取到(fetched, Ruby对象的get方法为fetch)

举个例子, 假如有一个Supplier类拥有一个account, 你可能会声明supplier为如下代码

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

与`belongs_to`的主要区别在于其起到链接作用的外键字段`supplier_id`在对方的表里, 此时对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```

基于项目情况, 可能我们依旧需要创建唯一索引和外键约束来满足需求, 在这种情况下字段的定义可能如下

```ruby
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
end
```

当`has_one`组合使用`belongs_to`时, 则两个models之间的关系会变成双向的.

#### 2.3 has_many

`has_many`关系类似于`has_one`, 但是它表示了models之间存在的是一对多的关系, 该关系表示每一个model实例都会有0~n个其他的model实例. 举个例子, 在一个应用里包括了作者和书籍2个model, 作者的model可能如下被声明

```ruby
class Author < ApplicationRecord
  has_many :books
end
```

注意: 当model的关系为`has_many`的时候, 则对方model的名字需要是复数.

对应的migration可能如下

```ruby
class CreateAuthors < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

基于项目情况, 通常来说对于`has_many`的关系来说, 创建一个非唯一的索引和可选的外键约束能够提升性能

```ruby
create_table :books do |t|
  t.belongs_to :author, index: true, foreign_key: true
end
```

#### 2.4 has_many :through关系

`has_many :through`关系经常被用在设定多对多的关系上. 这个关联关系表示当前声明了这个关系的model与其0-n个models, 可以通过(through)第三方model来访问到. 举个例子, 考虑存在一个病人需要预约来找到医生的例子. 相关的关系可能如下

```ruby
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

从上可以看到, Physician会有很多的Patients, 而一个Patient也可以有很多的Physicians, 两者为多对多的关系, 通过第三张表appointments来进行管理. 此时`physician_id, patient_id`都在appointments表上. 对应的migrations会如下

```ruby
class CreateAppointments < ActiveRecord::Migration[7.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```

关联的models可以通过`has_many`来进行管理, 举个例子, 如果

```ruby
physician.patients = patients
```

那么新的关系会自动创建, 当中如果某些关联关系丢失了, 则相关记录会自动被删除.

注意: 自动删除join的models是直接删除的, 不会触发任何删除回调的逻辑.

`has_many :through`关联关系在设定多对多关系的捷径时也很有用. 举个例子, 如果一篇文档有多个章节, 每个章节又会有多个段落, 有时你可能想直接获取所有段落的集合, 此时你可能会如下设定.

```ruby
class Docment < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```

通过上述的`through: :sections`, Rails会自动识别理解为如下代码

```ruby
@document.paragraphs
```

#### 2.5 has_one :through 关联关系

`has_one :through`关联关系设定了两个models之间一对一的关系. 该关联关系表示声明的model可以通过(through)第三方的model来匹配到其对应的model. 举个例子, 如果一个供应商拥有一个账号, 并且每个账号又关联到一个账号历史, 则供应商model的关系可以如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```

对应的migration如下

```ruby
class CreateAccountHistory < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```

#### 2.6 has_and_belongs_to_many 关联关系

`has_and_belongs_to_many`关联关系能够创建一个直接的多对多的关系, 而不需要中间用于搭桥的model. 举个例子, 如果你的应用包括了`assemblies和parts`两个models, 每个`assembly`会有多个`parts`,每个`part`会出现在多个`assemblies`里, 你可以如下声明models

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end


class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

此时会自动以2个Models的名称的复数, 来生成第三张表多多的映射表, migrations如下

```ruby
class CreateAssembliesAndParts < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```

#### 2.7 belongs_to和has_one如何选

如果你想要在两个models之间设定1对1的关系, 你需要给其中一个model加上`belongs_to`,另外一个加上`has_one`, 但是谁加给谁怎么决定?

两者的主要区别在于外键(belongs_to的那一方会加上外键约束),但是你依然需要思考数据的实际意义. `has_one`关系表示的是某个东西里的某一个是属于你的, 也就是说, 通过那个东西能反向找到你. 举个例子, 账号和供应商的关系, 它们之间正确的关系如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```

对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint :supplier_id
      t.string :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```

注意: 使用`t.bigint :supplier_id`能让外键的命名容易理解和识别, 在当前版本的Rails里, 你可以使用`t.references :supplier`来代替.

#### 2.8 has_many :through 和 has_and_belongs_to_many如何选

Rails提供了2种完全不同的方法来声明models的多对多关系, 第一种方法是使用`has_and_belongs_to_many`, 该方法允许你直接创建关联关系.

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

第二种方式声明多对多是使用`has_many :through`, 这个指令是通过一个join的model,来间接创建多对多的关系.

```ruby
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```

最佳实践表示, 如果你需要用到`relationship`的join的model当作一个独立的实体的话, 则你应该设定`has_many :through`关系. 如果你不需要在`relationship`的model上做任何操作的话, 直接用`has_and_belongs_to_many`关系会更简单一些(尽管你需要记住自动创建的第三张表叫啥, 而且要手动创建一下这张表)

如果你需要`validations, callbacks, attributes`等等属性和功能的话, 你应该使用`has_many :through`来管理join model.

#### 2.9 多态(Poly)关联关系

一个稍微复杂的例子是多态关联关系. 使用多态关联关系的话, 则一个model可以属于(belongs_to)超过一个的其他models. 举个例子, 如果你拥有一个picture model, 它既属于一个employee的model, 又属于一个product的model, 此时可以如下声明

```ruby
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :picutures, as: :imageable
end
```

你可以把`polymorphic`的`belongs_to`声明当作是在设定一个接口名称, 这个接口可以提供给其他的models自由使用. 从上面的例子中, 你可以通过一个`Employee`的实例, 来获取到一组照片`@employee.pictures`

相似的, 也可以通过`@product.pictures`来获取照片.