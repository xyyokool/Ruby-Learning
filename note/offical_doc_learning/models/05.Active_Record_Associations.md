## ActiveRecord Associations

### 0. 大纲

- 理解如何在ActiveRecord的Models之间声明事务
- 理解ActiveRecord的Associations的types
- 理解如何通过创建Associations来使用models的关联方法

### 1. 为什么需要关联关系Associations

在Rails里, 关联关系Association描述了两个ActiveRecord models之间的联系. 为什么我们需要关联关系? 因为它们能将关联models之间的操作变得简单且有效. 举个例子, 假如有一个Rails应用拥有Author和Book两个Model, 每位Author可以拥有多个Books. 如果没有关联关系, 那么model的声明会长成这样

```ruby
class Author < ApplicationRecord
  
end

class Book < ApplicationRecord

end
```

现在, 假如我们想要添加一本新的书给到一位作者, 那么我们可能要做如下操作

```ruby
@book = Book.create(published_at: Time.now, author_id: @author.id)
```

当我们需要删除一位作者时, 同时需要删除属于该作者的所有书籍, 则可能如下

```ruby
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end

@author.destroy
```

如果我们切换为使用关联关系Associations, 则我们可以为上面的代码做一个明显的瘦身. 我们只需要告诉Rails两Models的关系就行, 下方是重构后的代码

```ruby
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```

通过上述的修改后, 我们可以非常简单的创建一本属于某位作者的书籍.

```ruby
@book = @author.books.create(published_at: Time.now)
```

当删除这位作者时, 只需要一行代码, 就能同时删除作者和属于该作者的所有书籍

```ruby
@author.destroy
```

通过上述的例子我们可以看到关联关系的便利性, 请阅读下面的章节来增进理解, 同时当中还包含了很多的技巧.

### 2. 关联关系的类型

Rails支持以下6种关联关系

- belongs_to
- has_one
- has_many
- has_many :through
- has_one :through
- has_and_belongs_to_many

关联关系也是通过宏模式进行调用, 因此你可以以声明的形式按需添加到你的Models里. 举个例子, 通过声明某个model`belongs_to`另外一个model, Rails会理解为维持一个`Primary Key - Foreign Key`的关系给到两个models, 同时你会自动获得很多好用的方法来使用这一关系.

在下面的章节里, 你会学到如何声明并且使用各种类型的关联关系. 但是首先请快速的来理解一下每种关联关系的含义.

#### 2.1 belongs_to

`belongs_to`关联关系会建立与另外一个model的联系, 也就是说每一个model实例都会属于(belongs_to)另外一个model的实例. 举个例子, 作者和书籍, 每本书籍都应该属于一位作者, 则代码如下

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

注意: `belongs_to`关联关系必须使用`单数名词`, 如果你使用了`复数名词`的话(比如通过Book.create(authors: @author)), 你可能会碰到`uninitialized constant Book::Authors`错误. 这是因为Rails是自动从关联关系的名称来推断类名的, 如果你的关联关系的名称错误的使用了复数, 那么推断的类名也会错误的被认为是复数.

对应的migration可能如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

当单独使用`belongs_to`的时候, 会生成一个单一方向的连接. 此时上面例子中的每本书都会有作者, 但是作者并不会知道他有这些书. 为了设定双向的联系, `belongs_to`需要组合使用`has_one`或者`has_many`到其他的model里.

光靠`belongs_to`不能确保引用一致性, 因此基于实际的业务逻辑你可能还需要添加一个数据库级别的外键约束到引用的字段上, 比如

```ruby
create_table :books do |t|
  t.belongs_to :author, foreign_key: true
end
```

#### 2.2 has_one

`has_one` 关联关系表达了一个model对另外一个model有一对一的引用关系. 而这个model可以通过关联关系被获取到(fetched, Ruby对象的get方法为fetch)

举个例子, 假如有一个Supplier类拥有一个account, 你可能会声明supplier为如下代码

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

与`belongs_to`的主要区别在于其起到链接作用的外键字段`supplier_id`在对方的表里, 此时对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```

基于项目情况, 可能我们依旧需要创建唯一索引和外键约束来满足需求, 在这种情况下字段的定义可能如下

```ruby
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
end
```

当`has_one`组合使用`belongs_to`时, 则两个models之间的关系会变成双向的.

#### 2.3 has_many

`has_many`关系类似于`has_one`, 但是它表示了models之间存在的是一对多的关系, 该关系表示每一个model实例都会有0~n个其他的model实例. 举个例子, 在一个应用里包括了作者和书籍2个model, 作者的model可能如下被声明

```ruby
class Author < ApplicationRecord
  has_many :books
end
```

注意: 当model的关系为`has_many`的时候, 则对方model的名字需要是复数.

对应的migration可能如下

```ruby
class CreateAuthors < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

基于项目情况, 通常来说对于`has_many`的关系来说, 创建一个非唯一的索引和可选的外键约束能够提升性能

```ruby
create_table :books do |t|
  t.belongs_to :author, index: true, foreign_key: true
end
```

#### 2.4 has_many :through关系

`has_many :through`关系经常被用在设定多对多的关系上. 这个关联关系表示当前声明了这个关系的model与其0-n个models, 可以通过(through)第三方model来访问到. 举个例子, 考虑存在一个病人需要预约来找到医生的例子. 相关的关系可能如下

```ruby
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

从上可以看到, Physician会有很多的Patients, 而一个Patient也可以有很多的Physicians, 两者为多对多的关系, 通过第三张表appointments来进行管理. 此时`physician_id, patient_id`都在appointments表上. 对应的migrations会如下

```ruby
class CreateAppointments < ActiveRecord::Migration[7.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```

关联的models可以通过`has_many`来进行管理, 举个例子, 如果

```ruby
physician.patients = patients
```

那么新的关系会自动创建, 当中如果某些关联关系丢失了, 则相关记录会自动被删除.

注意: 自动删除join的models是直接删除的, 不会触发任何删除回调的逻辑.

`has_many :through`关联关系在设定多对多关系的捷径时也很有用. 举个例子, 如果一篇文档有多个章节, 每个章节又会有多个段落, 有时你可能想直接获取所有段落的集合, 此时你可能会如下设定.

```ruby
class Docment < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```

通过上述的`through: :sections`, Rails会自动识别理解为如下代码

```ruby
@document.paragraphs
```

#### 2.5 has_one :through 关联关系

`has_one :through`关联关系设定了两个models之间一对一的关系. 该关联关系表示声明的model可以通过(through)第三方的model来匹配到其对应的model. 举个例子, 如果一个供应商拥有一个账号, 并且每个账号又关联到一个账号历史, 则供应商model的关系可以如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```

对应的migration如下

```ruby
class CreateAccountHistory < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```

#### 2.6 has_and_belongs_to_many 关联关系

`has_and_belongs_to_many`关联关系能够创建一个直接的多对多的关系, 而不需要中间用于搭桥的model. 举个例子, 如果你的应用包括了`assemblies和parts`两个models, 每个`assembly`会有多个`parts`,每个`part`会出现在多个`assemblies`里, 你可以如下声明models

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end


class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

此时会自动以2个Models的名称的复数, 来生成第三张表多多的映射表, migrations如下

```ruby
class CreateAssembliesAndParts < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```

#### 2.7 belongs_to和has_one如何选

如果你想要在两个models之间设定1对1的关系, 你需要给其中一个model加上`belongs_to`,另外一个加上`has_one`, 但是谁加给谁怎么决定?

两者的主要区别在于外键(belongs_to的那一方会加上外键约束),但是你依然需要思考数据的实际意义. `has_one`关系表示的是某个东西里的某一个是属于你的, 也就是说, 通过那个东西能反向找到你. 举个例子, 账号和供应商的关系, 它们之间正确的关系如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```

对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint :supplier_id
      t.string :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```

注意: 使用`t.bigint :supplier_id`能让外键的命名容易理解和识别, 在当前版本的Rails里, 你可以使用`t.references :supplier`来代替.

#### 2.8 has_many :through 和 has_and_belongs_to_many如何选

Rails提供了2种完全不同的方法来声明models的多对多关系, 第一种方法是使用`has_and_belongs_to_many`, 该方法允许你直接创建关联关系.

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

第二种方式声明多对多是使用`has_many :through`, 这个指令是通过一个join的model,来间接创建多对多的关系.

```ruby
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```

最佳实践表示, 如果你需要用到`relationship`的join的model当作一个独立的实体的话, 则你应该设定`has_many :through`关系. 如果你不需要在`relationship`的model上做任何操作的话, 直接用`has_and_belongs_to_many`关系会更简单一些(尽管你需要记住自动创建的第三张表叫啥, 而且要手动创建一下这张表)

如果你需要`validations, callbacks, attributes`等等属性和功能的话, 你应该使用`has_many :through`来管理join model.

#### 2.9 多态(Poly)关联关系

一个稍微复杂的例子是多态关联关系. 使用多态关联关系的话, 则一个model可以属于(belongs_to)超过一个的其他models. 举个例子, 如果你拥有一个picture model, 它既属于一个employee的model, 又属于一个product的model, 此时可以如下声明

```ruby
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```

你可以把`polymorphic`的`belongs_to`声明当作是在设定一个接口名称, 这个接口可以提供给其他的models自由使用. 从上面的例子中, 你可以通过一个`Employee`的实例, 来获取到一组照片`@employee.pictures`

相似的, 也可以通过`@product.pictures`来获取照片.

如果你有`Picture`这个model的一个实例的话, 则你可以通过`@picture.imageable`来访问到它的parent. 为了让其起作用, 你需要同时为model声明一个外键字段和一个类型字段以用来表示是多态的接口

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```

这个migration可以用`t.references`简化

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end

# t.references, ploymorphic: true 会自动给表加上imageable_id imageable_type 2个字段
```

#### 2.10 Self Joins

在设计一个model的时候, 有时你可能会发现你需要关联到model自身. 举个例子, 你可能想要在一个单一的数据库model里存储所有的雇员信息, 但是又希望能区分它们为经理或者普通员工. 这种情况可以通过`self-joining`关系来解决

```ruby
class Employee < ApplicationRecord
  has_many :subordinates, class_name: 'Employee', foreign_key: 'manager_id'
  belongs_to :manager, class_name: 'Employee', optional: true
end
```

通过这样的设置, 你可以通过`@employee.subordinates`, `@employee.manager`来获取不同的对象.

在migrations里, 你需要加入一个引用字段给到model自身

```ruby
class CreateEmployees < ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      t.references :manager, foreign_key: { to_table: :employees }
      t.timestamps
    end
  end
end
```

### 3. 技巧与警告

这里有些准则你需要遵守以有效使用关联关系

- 控制缓存
- 避免名称冲突
- 更新schema
- 控制关联关系的范围(scope)
- 双向关系

#### 3.1 控制缓存

所有关联关系的方法都是基于缓存来完成的, 它们会缓存最为常用的查询结果来完成复杂的操作. 缓存是跨方法的, 比如

```ruby
author.books.load

# 会使用上面的缓存
author.books.size
# 会使用上面的缓存
author.books.empty?
```

但是如果你想重新加载缓存的话应该怎么做? 调用`reload`来刷新缓存

```ruby
author.books.load
author.books.size
# 重新从数据库加载最新的数据
author.books.reload.empty?
```

#### 3.2 避免命名冲突

不要使用已经被`ActiveRecord::Base`所占用的名称. 关联关系的方法会覆盖继承的父类的方法.比如`attributes`,`connection`都是错误的命名

#### 3.3 更新Schema

关联关系非常的有用, 你有必要维护整个数据库schema的正确以确保匹配你的关联关系. 在实践中, 你需要做以下2件事. 

1. 对于`belongs_to`的关联关系, 你应该创建外键.

当你声明`belongs_to`关系时, 你需要创建合理的外键. 举个例子

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

这个声明需要在books表里有合适的外键字段. 如果此时是一张新表, 则migration应该如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```

如果是既存的表, 则migration应该如下

```ruby
class AddAuthorToBooks < ActiveRecord::Migration[7.0]
  def change
    add_reference :books, :author
  end
end
```

注意: 如果你要确保数据库层面的引用关系完整, 请在上面的例子里加上`foreign_key: true`配置项给到`reference`字段


2. 对于`has_and_belongs_to_many`的关联关系, 你应该创建合适的join表.

如果你是通过`has_and_belongs_to_many`关联关系创建的, 则你需要显式的创建join表. 除非你写了`:join_table`配置项. ActiveRecord会自动按照词法优先级来创建表名, 比如`authors, books`两张表的join表会自动为`authors_books`, 因为`a`在`b`的前面.

注意: 前面的models的名称使用的是`String`的`<=>`操作符来计算的. 也就意味着如果字符串长度不一样, 则较长的字符串会被认为有较高的词法优先级. 举个例子, 表`paper_boxes`和`papers`结合生成的join表名会为`paper_boxes_papers`, 因为下划线`_`在词法上低于`s`.

无论名字是啥, 你都必须手动创建join table, 举个例子

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

上述例子需要`assemblies_parts`这个join表来支撑才能完成关联关系. 这张表不应该拥有主键

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```

我们传递了`id: false`在`create_table`的时候, 因为这张join表不需要表现为一个model. 如果你在`has_and_belongs_to_many`的关系上看到了任何奇怪的行为或者id冲突等问题, 很有可能是因为你可能忘了取消主键导致的.

你也可以使用`create_join_table`方法

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```

#### 3.4 控制关联关系的范围(scope)

默认情况下, 关联关系仅会限制在当前的module的范围内, 举个例子

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

上述例子会正常工作, 因为`Supplier`和`Account`这2个类都定义在了相同的作用域里. 但是下面的例子就不行了, 因为它们定义在了不同的作用域里

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

为了关联不同命名空间的model, 你需要完整的声明类名

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```

#### 3.5 双向关系

声明双向关系是必须且普遍的事情

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```

Active Record会尝试基于关联关系的名称,来自动识别这2个models的双向关系,如下

```ruby
a = Author.first
b = a.books.first
a.first_name == b.author.first_name
a.first_name = 'David'
a.first_name == b.author.first_name
```

Active Record支持自动识别大多数的标准名称. 但是, Active Record不能自动识别带`:through`或者`:foreign_key`配置项的双向关系. 此外自定义作用域的也没法自动识别, 除非

`config.active_record.automatic_scope_inversing` = true 这个项目配置被设定.默认是开启的.

举个例子

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

Active Record此时不会自动识别双边关系.

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

为此, Active Record提供了`:inverse_of`配置项来帮助你显式的声明双向关系.

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

通过加入`:inverse_of`配置项到`has_many`关系声明, Active Record则可以识别双向关系

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

### 4. 关联关系引用细节

下面的章节给出了每种关联关系的细节, 包括它们会提供的方法和可以用到的配置项.

#### 4.1 belongs_to 关联关系引用

从数据库的角度来说的话, `belongs_to`的关联关系表达了这个model的表会有一个字段, 该字段用于和其他的表做引用连接. `belongs_to`可以用在一对多,也可以用在一对一的关系上. 如果是一对一的关系, 则应该用`has_one`.

##### 4.1.1 belongs_to增加的方法

当你声明一个`belongs_to`关联关系的时候, 声明的类会自动追加8个方法. 分别如下

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association
- association_changed?
- association_previously_changed?

所有上述的方法, `association`文字描述的位置都要以`belongs_to`的第一个参数的Symbol来替换.比如

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

此时,每一个`Book`的model的实例, 都会有如下的方法

```sh
author
author=
build_author
create_author
create_author!
reload_author
author_changed?
author_previously_changed?
```

当初始化一个新的`has_one`或者`belongs_to`关联关系的时候, 你必须使用`build_`前缀来创建关联关系, 而对于`association.build`方法来说, 它更适合用在`has_many`或`has_and_belongs_to_many`关联关系上.如果是`create`,则应该使用`create_`前缀.

###### 4.1.1.1 association

`association`方法会返回存在的所有关联对象. 如果没有找到关联对象, 则返回`nil`

```ruby
@author = @book.author
```

如果关联的对象已经从数据库里被加载, 则第二次要的时候会返回缓存的版本. 为了覆盖这一行为(即强制重新从数据库加载), 可以调用父对象的`reload_association`方法来完成.

再次提醒, 这里的`reload_association`,带下划线的这些方法, 都是给到一对一关系的.

```ruby
@author = @book.reload_author
```

###### 4.1.1.2 association=(associate)

`association=`方法可以将一个关联的对象赋值到这个对象上. 从原理上说, 这意味着提取出关联对象的主键, 并设定对象的外键为这个主键的值.

```ruby
@book.author = @author
```

###### 4.1.1.3 build_association(attributes = {})

`build_association`方法, 会返回关联关系类型的一个新的对象. 该对象会以传入的属性来进行实例化, 并且会设定好外键关系, 但是要注意此时**还没有**被持久化到数据库.

```ruby
@author = @book.build_author(author_number: 123, author_name: "zhangsan")
```

###### 4.1.1.4 create_association(attributes = {})

`create_association`方法和上面的方法一样, 但是会触发model的校验逻辑, 并且如果校验通过,则**会自动**持久化到数据库里.

###### 4.1.1.5 create_association!(attributes = {})

和上面的4.1.1.4的方法一摸一样, 但是在创建对象失败时(invalid)会抛出`ActiveRecord::RecordInvalid`的异常.

###### 4.1.1.6 association_changed?

`association_changed?`方法用于确认关联对象是否在未持久化到数据库时发生了改变. 如果持久化了, 则返回false, 如果没持久化但是发生了改变, 则返回true.

```ruby
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.author_changed? # => true

@book.save!
@book.author_changed? # => false
```

###### 4.1.1.7 association_previously_changed?

`association_previously_changed?`方法会在关联对象发生过变化时返回true

```ruby
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_previously_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.save!
@book.author_previously_changed? # => true
```

##### 4.1.2 Options for belongs_to

Rails在大多数情况下都能自动处理好双边关系, 但是如果需要自定义`belongs_to`关系的引用行为的话, 则需要使用配置项. 举个例子

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at, counter_cache: true
end
```

`belongs_to`关联关系支持如下配置项目

- :autosave
- :class_name
- :counter_cache
- :dependent
- :foreign_key
- :primary_key
- :inverse_of
- :polymorphic
- :touch
- :validate
- :optional

###### 4.1.2.1 :autosave

如果你设定了`autosave: true`, 则Rails会自动在父对象发生`save`保存的时候,自动保存与删除关联对象. 设定`autosave: false` 并不等价于不设定`:autosave`配置项, 如果`:autosave`配置项没有被用到, 那么新的关联关系对象将会被保存到数据库, 但是更新的关联关系对象则不会被自动保存到数据库.

###### 4.1.2.2 :class_name

如果另一个model的名字不能直接通过association的名字来自动获取的话, 你可以使用`:class_name`配置项来提供一个类名. 举个例子, 假如一本书属于一个作者, 但是作者的类叫做Patron, 则你可以如下设定.

```ruby
class Book < ApplicationRecord
  belongs_to :author, class_name: 'Patron'
end
```

###### 4.1.2.3 :counter_cache

`:counter_cache`配置项可以被用在高效的查找所拥有对象的数量上. 考虑如下models

```ruby
class Book < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :books
end
```

通过上述的声明, 可以通过`@author.books.size`来调用数据库的`COUNT(*)`查询API. 为了避免反复调用数据库查询, 你可以添加计数器的缓存到所拥有的model里

```ruby
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end

class Author < ApplicationRecord
  has_many :books
end
```

通过上述声明, Rails会启用缓存机制来保存`size`方法的查询结果.

尽管`:counter_cache`配置项是被用在`belongs_to`的声明上的, 但是要注意它所对应的关联关系必须是`has_many`的model才可以. 在上面的例子里, 你可能会需要添加一个字段叫做`books_count`到`Author`这个model里.

你可以通过声明一个字段名称来替换掉`counter_cache: true`里的`true`选项以保存结果到这个字段里. 举个例子, 使用`count_of_books`来代替使用`books_count`

```ruby
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end

class Author < ApplicationRecord
  has_many :books
end
```

注意: 你仅需要在`belongs_to`这边的model上添加`counter_cache`配置项.

Counter cache 字段会以只读属性(attr_readonly)被添加到所属的model的属性里.

###### 4.1.2.4 :dependent

如果你设定了`:dependent`配置项

- `:destroy`, 当对象被`destroyed`的时候, 则其关联的对象就会自动`destroy`
- `:delete`, 当对象被`destroyed`的时候, 则其关联的对象会直接从数据库里删除, 而不会调用`destroy`方法去删除.
- `:destroy_async`, 当对象被`destroyed`的时候, 一个`ActiveRecord::DestroyAssociationAsyncJob`的job会被自动加入到队列里,Active Job必须开启才能使用.

注意: 你不应该设定`belongs_to`关系给到其他还带了`has_many`关系的model里, 这样的话会导致`orphaned`记录的出现. 举个例子, A -> B 可以级联删除, 但是 A -> B -> C, 是没法删除到C的.

###### 4.1.2.5 :foreign_key

出于便利, Rails会假定默认外键字段名称为`association_id`. 而`:foreign_key`配置项允许你直接配置外键的名称.

```ruby
class Book < ApplicationRecord
  belongs_to :author, foreign_key: "patron_id", class_name: "Patron"
end
```

注意: 在任何情况下, Rails都不会主动给你创建外键字段, 这些外键字段的创建你都必须自己在migrations里显式加上数据库里才会有.

###### 4.1.2.6 :primary_key

默认情况下, Rails会假设`id`字段会被当作表的主键, 而`:primary_key`配置项则允许你使用其他的字段来定义为主键.

举个例子, 假设我们拥有一个`users`表, 其主键字段为`guid`, 如果我们想要一个其他的表来关联这个自定义的主键的话, 我们可以使用`primary_key`来向如下一样达到需求.

```ruby
class User < ApplicationRecord
  self.primary_key = 'guid' # 设定该model的主键为guid, 而不是user_id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```

当我们执行`@user.todos.create`时, `@todo`记录将会从默认的`user_id`改为`guid`的值

###### 4.1.2.7 :inverse_of

`:inverse_of`配置项详细说明了`has_many`或者`has_one`关系的`name`是`inverse_of`的反转. 只有配了这个反转, 才可以反向获取关联对象.

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

###### 4.1.2.8 :polymorphic

传递`true`给到`:polymorphic`配置项表明这是一个多态的关联关系. 请参照之前对多态的描述.

###### 4.1.2.9 :touch

如果你设定了`:touch`配置项为`true`, 则关联对象的`updated_at`或者`updated_on`时间戳字段会被修改成当前时间, 无论这条记录是更新还是删除.

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
```

在这个场景下, 保存或者删除一本书都将会更新关联作者的时间戳, 你也可以指定一个自定义的时间戳属性来更新

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```

###### 4.1.2.10 :validate

如果你设定`:validate`配置项为`true`, 则无论在任何时候, 当你尝试`save`对象时, 都会触发校验逻辑. 默认情况下为`false`,即当新的关联对象被保存时,这些新的关联对象不会走它们的校验逻辑.

###### 4.1.2.11 :optional

如果你设定`:optional`配置项为`true`时, 则关联对象是否存在将不会被校验. 默认情况下, 这个配置项是设定为`false`的.(即设定了该配置项,则关联对象可以为nil)

##### 4.1.3 belongs_to的作用范围

你偶尔可能需要自定义你的`belongs_to`的关联关系的查询方式, 以自定义需要返回的内容, 你可以如下例子一样进行操作

```ruby
class Book < ApplicationRecord
  belongs_to :author, -> { where(active: true) }
end
```

你可以在scope的代码块里使用任何方式的查询方法, 下面是常用的一些

- where
- includes
- readonly
- select

###### 4.1.3.1 where

`where`方法能让你声明关联对象必须要满足的条件

```ruby
class Book < ApplicationRecord
  belongs_to :author, -> { where(active: true) }
end
```

###### 4.1.3.2 includes

你可以使用`includes`方法来声明那些, 当使用关联对象时, 那些需要被急切加载的二阶关联对象.举个例子, 考虑如下这些models

```ruby
class Chapter < ApplicationRecord
  belongs_to :book
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```

如果你经常从`chapters`来直接获取`authors`(@chapter.book.author), 那么你可以通过往`Chapter`类里`includes`另外的`Author`类来提升查询效率.

```ruby
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```

注意: 对于直接的关联关系而言, 你不必使用`includes`, 也就是说, 如果你有`Book belongs_to :author`的话, 那么`author`会在需要时自动急切加载(eager-loaded)

###### 4.1.3.3 readonly

如果你使用了`readonly`, 那么关联对象将会在被提取使用时变成只读的.

###### 4.1.3.4 select

`select`方法能让你覆盖`SELECT`的SQL语法, 默认情况下, Rails会返回所有的字段(即默认为 select *, 而当启用此配置时可自定返回的字段)

注意: 如果你在一个`belongs_to`关联关系上使用了`select`方法, 那么你应该设定`:foreign_key`选项以确保能获取到正确的结果.

##### 4.1.4 判断关联对象是否存在.

你可以通过使用`association.nil?`来确认是否关联对象存在.

```ruby
def test
  if @book.author.nil?
    @msg = "No author"
  end
end
```

##### 4.1.5 什么时候对象会被保存(saved)

赋予一个对象到`belongs_to`的关联对象上并不会自动保存. 同样也不会保存其他关联对象.

#### 4.2 has_one 关联关系引用

`has_one`关联关系会创建一个一对一的关系, 从数据库角度来说, 这个关联关系表示另外一个类会包含外键, 如果这个类已经包含了外键, 那么你应该使用`belongs_to`来代替.(即belongs_to写在哪里, 就有那个外键.)

##### 4.2.1 has_one 添加上的方法

如下方法会通过声明`has_one`关系来自动添加

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association

所有这东西的方法, `association`字符串都需要被`has_one`所标注使用的Symbol来代替, 举个例子

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

每一个`Supplier`这个model的实例都应该有如下这些方法

```ruby
account
account=
build_account
create_account
create_account!
reload_account
```

当实例化一个新的`has_one`或者`belongs_to`关系时, 你必须使用`build_`前缀来`build`一个关联关系, 而`association.build`方法只适用于`has_many`或者`has_and_belongs_to_many`关联关系. 如果要`create`一个, 则应该使用`create_`前缀.

###### 4.2.1.1 association

