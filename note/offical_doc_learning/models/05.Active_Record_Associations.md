## ActiveRecord Associations

### 0. 大纲

- 理解如何在ActiveRecord的Models之间声明事务
- 理解ActiveRecord的Associations的types
- 理解如何通过创建Associations来使用models的关联方法

### 1. 为什么需要关联关系Associations

在Rails里, 关联关系Association描述了两个ActiveRecord models之间的联系. 为什么我们需要关联关系? 因为它们能将关联models之间的操作变得简单且有效. 举个例子, 假如有一个Rails应用拥有Author和Book两个Model, 每位Author可以拥有多个Books. 如果没有关联关系, 那么model的声明会长成这样

```ruby
class Author < ApplicationRecord
  
end

class Book < ApplicationRecord

end
```

现在, 假如我们想要添加一本新的书给到一位作者, 那么我们可能要做如下操作

```ruby
@book = Book.create(published_at: Time.now, author_id: @author.id)
```

当我们需要删除一位作者时, 同时需要删除属于该作者的所有书籍, 则可能如下

```ruby
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end

@author.destroy
```

如果我们切换为使用关联关系Associations, 则我们可以为上面的代码做一个明显的瘦身. 我们只需要告诉Rails两Models的关系就行, 下方是重构后的代码

```ruby
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```

通过上述的修改后, 我们可以非常简单的创建一本属于某位作者的书籍.

```ruby
@book = @author.books.create(published_at: Time.now)
```

当删除这位作者时, 只需要一行代码, 就能同时删除作者和属于该作者的所有书籍

```ruby
@author.destroy
```

通过上述的例子我们可以看到关联关系的便利性, 请阅读下面的章节来增进理解, 同时当中还包含了很多的技巧.

### 2. 关联关系的类型

Rails支持以下6种关联关系

- belongs_to
- has_one
- has_many
- has_many :through
- has_one :through
- has_and_belongs_to_many

关联关系也是通过宏模式进行调用, 因此你可以以声明的形式按需添加到你的Models里. 举个例子, 通过声明某个model`belongs_to`另外一个model, Rails会理解为维持一个`Primary Key - Foreign Key`的关系给到两个models, 同时你会自动获得很多好用的方法来使用这一关系.

在下面的章节里, 你会学到如何声明并且使用各种类型的关联关系. 但是首先请快速的来理解一下每种关联关系的含义.

#### 2.1 belongs_to

`belongs_to`关联关系会建立与另外一个model的联系, 也就是说每一个model实例都会属于(belongs_to)另外一个model的实例. 举个例子, 作者和书籍, 每本书籍都应该属于一位作者, 则代码如下

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

注意: `belongs_to`关联关系必须使用`单数名词`, 如果你使用了`复数名词`的话(比如通过Book.create(authors: @author)), 你可能会碰到`uninitialized constant Book::Authors`错误. 这是因为Rails是自动从关联关系的名称来推断类名的, 如果你的关联关系的名称错误的使用了复数, 那么推断的类名也会错误的被认为是复数.

对应的migration可能如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

当单独使用`belongs_to`的时候, 会生成一个单一方向的连接. 此时上面例子中的每本书都会有作者, 但是作者并不会知道他有这些书. 为了设定双向的联系, `belongs_to`需要组合使用`has_one`或者`has_many`到其他的model里.

光靠`belongs_to`不能确保引用一致性, 因此基于实际的业务逻辑你可能还需要添加一个数据库级别的外键约束到引用的字段上, 比如

```ruby
create_table :books do |t|
  t.belongs_to :author, foreign_key: true
end
```

#### 2.2 has_one

`has_one` 关联关系表达了一个model对另外一个model有一对一的引用关系. 而这个model可以通过关联关系被获取到(fetched, Ruby对象的get方法为fetch)

举个例子, 假如有一个Supplier类拥有一个account, 你可能会声明supplier为如下代码

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

与`belongs_to`的主要区别在于其起到链接作用的外键字段`supplier_id`在对方的表里, 此时对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```

基于项目情况, 可能我们依旧需要创建唯一索引和外键约束来满足需求, 在这种情况下字段的定义可能如下

```ruby
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
end
```

当`has_one`组合使用`belongs_to`时, 则两个models之间的关系会变成双向的.

#### 2.3 has_many

`has_many`关系类似于`has_one`, 但是它表示了models之间存在的是一对多的关系, 该关系表示每一个model实例都会有0~n个其他的model实例. 举个例子, 在一个应用里包括了作者和书籍2个model, 作者的model可能如下被声明

```ruby
class Author < ApplicationRecord
  has_many :books
end
```

注意: 当model的关系为`has_many`的时候, 则对方model的名字需要是复数.

对应的migration可能如下

```ruby
class CreateAuthors < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

基于项目情况, 通常来说对于`has_many`的关系来说, 创建一个非唯一的索引和可选的外键约束能够提升性能

```ruby
create_table :books do |t|
  t.belongs_to :author, index: true, foreign_key: true
end
```

#### 2.4 has_many :through关系

`has_many :through`关系经常被用在设定多对多的关系上. 这个关联关系表示当前声明了这个关系的model与其0-n个models, 可以通过(through)第三方model来访问到. 举个例子, 考虑存在一个病人需要预约来找到医生的例子. 相关的关系可能如下

```ruby
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

从上可以看到, Physician会有很多的Patients, 而一个Patient也可以有很多的Physicians, 两者为多对多的关系, 通过第三张表appointments来进行管理. 此时`physician_id, patient_id`都在appointments表上. 对应的migrations会如下

```ruby
class CreateAppointments < ActiveRecord::Migration[7.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```

关联的models可以通过`has_many`来进行管理, 举个例子, 如果

```ruby
physician.patients = patients
```

那么新的关系会自动创建, 当中如果某些关联关系丢失了, 则相关记录会自动被删除.

注意: 自动删除join的models是直接删除的, 不会触发任何删除回调的逻辑.

`has_many :through`关联关系在设定多对多关系的捷径时也很有用. 举个例子, 如果一篇文档有多个章节, 每个章节又会有多个段落, 有时你可能想直接获取所有段落的集合, 此时你可能会如下设定.

```ruby
class Docment < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```

通过上述的`through: :sections`, Rails会自动识别理解为如下代码

```ruby
@document.paragraphs
```

#### 2.5 has_one :through 关联关系

`has_one :through`关联关系设定了两个models之间一对一的关系. 该关联关系表示声明的model可以通过(through)第三方的model来匹配到其对应的model. 举个例子, 如果一个供应商拥有一个账号, 并且每个账号又关联到一个账号历史, 则供应商model的关系可以如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```

对应的migration如下

```ruby
class CreateAccountHistory < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```

#### 2.6 has_and_belongs_to_many 关联关系

`has_and_belongs_to_many`关联关系能够创建一个直接的多对多的关系, 而不需要中间用于搭桥的model. 举个例子, 如果你的应用包括了`assemblies和parts`两个models, 每个`assembly`会有多个`parts`,每个`part`会出现在多个`assemblies`里, 你可以如下声明models

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end


class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

此时会自动以2个Models的名称的复数, 来生成第三张表多多的映射表, migrations如下

```ruby
class CreateAssembliesAndParts < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```

#### 2.7 belongs_to和has_one如何选

如果你想要在两个models之间设定1对1的关系, 你需要给其中一个model加上`belongs_to`,另外一个加上`has_one`, 但是谁加给谁怎么决定?

两者的主要区别在于外键(belongs_to的那一方会加上外键约束),但是你依然需要思考数据的实际意义. `has_one`关系表示的是某个东西里的某一个是属于你的, 也就是说, 通过那个东西能反向找到你. 举个例子, 账号和供应商的关系, 它们之间正确的关系如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```

对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint :supplier_id
      t.string :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```

注意: 使用`t.bigint :supplier_id`能让外键的命名容易理解和识别, 在当前版本的Rails里, 你可以使用`t.references :supplier`来代替.

#### 2.8 has_many :through 和 has_and_belongs_to_many如何选

Rails提供了2种完全不同的方法来声明models的多对多关系, 第一种方法是使用`has_and_belongs_to_many`, 该方法允许你直接创建关联关系.

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

第二种方式声明多对多是使用`has_many :through`, 这个指令是通过一个join的model,来间接创建多对多的关系.

```ruby
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```

最佳实践表示, 如果你需要用到`relationship`的join的model当作一个独立的实体的话, 则你应该设定`has_many :through`关系. 如果你不需要在`relationship`的model上做任何操作的话, 直接用`has_and_belongs_to_many`关系会更简单一些(尽管你需要记住自动创建的第三张表叫啥, 而且要手动创建一下这张表)

如果你需要`validations, callbacks, attributes`等等属性和功能的话, 你应该使用`has_many :through`来管理join model.

#### 2.9 多态(Poly)关联关系

一个稍微复杂的例子是多态关联关系. 使用多态关联关系的话, 则一个model可以属于(belongs_to)超过一个的其他models. 举个例子, 如果你拥有一个picture model, 它既属于一个employee的model, 又属于一个product的model, 此时可以如下声明

```ruby
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```

你可以把`polymorphic`的`belongs_to`声明当作是在设定一个接口名称, 这个接口可以提供给其他的models自由使用. 从上面的例子中, 你可以通过一个`Employee`的实例, 来获取到一组照片`@employee.pictures`

相似的, 也可以通过`@product.pictures`来获取照片.

如果你有`Picture`这个model的一个实例的话, 则你可以通过`@picture.imageable`来访问到它的parent. 为了让其起作用, 你需要同时为model声明一个外键字段和一个类型字段以用来表示是多态的接口

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```

这个migration可以用`t.references`简化

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end

# t.references, ploymorphic: true 会自动给表加上imageable_id imageable_type 2个字段
```

#### 2.10 Self Joins

在设计一个model的时候, 有时你可能会发现你需要关联到model自身. 举个例子, 你可能想要在一个单一的数据库model里存储所有的雇员信息, 但是又希望能区分它们为经理或者普通员工. 这种情况可以通过`self-joining`关系来解决

```ruby
class Employee < ApplicationRecord
  has_many :subordinates, class_name: 'Employee', foreign_key: 'manager_id'
  belongs_to :manager, class_name: 'Employee', optional: true
end
```

通过这样的设置, 你可以通过`@employee.subordinates`, `@employee.manager`来获取不同的对象.

在migrations里, 你需要加入一个引用字段给到model自身

```ruby
class CreateEmployees < ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      t.references :manager, foreign_key: { to_table: :employees }
      t.timestamps
    end
  end
end
```

### 3. 技巧与警告

这里有些准则你需要遵守以有效使用关联关系

- 控制缓存
- 避免名称冲突
- 更新schema
- 控制关联关系的范围(scope)
- 双向关系

#### 3.1 控制缓存

所有关联关系的方法都是基于缓存来完成的, 它们会缓存最为常用的查询结果来完成复杂的操作. 缓存是跨方法的, 比如

```ruby
author.books.load

# 会使用上面的缓存
author.books.size
# 会使用上面的缓存
author.books.empty?
```

但是如果你想重新加载缓存的话应该怎么做? 调用`reload`来刷新缓存

```ruby
author.books.load
author.books.size
# 重新从数据库加载最新的数据
author.books.reload.empty?
```

#### 3.2 避免命名冲突

不要使用已经被`ActiveRecord::Base`所占用的名称. 关联关系的方法会覆盖继承的父类的方法.比如`attributes`,`connection`都是错误的命名

#### 3.3 更新Schema

关联关系非常的有用, 你有必要维护整个数据库schema的正确以确保匹配你的关联关系. 在实践中, 你需要做以下2件事. 

1. 对于`belongs_to`的关联关系, 你应该创建外键.

当你声明`belongs_to`关系时, 你需要创建合理的外键. 举个例子

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

这个声明需要在books表里有合适的外键字段. 如果此时是一张新表, 则migration应该如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```

如果是既存的表, 则migration应该如下

```ruby
class AddAuthorToBooks < ActiveRecord::Migration[7.0]
  def change
    add_reference :books, :author
  end
end
```

注意: 如果你要确保数据库层面的引用关系完整, 请在上面的例子里加上`foreign_key: true`配置项给到`reference`字段


2. 对于`has_and_belongs_to_many`的关联关系, 你应该创建合适的join表.

如果你是通过`has_and_belongs_to_many`关联关系创建的, 则你需要显式的创建join表. 除非你写了`:join_table`配置项. ActiveRecord会自动按照词法优先级来创建表名, 比如`authors, books`两张表的join表会自动为`authors_books`, 因为`a`在`b`的前面.

注意: 前面的models的名称使用的是`String`的`<=>`操作符来计算的. 也就意味着如果字符串长度不一样, 则较长的字符串会被认为有较高的词法优先级. 举个例子, 表`paper_boxes`和`papers`结合生成的join表名会为`paper_boxes_papers`, 因为下划线`_`在词法上低于`s`.

无论名字是啥, 你都必须手动创建join table, 举个例子

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

上述例子需要`assemblies_parts`这个join表来支撑才能完成关联关系. 这张表不应该拥有主键

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```

我们传递了`id: false`在`create_table`的时候, 因为这张join表不需要表现为一个model. 如果你在`has_and_belongs_to_many`的关系上看到了任何奇怪的行为或者id冲突等问题, 很有可能是因为你可能忘了取消主键导致的.

你也可以使用`create_join_table`方法

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```

#### 3.4 控制关联关系的范围(scope)

默认情况下, 关联关系仅会限制在当前的module的范围内, 举个例子

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

上述例子会正常工作, 因为`Supplier`和`Account`这2个类都定义在了相同的作用域里. 但是下面的例子就不行了, 因为它们定义在了不同的作用域里

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

为了关联不同命名空间的model, 你需要完整的声明类名

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```

#### 3.5 双向关系

声明双向关系是必须且普遍的事情

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```

Active Record会尝试基于关联关系的名称,来自动识别这2个models的双向关系,如下

```ruby
a = Author.first
b = a.books.first
a.first_name == b.author.first_name
a.first_name = 'David'
a.first_name == b.author.first_name
```

Active Record支持自动识别大多数的标准名称. 但是, Active Record不能自动识别带`:through`或者`:foreign_key`配置项的双向关系. 此外自定义作用域的也没法自动识别, 除非

`config.active_record.automatic_scope_inversing` = true 这个项目配置被设定.默认是开启的.

举个例子

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

Active Record此时不会自动识别双边关系.

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

为此, Active Record提供了`:inverse_of`配置项来帮助你显式的声明双向关系.

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

通过加入`:inverse_of`配置项到`has_many`关系声明, Active Record则可以识别双向关系

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

### 4. 关联关系引用细节

下面的章节给出了每种关联关系的细节, 包括它们会提供的方法和可以用到的配置项.

#### 4.1 belongs_to 关联关系引用

从数据库的角度来说的话, `belongs_to`的关联关系表达了这个model的表会有一个字段, 该字段用于和其他的表做引用连接. `belongs_to`可以用在一对多,也可以用在一对一的关系上. 如果是一对一的关系, 则应该用`has_one`.

##### 4.1.1 belongs_to增加的方法

当你声明一个`belongs_to`关联关系的时候, 声明的类会自动追加8个方法. 分别如下

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association
- association_changed?
- association_previously_changed?

所有上述的方法, `association`文字描述的位置都要以`belongs_to`的第一个参数的Symbol来替换.比如

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

此时,每一个`Book`的model的实例, 都会有如下的方法

```sh
author
author=
build_author
create_author
create_author!
reload_author
author_changed?
author_previously_changed?
```

当初始化一个新的`has_one`或者`belongs_to`关联关系的时候, 你必须使用`build_`前缀来创建关联关系, 而对于`association.build`方法来说, 它更适合用在`has_many`或`has_and_belongs_to_many`关联关系上.如果是`create`,则应该使用`create_`前缀.

###### 4.1.1.1 association

`association`方法会返回存在的所有关联对象. 如果没有找到关联对象, 则返回`nil`

```ruby
@author = @book.author
```

如果关联的对象已经从数据库里被加载, 则第二次要的时候会返回缓存的版本. 为了覆盖这一行为(即强制重新从数据库加载), 可以调用父对象的`reload_association`方法来完成.

再次提醒, 这里的`reload_association`,带下划线的这些方法, 都是给到一对一关系的.

```ruby
@author = @book.reload_author
```

###### 4.1.1.2 association=(associate)

`association=`方法可以将一个关联的对象赋值到这个对象上. 从原理上说, 这意味着提取出关联对象的主键, 并设定对象的外键为这个主键的值.

```ruby
@book.author = @author
```

###### 4.1.1.3 build_association(attributes = {})

`build_association`方法, 会返回关联关系类型的一个新的对象. 该对象会以传入的属性来进行实例化, 并且会设定好外键关系, 但是要注意此时**还没有**被持久化到数据库.

```ruby
@author = @book.build_author(author_number: 123, author_name: "zhangsan")
```

###### 4.1.1.4 create_association(attributes = {})

`create_association`方法和上面的方法一样, 但是会触发model的校验逻辑, 并且如果校验通过,则**会自动**持久化到数据库里.

###### 4.1.1.5 create_association!(attributes = {})

和上面的4.1.1.4的方法一摸一样, 但是在创建对象失败时(invalid)会抛出`ActiveRecord::RecordInvalid`的异常.

###### 4.1.1.6 association_changed?

`association_changed?`方法用于确认关联对象是否在未持久化到数据库时发生了改变. 如果持久化了, 则返回false, 如果没持久化但是发生了改变, 则返回true.

```ruby
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.author_changed? # => true

@book.save!
@book.author_changed? # => false
```

###### 4.1.1.7 association_previously_changed?

`association_previously_changed?`方法会在关联对象发生过变化时返回true

```ruby
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_previously_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.save!
@book.author_previously_changed? # => true
```

##### 4.1.2 Options for belongs_to

Rails在大多数情况下都能自动处理好双边关系, 但是如果需要自定义`belongs_to`关系的引用行为的话, 则需要使用配置项. 举个例子

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at, counter_cache: true
end
```

`belongs_to`关联关系支持如下配置项目

- :autosave
- :class_name
- :counter_cache
- :dependent
- :foreign_key
- :primary_key
- :inverse_of
- :polymorphic
- :touch
- :validate
- :optional

###### 4.1.2.1 :autosave

如果你设定了`autosave: true`, 则Rails会自动在父对象发生`save`保存的时候,自动保存与删除关联对象. 设定`autosave: false` 并不等价于不设定`:autosave`配置项, 如果`:autosave`配置项没有被用到, 那么新的关联关系对象将会被保存到数据库, 但是更新的关联关系对象则不会被自动保存到数据库.

###### 4.1.2.2 :class_name

如果另一个model的名字不能直接通过association的名字来自动获取的话, 你可以使用`:class_name`配置项来提供一个类名. 举个例子, 假如一本书属于一个作者, 但是作者的类叫做Patron, 则你可以如下设定.

```ruby
class Book < ApplicationRecord
  belongs_to :author, class_name: 'Patron'
end
```

###### 4.1.2.3 :counter_cache

`:counter_cache`配置项可以被用在高效的查找所拥有对象的数量上. 考虑如下models

```ruby
class Book < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :books
end
```

通过上述的声明, 可以通过`@author.books.size`来调用数据库的`COUNT(*)`查询API. 为了避免反复调用数据库查询, 你可以添加计数器的缓存到所拥有的model里

```ruby
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end

class Author < ApplicationRecord
  has_many :books
end
```

通过上述声明, Rails会启用缓存机制来保存`size`方法的查询结果.

尽管`:counter_cache`配置项是被用在`belongs_to`的声明上的, 但是要注意它所对应的关联关系必须是`has_many`的model才可以. 在上面的例子里, 你可能会需要添加一个字段叫做`books_count`到`Author`这个model里.

你可以通过声明一个字段名称来替换掉`counter_cache: true`里的`true`选项以保存结果到这个字段里. 举个例子, 使用`count_of_books`来代替使用`books_count`

```ruby
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end

class Author < ApplicationRecord
  has_many :books
end
```

注意: 你仅需要在`belongs_to`这边的model上添加`counter_cache`配置项.

Counter cache 字段会以只读属性(attr_readonly)被添加到所属的model的属性里.

###### 4.1.2.4 :dependent

如果你设定了`:dependent`配置项

- `:destroy`, 当对象被`destroyed`的时候, 则其关联的对象就会自动执行其`destroy`方法
- `:delete`, 当对象被`destroyed`的时候, 则其关联的对象会直接从数据库里删除, 而不会调用`destroy`方法去删除.
- `:destroy_async`, 当对象被`destroyed`的时候, 一个`ActiveRecord::DestroyAssociationAsyncJob`的job会被自动加入到队列里,Active Job必须开启才能使用.

注意: 你不应该设定`belongs_to`关系给到其他还带了`has_many`关系的model里, 这样的话会导致`orphaned`记录的出现. 举个例子, A -> B 可以级联删除, 但是 A -> B -> C, 是没法删除到C的.

###### 4.1.2.5 :foreign_key

出于便利, Rails会假定默认外键字段名称为`association_id`. 而`:foreign_key`配置项允许你直接配置外键的名称.

```ruby
class Book < ApplicationRecord
  belongs_to :author, foreign_key: "patron_id", class_name: "Patron"
end
```

注意: 在任何情况下, Rails都不会主动给你创建外键字段, 这些外键字段的创建你都必须自己在migrations里显式加上数据库里才会有.

###### 4.1.2.6 :primary_key

默认情况下, Rails会假设`id`字段会被当作表的主键, 而`:primary_key`配置项则允许你使用其他的字段来定义为主键.

举个例子, 假设我们拥有一个`users`表, 其主键字段为`guid`, 如果我们想要一个其他的表来关联这个自定义的主键的话, 我们可以使用`primary_key`来向如下一样达到需求.

```ruby
class User < ApplicationRecord
  self.primary_key = 'guid' # 设定该model的主键为guid, 而不是user_id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```

当我们执行`@user.todos.create`时, `@todo`记录将会从默认的`user_id`改为`guid`的值

###### 4.1.2.7 :inverse_of

`:inverse_of`配置项详细说明了`has_many`或者`has_one`关系的`name`是`inverse_of`的反转. 只有配了这个反转, 才可以反向获取关联对象.

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

###### 4.1.2.8 :polymorphic

传递`true`给到`:polymorphic`配置项表明这是一个多态的关联关系. 请参照之前对多态的描述.

###### 4.1.2.9 :touch

如果你设定了`:touch`配置项为`true`, 则关联对象的`updated_at`或者`updated_on`时间戳字段会被修改成当前时间, 无论这条记录是更新还是删除.

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
```

在这个场景下, 保存或者删除一本书都将会更新关联作者的时间戳, 你也可以指定一个自定义的时间戳属性来更新

```ruby
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```

###### 4.1.2.10 :validate

如果你设定`:validate`配置项为`true`, 则无论在任何时候, 当你尝试`save`对象时, 都会触发校验逻辑. 默认情况下为`false`,即当新的关联对象被保存时,这些新的关联对象不会走它们的校验逻辑.

###### 4.1.2.11 :optional

如果你设定`:optional`配置项为`true`时, 则关联对象是否存在将不会被校验. 默认情况下, 这个配置项是设定为`false`的.(即设定了该配置项,则关联对象可以为nil)

##### 4.1.3 belongs_to的作用范围

你偶尔可能需要自定义你的`belongs_to`的关联关系的查询方式, 以自定义需要返回的内容, 你可以如下例子一样进行操作

```ruby
class Book < ApplicationRecord
  belongs_to :author, -> { where(active: true) }
end
```

你可以在scope的代码块里使用任何方式的查询方法, 下面是常用的一些

- where
- includes
- readonly
- select

###### 4.1.3.1 where

`where`方法能让你声明关联对象必须要满足的条件

```ruby
class Book < ApplicationRecord
  belongs_to :author, -> { where(active: true) }
end
```

###### 4.1.3.2 includes

你可以使用`includes`方法来声明那些, 当使用关联对象时, 那些需要被急切加载的二阶关联对象.举个例子, 考虑如下这些models

```ruby
class Chapter < ApplicationRecord
  belongs_to :book
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```

如果你经常从`chapters`来直接获取`authors`(@chapter.book.author), 那么你可以通过往`Chapter`类里`includes`另外的`Author`类来提升查询效率.

```ruby
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```

注意: 对于直接的关联关系而言, 你不必使用`includes`, 也就是说, 如果你有`Book belongs_to :author`的话, 那么`author`会在需要时自动急切加载(eager-loaded)

###### 4.1.3.3 readonly

如果你使用了`readonly`, 那么关联对象将会在被提取使用时变成只读的.

###### 4.1.3.4 select

`select`方法能让你覆盖`SELECT`的SQL语法, 默认情况下, Rails会返回所有的字段(即默认为 select *, 而当启用此配置时可自定返回的字段)

注意: 如果你在一个`belongs_to`关联关系上使用了`select`方法, 那么你应该设定`:foreign_key`选项以确保能获取到正确的结果.

##### 4.1.4 判断关联对象是否存在.

你可以通过使用`association.nil?`来确认是否关联对象存在.

```ruby
def test
  if @book.author.nil?
    @msg = "No author"
  end
end
```

##### 4.1.5 什么时候对象会被保存(saved)

赋予一个对象到`belongs_to`的关联对象上并不会自动保存. 同样也不会保存其他关联对象.

#### 4.2 has_one 关联关系引用

`has_one`关联关系会创建一个一对一的关系, 从数据库角度来说, 这个关联关系表示另外一个类会包含外键, 如果这个类已经包含了外键, 那么你应该使用`belongs_to`来代替.(即belongs_to写在哪里, 就有那个外键.)

##### 4.2.1 has_one 添加上的方法

如下方法会通过声明`has_one`关系来自动添加

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association

所有这东西的方法, `association`字符串都需要被`has_one`所标注使用的Symbol来代替, 举个例子

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

每一个`Supplier`这个model的实例都应该有如下这些方法

```ruby
account
account=
build_account
create_account
create_account!
reload_account
```

当实例化一个新的`has_one`或者`belongs_to`关系时, 你必须使用`build_`前缀来`build`一个关联关系, 而`association.build`方法只适用于`has_many`或者`has_and_belongs_to_many`关联关系. 如果要`create`一个, 则应该使用`create_`前缀.

###### 4.2.1.1 association

`association`方法会返回关联的对象, 如果没有找人任何关联对象, 则返回`nil`

```ruby
@account = @supplier.account
```

如果关联对象已经被从数据库里取出, 则会返回缓存的版本, 为了覆盖缓存, 可以调用`reload_association`来覆盖

```ruby
@account = @supplier.reload_account
```

###### 4.2.1.2 association=(associate)

`association=`方法为赋值方法, 重新赋值意味着提取之前的对象的外键, 并设定关联对象的外键为相同的值.

```ruby
@supplier.account = @account
```

###### 4.2.1.3 build_association(attributes = {})

`build_association`方法会返回一个关联对象类型的新对象, 这个对象会通过传入的参数来进行实例化, 并且外键约束也会准备好, 但是此时这个对象还不会真实存入到数据库里.

```ruby
@account = @supplier.build_account(terms: "ok 3o")
```

###### 4.2.1.4 create_association(attributes = {})

`create_association`是上面方法的保存版本, 在创建后会直接存入到数据库里.

```ruby
@account = @supplier.create_account(terms: "ok 30")
```

###### 4.2.1.5 create_association!(attributes = {})

上述方法的异常抛出版, 在创建的记录无效时会抛出`ActiveRecord::RecordInvalid`

###### 4.2.2 has_one的配置项

用于自定义关联关系的引用, 比如

```ruby
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing", dependent: :nullify
end
```

常用配置如下

- :as
- :autosave
- :class_name
- :dependent
- :foreign_key
- :inverse_of
- :primary_key
- :source
- :source_type
- :through
- :touch
- :validate

###### 4.2.2.1 :as

设定`:as`配置项, 意味着这是一个多态关联关系, 可以参考之前关于多态的描述

###### 4.2.2.2 :autosave

如果你设定`:autosave`配置项为`true`, 则Rails会自动保存/删除对应的关联关系对象. 设定`:autosave`为`false`并不等价于没设定`:autosave`配置项, 如果`:autosave`配置项不存在, 那么创建新的关联对象的动作将会被自动保存, 但是更新关联对象的操作不会自动保存.

###### 4.2.2.3 :class_name

如果其他model的名称不能直接从关联关系上推出来, 则可以使用`:class_name`配置项来直接指定model的名称. 举个例子, 如果一个供应商拥有一个账号, 但是实际的model的名称叫做`Billing`, 则可以如下

```ruby
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing"
end
```

###### 4.2.2.4 :dependent

用于控制关联对象的父对象被删除时要做些啥的设定.

- :destroy, 会导致关联对象同时被删除, 会触发删除回调
- :delete, 会直接从数据库删除关联对象, 会跳过删除回调
- :destroy_async, 当父对象被删除时, 会增加一个`ActiveJob::DestroyAssociationAsyncJob`的job排队来异步删除, 需要提前开启Active Job.
- :nullify, 允许设定外键为`NULL`, 多态类型的字段在多态关系下同样也允许空值. 此时回调不回执行.
- :restric_with_exception, 会抛出`ActiveRecord::DeleteRestrictionError`这个异常, 如果是一个关联对象的话.
- :restrict_with_error, 会添加一个error给到父对象, 如果是一个关联对象的话.

对于那些在数据库里存在`NOT NULL`约束条件的记录而言, 不要设定`:nullify`配置项给那些关联对象是非常有必要的. 如果你不设定`dependent`配置项来删除这些关联记录的话, 你将不能再去改变这些关联对象, 因为它们的外键将会被设定为不允许的`NULL`值.

###### 4.2.2.5 :foreign_key

Rails会自动设定外键的字段为关联model名前缀 + `_id`. `:foreign_key`配置项允许你直接设定外键

```ruby
class Supplier < ApplicationRecord
  has_one :account, foreign_key: "supp_id"
end
```

注意: 任何情况下, Rails都不会帮你创建外键字段, 你需要显式的在migrations里声明外键.

###### 4.2.2.6 :inverse_of

`:inverse_of`配置项会声明`belongs_to`关联关系的名称为其逆向, 这个配置项要用了, 才能从子关联对象上.点到父对象上来.

```ruby
class Supplier < ApplicationRecord
  has_one :account, inverse_of: :supplier
end

class Account < ApplicationRecord
  belongs_to :supplier, inverse_of: :account
end

# 这样定义了, 才能使用 @supplier.account, @account.supplier来相互获取
```

###### 4.2.2.7 :primary_key

为了方面, Rails会自动使用`id`为主键, 可以通过这个配置项来覆盖Model的主键字段名

###### 4.2.2.8 :source

`:source`配置项声明了`has_one :through`关联对象的源关联对象名.

###### 4.2.2.9 :source_type

`:source_type`配置项声明了`has_one :through`多态关联对象的源关联对象类型

```ruby
class Author < ApplicationRecord
  has_one :book
  has_one :hardback, through: :book, source: :format, source_type: "Hardback"
  has_one :dust_jacket, through: :hardback
end

class Book < ApplicationRecord
  belongs_to :format, polymorphic: true
end

class Paperback < ApplicationRecord; end

class Hardback < ApplicationRecord
  has_one :dust_jacket
end

class DustJacket < ApplicationRecord; end
```

###### 4.2.2.10 :through

`:through`配置项用于声明一个联合(join)model, 通过这个联合的model来进行查询. `has_one :through`关联对象的讨论参考前面的内容.

###### 4.2.2.11 :touch

如果你设定了`:touch`配置项为`true`, 则当父对象进行增删操作时, 关联对象上的`updated_at`或者`updated_on`时间戳字段会被设定为当前时间

```ruby
class Supplier < ApplicationRecord
  has_one :account, touch: true
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```

在这种情况下, 保存或者删除一个`supplier`都将更新关联账号的时间戳字段, 你也可以手动指定需要更新的字段是哪个

```ruby
class Supplier < ApplicationRecord
  has_one :account, touch: :suppliers_updated_at
end
```

###### 4.2.2.12 :validate

如果你设定`:validate`配置为`true`的话, 则无论任何时候保存父对象, 其新的关联对象都会被进行校验. 默认情况下, `:validate`是设定为`false`的, 即当父对象保存时(saved), 新的关联对象将不会被自动校验.

##### 4.2.3 has_one的作用范围

可以通过传入lambda的形式来设定`has_one`关联对象需要被返回的属性范围有哪些

```ruby
class Supplier < ApplicationRecord
  has_one :account, -> { where(active: true) }
end
```

你可以在代码块里使用任何标准的查询方法,比如如下

- where
- includes
- readonly
- select

###### 4.2.3.1 where

`where`方法能让你指定查询的对象所需要满足的条件

```ruby
class Supplier < ApplicationRecord
  has_one :account, -> { where("confirm = 1") }
end
```

###### 4.2.3.2 includes

`includes`方法用来声明那些应该被`eager-loaded`的二阶关联对象, 当关联对象被使用时. 举个例子

```ruby
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```

在这个例子里, 假如你经常直接从`suppliers`去获取`representatives`(@supplier.account.representative), 则你可以在`suppliers`里,通过从`accounts`里`includes representatives`来提升你的代码运行效率.

换句话说, 只要碰到这种跳跃到第三个model进行查询, 并且第三个model和第二个model是一对多的情况的话, 为了避免`N+1`查询问题, 一定要设定`includes`, rails底层会更改为先查出全部数据, 再一次性取回需要的数据. 而如果不设定`includes`的话, 则是查一条给一条查一条给一条,再返回全部所需的数据(即N+1查询问题)

```ruby
class Supplier < ApplicationRecord
  has_one :account, -> { includes :representative }
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```

###### 4.2.3.3 readonly

如果你使用`readonly`方法的话, 则查出来的关联对象的属性将会被设定为只读.

###### 4.2.3.4 select

`select`方法能让你覆盖默认的SQL的`SELECT`查询语句, 默认情况下, Rails会返回所有的字段.

##### 4.2.4 判断关联对象是否存在

你可以使用`association.nil`方法来判断关联对象是否存在

```ruby
if @supplier.account.nil?
  @msg = "No Account"
end
```

##### 4.2.5 对象什么时候保存到数据库

当你赋给一个`has_one`关联对象赋值时,  关联对象会自动保存(为了更新外键). 此外, 任何被替换的对象也都会自动被保存, 因为外键也发生了变化.

如果由于校验错误而发生了任何保存失败的情况的话, 则赋值操作会返回`false`, 并且该操作会被取消

如果父对象(声明了`has_one`关联对象的那个)没有被保存的话(也就是说, `new_record?`会返回`true`), 则子对象也不会被保存. 它们将会自动在父对象保存时自动保存.

如果你想要给一个`has_one`关联对象赋值但是又不想保存其到数据库的话, 则可以使用`build_association`方法来实现.

#### 4.3 has_many 关联对象引用

`has_many`会与其他的model创建一个一对多的关系. 丛数据库层面来说, 这个关联关系表示其他的类将会拥有一个外键来引用到这个类的实例.

##### 4.3.1 has_many 带来的方法

下面17个方法是`has_many`关系带给model的大礼包

- collection
- collection<<(object, ...)
- collection.delete(object, ...)
- collection.destroy(object, ...)
- collection=(objects)
- collection_singular_ids
- collection_singular_ids=(ids)
- collection.clear
- collection.empty?
- collection.size
- collection.find(...)
- collection.where(...)
- collection.exists?(...)
- collection.build(attributes = {})
- collection.create(attributes = {})
- collection.create!(attributes = {})
- collection.reload

所有的上述方法, `collection`都需要被`has_many`的第一个Symbol参数给替换掉, `collection_singular`需要被Symbol的单数形式替换掉. 举个例子

```ruby
class Author < ApplicationRecord
  has_many :books
end
```

则每一个`Author`的model的实例都会有如下方法大礼包

```ruby
books
books<<(object, ...)
books.delete(object, ...)
books.destroy(object, ...)
books=(objects)
book_ids
book_ids=(ids)
books.clear
books.empty?
books.size
books.find(...)
books.where(...)
books.exists?(...)
books.build(attributes = {}, ...)
books.create(attributes = {})
books.create!(attributes = {})
books.reload
```

###### 4.3.1.1 collection

`collection`方法将会返回所有的关联对象的关系`Relation`. 如果没有关联对象, 则返回空的Relation

```ruby
@books = @author.books
# 没有则返回nil, 有则返回集合
```

###### 4.3.1.2 collection << (object, ...)

`collection<<`方法能够添加一到多个对象给到集合, 通过设定它们的外键为调用model的主键来完成.

```ruby
@author.books << @book1
```

###### 4.3.1.3 collection.delete(object, ...)

`collection.delete`方法会从集合中移除一到多个对象, 通过设定它们的外键为`NULL`, 这里不会从数据库里删除数据, 注意了.

```ruby
@author.books.delete(@book1)
```

注意: 如果你设定了`dependent: :destroy`, 则上述的`delete`会触发关联对象的`destroy`逻辑, 而如果设定的是`dependent: :delete_all`的话, 则会触发`delete`逻辑(直接从数据库删除,无回调).

###### 4.3.1.4 collection.destroy(object, ...)

`collection.destroy`方法会通过执行每个对象的`destroy`方法来从集合里移除一到多个对象.

```ruby
@author.books.destroy(@book1)
```

注意: 对象总会从数据库里移除, 并且会无视`:dependent`配置项的设定.

###### 4.3.1.5 collection=(objects)

`collection=`方法即重新赋值整个集合, 这个操作会被持久化到数据库里.

###### 4.3.1.6 collection_singular_ids

`collection_singular_ids`方法会返回一个对象ids的数组

```ruby
# 拿到所有属于这个作者的书籍的所有id组成的数组
@book_ids = @author.book_ids
```

###### 4.3.1.7 collection_singular_ids=(ids)

`collection_singular_ids=`方法会创建集合, 这个集合仅包含所提供的主键. 会持久化到数据库.

###### 4.3.1.8 collection.clear

`collection_clear`方法会通过`dependent`配置项所设定的内容, 来移除所有集合里的对象. 如果没有提供`option`的话, 则会使用默认策略. `has_many :through`关联关系的默认策略是`delete_all`, 对于`has_many`关联关系而言是设定它们的外键为`NULL` 

```ruby
@author.books.clear
```

注意: 如果设定关联关系为`dependent: :destroy`或者`dependent: :destroy_async`的话, 则对象就会被删除(指的是从数据库里), 和设定`dependent: :delete_all`一样

###### 4.3.1.9 collection.empty?

`collection.empty?`方法会返回`true`, 如果集合没有任何关联对象的话

```ruby
<% if @author.books.empty? %>
  No Books here
<% end %>
```

###### 4.3.1.10 collection.size

`collection.size`方法会返回集合的数量

```ruby
@book_count = @author.books.size
```

###### 4.3.1.11 collection.find(...)

`collection.find`方法会在集合的表里查找`id`符合输入值的对象. 只会匹配`id`字段.

```ruby
@user.articles.find(1)
# 此时返回一条记录, 查询条件为articles.id = 1

@user.articles.find(1,2,3)
# 此时返回一个数组, 查询条件为articles.id in (1,2,3)
```

###### 4.3.1.12 collection.where(...)

`collection.where`方法会查找基于条件的对象集合, 但是这些对象是懒加载的. 也就是说, 仅当这些对象可以被正常访问的时候,才会从数据库里去查询.

```ruby
@user.articles.where("id > 5")
@user.articles.where(title: "abc")
@available_books = @author.books.where(available: true) # No query yet
@available_book = @available_books.first # Now the database will be queried
```

###### 4.3.1.13 collection.exists?(...)

`collection.exists?`方法会检查条件所描述的对象是否在数据库里有记录

```ruby
@user.articles.exists?(id: 1) # true
 @user.articles.exists?(id: 100) # false
```

###### 4.3.1.14 collection.build(attributes = {})

`collection.build`方法会返回一个单数或者关联对象类型的数组. 数组里的对象会通过传入的参数进行实例化, 外键此时会被创建, 但是还不会被保存到数据库里

```ruby
@book = @author.books.build(published_at: Time.now,
                            book_number: "A12345")

@books = @author.books.build([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }
])
```

###### 4.3.1.15 collection.create(attributes = {})

`collection.create`方法是上面方法的保存到数据库版本, 会触发校验逻辑

```ruby
@book = @author.books.create(published_at: Time.now,
                             book_number: "A12345")

@books = @author.books.create([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }
])
```

###### 4.3.1.16 collection.create!(attributes = {})

上述版本的报错版, 当校验失败时会抛出`ActiveRecord::RecordInvalid`异常

###### 4.3.1.17 collection.reload

重新加载关联对象的Relation, 强制数据库再次进行读操作. 如果没有关联对象, 则返回空的`Relation`

```ruby
@books = @author.books.reload
```

##### 4.3.2 has_many的配置项

和之前的内容一样, Rails足够智能去自动配置关联对象, 但是只要有自定义化的需求, 就需要把目光转向这些options来实现. 比如

```ruby
class Author < ApplicationRecord
  has_many :books, dependent: :delete_all, validate: false
end
```

`has_many`关联对象支持如下配置

- :as
- :autosave
- :class_name
- :counter_cache
- :dependent
- :foreign_key
- :inverse_of
- :primary_key
- :source
- :source_type
- :through
- :validate

###### 4.3.2.1 :as

设定`:as`选项的话, 表示这是一个多态的关联关系, 用于引用多态的"接口",参照之前多态的内容.

###### 4.3.2.2 :autosave

如果你设定了`:autosave`为`true`, 和之前的内容一样, 则当父对象保存删除时,子对象会自动保存.设定`:autosave`为`false`并不等价于不设定`:autosave`, 如果没有配置`:autosave`选项的话, 则新的关联对象将会被保存, 但是更新操作不会.

###### 4.3.2.3 :class_name

即自定义配置关联对象的类名, 而不是靠Rails自动推断

```ruby
class Author < ApplicationRecord
  has_many :books, class_name: "Transaction"
end
```

###### 4.3.2.4 :counter_cache

该配置项可以被用在配置自定义的`:counter_cache`字段名上, 你仅需要在当你在`belongs_to`关系上自定义了`:counter_cache`时,会用到这个配置项.

###### 4.3.2.5 :dependent

这个配置项会做什么, 会按下面的内容进行区分

- :destroy, destroy所有关联对象
- :delete_all, 直接从数据库里删除所有关联对象(回调将不会执行)
- :destroy_async, 当对象被destroy时, 会插入`ActiveRecord::DestroyAssociationAsyncJob`的job来异步处理删除关联对象, Active Job必须要提前设定
- :nullify, 设定外键为`NULL`, 多态类型的字段同样也会被`NULL`化在多态关系上, 不会触发回调.
- :restrict_with_exception, 如果存在任何关联记录, 则抛出`ActiveRecord::DeleteRestrictionError`
- :restrict_with_error, 如果存在任何关联记录, 则添加一个error到所属的owner里.

`:destroy`与`:delete_all`配置项也会影响`collection.delete`与`collectiono=`方法对删除关联对象的执行方式.

###### 4.3.2.6 :foreign_key

默认情况下, Rails会默认假定使用外键名称为关联对象model的名字作为前缀加上`_id`. `:foreign_key`配置允许你直接配置外键字段

```ruby
class Author < ApplicationRecord
  has_many :books, foreign_key: "cust_id"
end
# 默认外键是books_id
```

注意: 任何情况下, Rails都不会主动给你创建外键字段, 你需要在migrations里主动定义来完成数据库的外键添加.

###### 4.3.2.7 :inverse_of

`:inverse_of`选项声明关联对象的反向对象, 所以一般都是写model自己的name

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

###### 4.3.2.8 :primary_key

出于方便, Rails假设用于维持关联对象的主键字段为`id`(也就是关联对象的外键字段为id), 你可以使用`:primary_key`配置来覆盖这个默认行为. 

比如`users`表有`id`字段作为主键, 但是它同时还有一个`guid`字段. 此时需求是让`todos`这张表应该用`guid`字段的值来作为外键, 而不是`id`字段的值, 此时可以如下实现

```ruby
class User < ApplicationRecord
  has_many :todos, primary_key: :guid
end
```

现在如果我们执行`@todo = @user.todos.create`的话,则`@todo`记录的`user_id`的值会变成`@user`对象的`guid`字段的值

这里注意了: `primary_key`配置并不会修改User表的主键为`primary_key`, User表的主键id还是id, 这个配置只会修改关联关系默认所使用的外键的值, 在上面的例子里, 就是把`todo`的外键的值进行了修改, 对于todo这个类而言, 字段名称还是`user_id`, 但是值会改为`guid`的值.(只是改值,不是改名!)

###### 4.3.2.9 :source

`:source`选项用于声明`has_many :through`关联关系的源关联关系名. 你仅需要在源关系不能通过关联关系的名称自动推断的情况下使用这个配置.

###### 4.3.2.10 :source_type

`:source_type`选项用来声明`has_many :through`关联关系的源关系类型. 源关系为多态关系.

```ruby
class Author < ApplicationRecord
  has_many :books
  has_many :paperbacks, through: :books, source: :format, source_type: "Paperback"
end

class Book < ApplicationRecord
  belongs_to :format, polymorphic: true
end

class Hardback < ApplicationRecord; end
class Paperback < ApplicationRecord; end
```

###### 4.3.2.11 :through

`:through`选项声明一个join的model专门用来做查询. `has_many :through`关联关系提供了一个建立多对多关系的途径, 可以参照上面的内容.

###### 4.3.2.12 :validate

如果你设定了`:validate`选项为`false, 则当你保存对象时, 新的关联对象不会被校验. 默认情况下, 这个配置为`true`, 即新的关联对象都会默认被校验

##### 4.3.3 has_many的作用域

如果需要自定义关联对象返回的条件的话, 如下, 默认情况下是全量返回的.

```ruby
class Author < ApplicationRecord
 has_many :books, -> { where(processed: true) }
end
```

你可以在代码块里使用如下的标准查询方法

- where
- extending
- group
- includes
- limit
- offset
- order
- readonly
- select
- distinct

###### 4.3.3.1 where

where方法允许你声明记录必须符合的条件

```ruby
class Author < ApplicationRecord
  has_many :confirmed_books, -> { where("confirmed = 1") }, class_name: "Book"
end
```

你也同样可以通过一个哈希来设定记录需要满足的条件

```ruby
class Author < ApplicationRecord
  has_many :confirmed_books, -> { where(confirmed: true) }, class_name: "Book"
end
```

如果你使用的是hash模式的`where`配置的话, 则关联记录在创建时会自动使用哈希的设定来进行创建.比如, 使用`@author.confirmed_books.create`或者`@author.confirmed_books.build`创建的记录的`confirmed`字段的值将会被默认调整为`true`

###### 4.3.3.2 extending

`extending`方法声明了一个具名的module来扩展关联代理. 关联对象扩展会在后面讨论

###### 4.3.3.3 group

`group`方法提供了一个属性来分组结果, 它在SQL里会变成`GROUP_BY`语句.

```ruby
class Author < ApplicationRecord
  has_many :chapters, -> { group("books.id") }, through: :books
end
```

###### 4.3.3.4 includes

你可以使用`includes`方法来声明那些需要被`eagerloaded`的二阶关联关系. 举个例子

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```

此时如果你经常通过`@author.books.chapters`这样间接的形式来获取到第三个model的对象的内容的话, 那么如下使用`includes(:chapters)`的形式能显著提高查询效率.

```ruby
class Author < ApplicationRecord
  has_many :books, -> { includes :chapters }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```

###### 4.3.3.5 limit

`limit`方法能让你限制查询对象返回的记录总数

```ruby
class Author < ApplicationRecord
  has_many :recent_books, -> { order('published_at desc').limit(100) }, class_name: "Book"
end
```

###### 4.3.3.6 offset

`offset`方法能让你声明查询时偏移的量, 举个例子, `-> {offset(11)}`, 意味着查询时将会跳过前11条记录

###### 4.3.3.7 order

`order`方法用于调整查询返回的记录的排序, 其对应SQL的`ORDER BY`子句

```ruby
class Author < ApplicationRecord
  has_many :books, -> { order("date_confirmed desc") }
end
```

###### 4.3.3.8 readonly

`readonly`方法会将查询返回的值调整为只读

###### 4.3.3.9 select

覆盖默认返回所有字段的`SELECT`语法, 指定需要返回的字段.

注意: 如果你声明了自己的`select`, 那么请确保关联对象的主键和外键字段都被包括了. 如果你没选它们, Rails会抛出错误.

###### 4.3.3.10 distinct

可以使用`distinct`方法来给查询返回的集合做去重操作, 经常配合`:through`配置一起使用

```ruby
class Person < ApplicationRecord
  has_many :readings
  has_many :articles, through: :readings
end

person = Person.create(name: 'John')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.to_a
# [#<Article id: 5, name: "a1">, #<Article id: 5, name: "a1">]
Reading.all.to_a
# [#<Reading id: 12, person_id: 5, article_id: 5>, #<Reading id: 13, person_id: 5, article_id: 5>]
```

如上面的例子, 重复加入collection会发生记录重复的情况. 此时如果使用`distinct`

```ruby
class Person
  has_many :readings
  has_many :articles, -> { distinct }, through: :readings
end

person = Person.create(name: 'Honda')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.to_a
# [#<Article id: 7, name: "a1">]
Reading.all.to_a
# [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]
```

上面的例子我们可以发现`-> {distinct}`确实给关联的集合做了去重操作.

如果你想要确认的话, 在插入记录时, 所有插入到数据库的记录都会是`distinct`的, 因此可以确保你在使用关联关系的时候永远不会找到一条重复的记录. 你应该添加一个唯一索引给到这张表. 举个例子, 如果你有一个表叫做`readings`,并且你想要确保`article`仅可以被添加到`person`一次, 那么你可以执行如下的migration

```ruby
add_index :readings, [:person_id, :article_id], unique: true
```

一旦你设定了这个唯一索引, 则所有尝试添加`article`到一个`person`的两次操作会抛出一个`ActiveRecord::RecordNotUnique`的error.

```ruby
person = Person.create(name: 'Honda')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article
# ActiveRecord::RecordNotUnique
```

请注意`includes?`方法会和distinct冲突. 请不要尝试使用`includes?`来强制唯一化关联关系. 举个例子, 使用上面的`article`的例子, 下面的代码由于多个`users`都会同时尝试去判断, 使得代码变得不再优雅, 并会增加无用的额外开销.

```ruby
person.articles << article unless person.articles.include?(article)
```

上述的内容表明, 如果要确保记录唯一的话, 最好的方式是使用`distinct`加上`表结构带上联合唯一索引`, 而不是通过`includes?`这种逻辑判断来确认关联关系的collection是否唯一.

##### 4.3.4 对象什么时候保存

当你赋值一个对象给到`has_many`关联关系时, 该对象就会自动保存到数据库(为了更新外键), 如果你在一个语句里赋值多个对象的话, 那么它们都会被`saved`

如果由于校验错误导致任何保存失败的话, 则赋值语句会返回`false`并且赋值操作本身回被取消掉.

如果父对象(即声明了`has_many`关联对象那个model)没有被保存(即`new_record?`返回了`true`), 那么它的子对象们在被添加时也不会被保存.所有没被保存的关联对象仅会在父类对象完成`saved`时才会自动`saved`

如果你想要赋值一个对象给到`has_many`关联关系的, 而不保存这个对象的话, 使用`collection.build`方法来完成.

#### 4.4 has_and_belongs_to_many 关系引用

`has_and_belongs_to_many`关系会创建多对多的关系. 在数据库层面, 2个类会通过一个中间的`join table`来完成沟通

##### 4.4.1 has_and_belongs_to_many 方法大礼包

下方是使用`has_and_belongs_to_many`时附赠的方法

- collection
- collection<<(object, ...)
- collection.delete(object, ...)
- collection.destroy(object, ...)
- collection=(objects)
- collection_singular_ids
- collection_singular_ids=(ids)
- collection.clear
- collection.empty?
- collection.size
- collection.find(...)
- collection.where(...)
- collection.exists?(...)
- collection.build(attributes = {})
- collection.create(attributes = {})
- collection.create!(attributees = {})
- collection.reload

上面所有方法的`collection`都需要替换为`has_and_belongs_to_many`的第一个参数的名称, `collection_singular`则需要替换为Symbol的单数版本, 比如

```ruby
class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

则其添加的方法如下

```ruby
assemblies
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies.destroy(object, ...)
assemblies=(objects)
assembly_ids
assembly_ids=(ids)
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.where(...)
assemblies.exists?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
assemblies.create!(attributes = {})
assemblies.reload
```

###### 4.4.1.1 额外字段方法

如果join table拥有超过了2个外键之外的别的字段的话, 那么这些字段都会作为属性可以被提取使用. 这些额外的字段的返回值永远都是只读的, 因为Rails不能保存任何新的改变给到这些额外的字段.

警告⚠️: 在join table里使用额外的属性已经`deprecated`. 如果你需要用到这个复杂的功能的话, 你应该使用`has_many :through`来代替使用`has_and_belongs_to_many`

###### 4.4.1.2 collection

`collection`方法会返回所有关联对象的`Relation`, 如果没有任何关联对象的话, 则返回空的`Relation`

```ruby
@assemblies = @part.assemblies
```

###### 4.4.1.3 collection << (object, ...)

`collection<<`方法能够通过在join table里创建记录的方式, 添加一到多个对象给到集合里

```ruby
@part.assemblies << @assembly1
```

注意: 这个方法是`collection.concat`合`collection.push`的一个别名

###### 4.4.1.4 collection.delete(object, ...)

`collection.delete`方法会从集合里移除一到多个对象, 通过删除join table里的记录. 这个方法不会删除对象, 只是解除关联关系.

```ruby
@part.assemblies.delete(@assembly1)
```

###### 4.4.1.5 collection.destroy(object, ...)

`collection.destroy`方法会通过删除join table里记录的方式来从集合里移除一到多个记录. 这个方式不会删除对象.

```ruby
@part.assemblies.destroy(@assembly1)
```

###### 4.4.1.6 collection=(objects)

`collection=`方法即赋值, 会替换之前的内容, 变化会持久化到数据库

###### 4.4.1.7 collection_singular_ids

`collection_singular_ids`方法会返回一个关联对象的ids组成的数组

```ruby
@assembly_ids = @part.assembly_ids
```

###### 4.4.1.8 collection_singular_ids=(ids)

`collection_singular_ids=`方法即赋值, 这些ids的变化会被持久化到数据库里.

###### 4.4.1.9 collection.clear

`collection.clear`方法会通过删除join table里记录的方式来移除集合里的所有对象. 不会删除关联对象.

###### 4.4.1.10 collection.empty?

`collection.empty?`方法会在集合不包含任何关联对象时返回true

```ruby
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
```

###### 4.4.1.11 collection.size

`collection.size`方法返回集合的大小

```ruby
@assembly_count = @part.assemblies.size
```

###### 4.4.1.12 collection.find(...)

`collection.find`方法会在集合的表里查找符合的对象

```ruby
@assembly = @part.assemblies.find(1)
```

###### 4.4.1.13 collection.where(...)

`collection.where`方法会查找符合条件的所有对象, 这些对象都是懒加载的, 仅当它们需要被真正访问时才会执行数据库查询.

```ruby
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
```

###### 4.4.1.14 collection.exists?(...)

该方法用来检查是否有对象符合所提供的条件

###### 4.4.1.15 collection.build(attributes = {})

该方法用来返回一个新的对象, 新对象的实例化通过传入的参数完成. 与join table的连接会被创建, 但是不会持久化保存.

```ruby
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
```

###### 4.4.1.16 collection.create(attributes = {})

上面方法会持久化保存的版本.

###### 4.4.1.17 collection.create!(attributes = {})

记录校验不通过时抛出`ActiveRecord::RecordInvalid`错误的报错版本

###### 4.4.1.18 collection.reload

用来返回所有关联对象的数组, 强制数据库重新刷新. 如果没有关联对象, 则返回空的Relation

```ruby
@assemblies = @part.assemblies.reload
```

##### 4.4.2 has_and_belongs_to_many的options大礼包

和其他的一样, 也是用来直接设定功能用的, 比如

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { readonly },
                                       autosave: true
end
```

提供如下选项

- :association_foreign_key
- :autosave
- :class_name
- :foreign_key
- :join_table
- :validate

###### 4.4.2.1 :association_foreign_key

默认情况下, Rails会假设join table用来做外键的字段为model的名字做前缀加上`_id`,而这个选项用于直接设定外键字段名称. 注意`:foreign_key`和`:association_foreign_key`配置项在设定定多对多的self-join的时候都是有用的, 举个例子

```ruby
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
```

###### 4.4.2.2 :autosave

如果你设定了`:autosave`为true, 则在保存或者删除父对象时会自动保存子对象. 设定`:autosave`为false`并不等价于不设定`:autosave`, 如果`:autosave`没有被设定, 则新创建的关联对象会被保存, 但是更新的关联对象则不会被保存.

###### 4.4.2.3 :class_name

用于直接设定要使用的model的名称, 举个例子

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end
```

###### 4.4.2.4 :foreign_key

为了方便, Rails会假设join table里用来维持外键的字段名是关联对象的名称前缀加上`_id`. `:foreign_key`配置允许你设定直接设定外键的名称

```ruby
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
```

###### 4.4.2.5 :join_table

如果默认的join table的名称不是你想要的, 那么你可以使用`:join_table`来直接覆盖默认的join table的名称.

###### 4.4.2.6 :validate

设定该配置为`false`, 则新的关联对象创建时将不会走校验逻辑. 默认情况下为true, 即所有新创建的关联对象都会在保存时走校验逻辑.

##### 4.4.3 has_and_belongs_to_many的作用域

例子

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { where active: true }
end
```

如下是能被用来做作用域限制的配置项

- where
- extending
- group
- includes
- limit
- offset
- order
- readonly
- select
- distinct

###### 4.4.3.1 where

用于限制需要满足的条件

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where "factory = 'Seattle'" }
end
```

也可以使用hash来做条件限制

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where factory: 'Seattle' }
end
```

和`has_many`一样, 使用hash模式的话, 则创建新的对象时,设定的哈希值会自动更新到新对象的属性值里

###### 4.4.3.2 extending

该方法用来声明一个具名模块以扩展关系代理, 详细见后面

###### 4.4.3.3. group

用于SQL的`GROUP BY`语句分组

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { group "factory" }
end
```

###### 4.4.3.4 includes

用于三个以上关系时, 二阶关系的`eager loaded`, 详细见前面的解释

###### 4.4.3.5 limit

用于限制查询返回的总数

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order("created_at DESC").limit(50) }
end
```

###### 4.4.3.6 offset

用于偏移查询位置, `offset(11)`, 则意味着跳过前面11条数据

###### 4.4.3.7 order

即`ORDER BY`子句

```ruby
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order "assembly_name ASC" }
end
```

###### 4.4.3.8 readonly

用于设定取出的关联关系为只读

###### 4.4.3.9 select

用于覆盖默认的`SELECT`语句, 默认是返回所有的字段.

###### 4.4.3.10 distinct

用于去重

##### 4.4.4 什么时候对象会被保存

单个赋值会自动保存, 一次多个赋值也会自动保存.

如果出现任何校验失败导致的保存失败, 则赋值会返回`false`并被取消

如果父对象(has_and_belongs_to_many关系的声明方)没被保存(即new_record?返回true), 则子对象添加时不会被保存. 所有没保存的关联对象都会在父对象保存时自动保存.

使用`collection.build`来实现非保存创建对象的功能.

#### 4.5 关联关系的回调

ActiveRecord对象的回调允许你在多个阶段执行方法, 举个例子, 你可以使用`:before_save`回调来在对象保存前做点啥.

关联关系的回调类似于普通的回调, 但是它们是看集合的生命周期来触发的. 以下4个是关联关系可以用的回调

- before_add
- after_add
- before_remove
- after_remove

回调和options一样, 添加到关联关系里

```ruby
class Author < ApplicationRecord
  has_many :books, before_add: :check_credit_limit

  def check_credit_limit(book)
    # ...
  end
end
```

Rails会自动执在对象删除或添加时执行回调.

你也可以通过传递数组的形式, 来依次执行多个回调

```ruby
class Author < ApplicationRecord
  has_many :books,
    before_add: [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(book)
    # ...
  end

  def calculate_shipping_charges(book)
    # ...
  end
end
```

如果`before_add`回调抛出了`:abort`, 则对象将不会被添加到集合里. 类似的, 如果`before_remove`回调抛出了`:abort`, 则对象不回从集合里被移除

```ruby
# book won't be added if the limit has been reached
def check_credit_limit(book)
  throw(:abort) if limit_reached?
end
```

注意: 这些回调仅当关联对象通过关联数组被添加或删除时才会起作用.

```ruby
# Triggers `before_add` callback
author.books << book
author.books = [book, book2]

# Does not trigger the `before_add` callback
book.update(author_id: 1)
```

#### 4.6 关联对象扩展

你可以通过扩展其他模块的方式来扩展自己想要的功能, Rails是通过代理对象的模式来实现控制的, 因此并没有对你做出任何限制. 举个例子

```ruby
class Author < ApplicationRecord
  has_many :books do
    def find_by_book_prefix(book_number)
      find_by(category_id: book_number[0..2])
    end
  end
end
```

如果你有扩展需要被很多其他的关联关系分享的话, 你可以使用具名的扩展模块, 比如

```ruby
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  end
end

class Author < ApplicationRecord
  has_many :books, -> { extending FindRecentExtension }
end

class Supplier < ApplicationRecord
  has_many :deliveries, -> { extending FindRecentExtension }
end
```

扩展可以通过下面`proxy_association`的3个属性来访问到代理对象的内部

- `proxy_association.owner`, 会返回关联对象所属的对象
- `proxy_association.reflection`, 会返回用于描述关联对象的反射
- `proxy_association.target`, 会返回`belongs_to`或者`has_one`的关联对象, 或者返回`has_many`或者`has_and_belongs_to_many`关联对象的集合.

### 5. 单表继承(STI)

有时, 你可能需要在2个不同的models之间分享字段与行为. 假设我们有`Car`, `Motocycle`, `Bicycle`这3个models. 我们想要分享`color`和`price`这2个字段和一些方法给到所有类, 但是它们又需要有自己独有的特征已经独立的控制器.

首先, 先来生成基本的`Vehicle`的model

```sh
bin/rails generate model vehicle type:string color:string price:decimal{10.2}
```

你注意到我们添加了一个`type`字段吗? 因为所有的models都会被保存在同一张数据库表里, Rails会将同字段的保存起来. 在这个例子里, 为Car.

**请注意:STI必须要在表里有`type`字段来通过继承的方式实现多个多态的models共用一张表**

接着, 我们生成Car来继承自Vehicle. 可以使用`--parent=PARENT`配置来设定脚手架生成的model继承自哪个类

```sh
bin/rails generate model car --parent=Vehicle
```

内容会如下
```ruby
class Car < Vehicle
end
```

这意味着所有添加到Vehicle的行为都会同时给Car来一份, 比如关联关系, 公共的方法等.

创建一个car将会保存到`vehicles`表里, 此时"Car"会自动作为type字段的值

```ruby
Car.create(color: 'Red', price: 10000)
```

SQL如下

```sql
INSERT INTO "vehicles" ("type", "color", "price") VALUES ('Car', 'Red', 10000)
```

查询car的记录将会搜索整个vehicles表

```ruby
Car.all
```

会执行如下SQL

```sql
SELECT "vehicles".* FROM "vehicles" WHERE "vehicles"."type" IN ('Car')
```

