## ActiveRecord Associations

### 0. 大纲

- 理解如何在ActiveRecord的Models之间声明事务
- 理解ActiveRecord的Associations的types
- 理解如何通过创建Associations来使用models的关联方法

### 1. 为什么需要关联关系Associations

在Rails里, 关联关系Association描述了两个ActiveRecord models之间的联系. 为什么我们需要关联关系? 因为它们能将关联models之间的操作变得简单且有效. 举个例子, 假如有一个Rails应用拥有Author和Book两个Model, 每位Author可以拥有多个Books. 如果没有关联关系, 那么model的声明会长成这样

```ruby
class Author < ApplicationRecord
  
end

class Book < ApplicationRecord

end
```

现在, 假如我们想要添加一本新的书给到一位作者, 那么我们可能要做如下操作

```ruby
@book = Book.create(published_at: Time.now, author_id: @author.id)
```

当我们需要删除一位作者时, 同时需要删除属于该作者的所有书籍, 则可能如下

```ruby
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end

@author.destroy
```

如果我们切换为使用关联关系Associations, 则我们可以为上面的代码做一个明显的瘦身. 我们只需要告诉Rails两Models的关系就行, 下方是重构后的代码

```ruby
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```

通过上述的修改后, 我们可以非常简单的创建一本属于某位作者的书籍.

```ruby
@book = @author.books.create(published_at: Time.now)
```

当删除这位作者时, 只需要一行代码, 就能同时删除作者和属于该作者的所有书籍

```ruby
@author.destroy
```

通过上述的例子我们可以看到关联关系的便利性, 请阅读下面的章节来增进理解, 同时当中还包含了很多的技巧.

### 2. 关联关系的类型

Rails支持以下6种关联关系

- belongs_to
- has_one
- has_many
- has_many :through
- has_one :through
- has_and_belongs_to_many

关联关系也是通过宏模式进行调用, 因此你可以以声明的形式按需添加到你的Models里. 举个例子, 通过声明某个model`belongs_to`另外一个model, Rails会理解为维持一个`Primary Key - Foreign Key`的关系给到两个models, 同时你会自动获得很多好用的方法来使用这一关系.

在下面的章节里, 你会学到如何声明并且使用各种类型的关联关系. 但是首先请快速的来理解一下每种关联关系的含义.

#### 2.1 belongs_to

`belongs_to`关联关系会建立与另外一个model的联系, 也就是说每一个model实例都会属于(belongs_to)另外一个model的实例. 举个例子, 作者和书籍, 每本书籍都应该属于一位作者, 则代码如下

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

注意: `belongs_to`关联关系必须使用`单数名词`, 如果你使用了`复数名词`的话(比如通过Book.create(authors: @author)), 你可能会碰到`uninitialized constant Book::Authors`错误. 这是因为Rails是自动从关联关系的名称来推断类名的, 如果你的关联关系的名称错误的使用了复数, 那么推断的类名也会错误的被认为是复数.

对应的migration可能如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

当单独使用`belongs_to`的时候, 会生成一个单一方向的连接. 此时上面例子中的每本书都会有作者, 但是作者并不会知道他有这些书. 为了设定双向的联系, `belongs_to`需要组合使用`has_one`或者`has_many`到其他的model里.

光靠`belongs_to`不能确保引用一致性, 因此基于实际的业务逻辑你可能还需要添加一个数据库级别的外键约束到引用的字段上, 比如

```ruby
create_table :books do |t|
  t.belongs_to :author, foreign_key: true
end
```

#### 2.2 has_one

`has_one` 关联关系表达了一个model对另外一个model有一对一的引用关系. 而这个model可以通过关联关系被获取到(fetched, Ruby对象的get方法为fetch)

举个例子, 假如有一个Supplier类拥有一个account, 你可能会声明supplier为如下代码

```ruby
class Supplier < ApplicationRecord
  has_one :account
end
```

与`belongs_to`的主要区别在于其起到链接作用的外键字段`supplier_id`在对方的表里, 此时对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```

基于项目情况, 可能我们依旧需要创建唯一索引和外键约束来满足需求, 在这种情况下字段的定义可能如下

```ruby
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
end
```

当`has_one`组合使用`belongs_to`时, 则两个models之间的关系会变成双向的.

#### 2.3 has_many

`has_many`关系类似于`has_one`, 但是它表示了models之间存在的是一对多的关系, 该关系表示每一个model实例都会有0~n个其他的model实例. 举个例子, 在一个应用里包括了作者和书籍2个model, 作者的model可能如下被声明

```ruby
class Author < ApplicationRecord
  has_many :books
end
```

注意: 当model的关系为`has_many`的时候, 则对方model的名字需要是复数.

对应的migration可能如下

```ruby
class CreateAuthors < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

基于项目情况, 通常来说对于`has_many`的关系来说, 创建一个非唯一的索引和可选的外键约束能够提升性能

```ruby
create_table :books do |t|
  t.belongs_to :author, index: true, foreign_key: true
end
```

#### 2.4 has_many :through关系

`has_many :through`关系经常被用在设定多对多的关系上. 这个关联关系表示当前声明了这个关系的model与其0-n个models, 可以通过(through)第三方model来访问到. 举个例子, 考虑存在一个病人需要预约来找到医生的例子. 相关的关系可能如下

```ruby
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

从上可以看到, Physician会有很多的Patients, 而一个Patient也可以有很多的Physicians, 两者为多对多的关系, 通过第三张表appointments来进行管理. 此时`physician_id, patient_id`都在appointments表上. 对应的migrations会如下

```ruby
class CreateAppointments < ActiveRecord::Migration[7.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```

关联的models可以通过`has_many`来进行管理, 举个例子, 如果

```ruby
physician.patients = patients
```

那么新的关系会自动创建, 当中如果某些关联关系丢失了, 则相关记录会自动被删除.

注意: 自动删除join的models是直接删除的, 不会触发任何删除回调的逻辑.

`has_many :through`关联关系在设定多对多关系的捷径时也很有用. 举个例子, 如果一篇文档有多个章节, 每个章节又会有多个段落, 有时你可能想直接获取所有段落的集合, 此时你可能会如下设定.

```ruby
class Docment < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```

通过上述的`through: :sections`, Rails会自动识别理解为如下代码

```ruby
@document.paragraphs
```

#### 2.5 has_one :through 关联关系

`has_one :through`关联关系设定了两个models之间一对一的关系. 该关联关系表示声明的model可以通过(through)第三方的model来匹配到其对应的model. 举个例子, 如果一个供应商拥有一个账号, 并且每个账号又关联到一个账号历史, 则供应商model的关系可以如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```

对应的migration如下

```ruby
class CreateAccountHistory < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```

#### 2.6 has_and_belongs_to_many 关联关系

`has_and_belongs_to_many`关联关系能够创建一个直接的多对多的关系, 而不需要中间用于搭桥的model. 举个例子, 如果你的应用包括了`assemblies和parts`两个models, 每个`assembly`会有多个`parts`,每个`part`会出现在多个`assemblies`里, 你可以如下声明models

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end


class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

此时会自动以2个Models的名称的复数, 来生成第三张表多多的映射表, migrations如下

```ruby
class CreateAssembliesAndParts < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```

#### 2.7 belongs_to和has_one如何选

如果你想要在两个models之间设定1对1的关系, 你需要给其中一个model加上`belongs_to`,另外一个加上`has_one`, 但是谁加给谁怎么决定?

两者的主要区别在于外键(belongs_to的那一方会加上外键约束),但是你依然需要思考数据的实际意义. `has_one`关系表示的是某个东西里的某一个是属于你的, 也就是说, 通过那个东西能反向找到你. 举个例子, 账号和供应商的关系, 它们之间正确的关系如下

```ruby
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```

对应的migration如下

```ruby
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint :supplier_id
      t.string :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```

注意: 使用`t.bigint :supplier_id`能让外键的命名容易理解和识别, 在当前版本的Rails里, 你可以使用`t.references :supplier`来代替.

#### 2.8 has_many :through 和 has_and_belongs_to_many如何选

Rails提供了2种完全不同的方法来声明models的多对多关系, 第一种方法是使用`has_and_belongs_to_many`, 该方法允许你直接创建关联关系.

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

第二种方式声明多对多是使用`has_many :through`, 这个指令是通过一个join的model,来间接创建多对多的关系.

```ruby
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```

最佳实践表示, 如果你需要用到`relationship`的join的model当作一个独立的实体的话, 则你应该设定`has_many :through`关系. 如果你不需要在`relationship`的model上做任何操作的话, 直接用`has_and_belongs_to_many`关系会更简单一些(尽管你需要记住自动创建的第三张表叫啥, 而且要手动创建一下这张表)

如果你需要`validations, callbacks, attributes`等等属性和功能的话, 你应该使用`has_many :through`来管理join model.

#### 2.9 多态(Poly)关联关系

一个稍微复杂的例子是多态关联关系. 使用多态关联关系的话, 则一个model可以属于(belongs_to)超过一个的其他models. 举个例子, 如果你拥有一个picture model, 它既属于一个employee的model, 又属于一个product的model, 此时可以如下声明

```ruby
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```

你可以把`polymorphic`的`belongs_to`声明当作是在设定一个接口名称, 这个接口可以提供给其他的models自由使用. 从上面的例子中, 你可以通过一个`Employee`的实例, 来获取到一组照片`@employee.pictures`

相似的, 也可以通过`@product.pictures`来获取照片.

如果你有`Picture`这个model的一个实例的话, 则你可以通过`@picture.imageable`来访问到它的parent. 为了让其起作用, 你需要同时为model声明一个外键字段和一个类型字段以用来表示是多态的接口

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```

这个migration可以用`t.references`简化

```ruby
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end

# t.references, ploymorphic: true 会自动给表加上imageable_id imageable_type 2个字段
```

#### 2.10 Self Joins

在设计一个model的时候, 有时你可能会发现你需要关联到model自身. 举个例子, 你可能想要在一个单一的数据库model里存储所有的雇员信息, 但是又希望能区分它们为经理或者普通员工. 这种情况可以通过`self-joining`关系来解决

```ruby
class Employee < ApplicationRecord
  has_many :subordinates, class_name: 'Employee', foreign_key: 'manager_id'
  belongs_to :manager, class_name: 'Employee', optional: true
end
```

通过这样的设置, 你可以通过`@employee.subordinates`, `@employee.manager`来获取不同的对象.

在migrations里, 你需要加入一个引用字段给到model自身

```ruby
class CreateEmployees < ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      t.references :manager, foreign_key: { to_table: :employees }
      t.timestamps
    end
  end
end
```

### 3. 技巧与警告

这里有些准则你需要遵守以有效使用关联关系

- 控制缓存
- 避免名称冲突
- 更新schema
- 控制关联关系的范围(scope)
- 双向关系

#### 3.1 控制缓存

所有关联关系的方法都是基于缓存来完成的, 它们会缓存最为常用的查询结果来完成复杂的操作. 缓存是跨方法的, 比如

```ruby
author.books.load

# 会使用上面的缓存
author.books.size
# 会使用上面的缓存
author.books.empty?
```

但是如果你想重新加载缓存的话应该怎么做? 调用`reload`来刷新缓存

```ruby
author.books.load
author.books.size
# 重新从数据库加载最新的数据
author.books.reload.empty?
```

#### 3.2 避免命名冲突

不要使用已经被`ActiveRecord::Base`所占用的名称. 关联关系的方法会覆盖继承的父类的方法.比如`attributes`,`connection`都是错误的命名

#### 3.3 更新Schema

关联关系非常的有用, 你有必要维护整个数据库schema的正确以确保匹配你的关联关系. 在实践中, 你需要做以下2件事. 

1. 对于`belongs_to`的关联关系, 你应该创建外键.

当你声明`belongs_to`关系时, 你需要创建合理的外键. 举个例子

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

这个声明需要在books表里有合适的外键字段. 如果此时是一张新表, 则migration应该如下

```ruby
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```

如果是既存的表, 则migration应该如下

```ruby
class AddAuthorToBooks < ActiveRecord::Migration[7.0]
  def change
    add_reference :books, :author
  end
end
```

注意: 如果你要确保数据库层面的引用关系完整, 请在上面的例子里加上`foreign_key: true`配置项给到`reference`字段


2. 对于`has_and_belongs_to_many`的关联关系, 你应该创建合适的join表.

如果你是通过`has_and_belongs_to_many`关联关系创建的, 则你需要显式的创建join表. 除非你写了`:join_table`配置项. ActiveRecord会自动按照词法优先级来创建表名, 比如`authors, books`两张表的join表会自动为`authors_books`, 因为`a`在`b`的前面.

注意: 前面的models的名称使用的是`String`的`<=>`操作符来计算的. 也就意味着如果字符串长度不一样, 则较长的字符串会被认为有较高的词法优先级. 举个例子, 表`paper_boxes`和`papers`结合生成的join表名会为`paper_boxes_papers`, 因为下划线`_`在词法上低于`s`.

无论名字是啥, 你都必须手动创建join table, 举个例子

```ruby
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

上述例子需要`assemblies_parts`这个join表来支撑才能完成关联关系. 这张表不应该拥有主键

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```

我们传递了`id: false`在`create_table`的时候, 因为这张join表不需要表现为一个model. 如果你在`has_and_belongs_to_many`的关系上看到了任何奇怪的行为或者id冲突等问题, 很有可能是因为你可能忘了取消主键导致的.

你也可以使用`create_join_table`方法

```ruby
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```

#### 3.4 控制关联关系的范围(scope)

默认情况下, 关联关系仅会限制在当前的module的范围内, 举个例子

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

上述例子会正常工作, 因为`Supplier`和`Account`这2个类都定义在了相同的作用域里. 但是下面的例子就不行了, 因为它们定义在了不同的作用域里

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

为了关联不同命名空间的model, 你需要完整的声明类名

```ruby
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```

#### 3.5 双向关系

声明双向关系是必须且普遍的事情

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```

Active Record会尝试基于关联关系的名称,来自动识别这2个models的双向关系,如下

```ruby
a = Author.first
b = a.books.first
a.first_name == b.author.first_name
a.first_name = 'David'
a.first_name == b.author.first_name
```

Active Record支持自动识别大多数的标准名称. 但是, Active Record不能自动识别带`:through`或者`:foreign_key`配置项的双向关系. 此外自定义作用域的也没法自动识别, 除非

`config.active_record.automatic_scope_inversing` = true 这个项目配置被设定.默认是开启的.

举个例子

```ruby
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

Active Record此时不会自动识别双边关系.

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

为此, Active Record提供了`:inverse_of`配置项来帮助你显式的声明双向关系.

```ruby
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

通过加入`:inverse_of`配置项到`has_many`关系声明, Active Record则可以识别双向关系

```ruby
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name
a.first_name = 'David'
a.first_name == b.writer.first_name
```

### 4. 关联关系引用细节

下面的章节给出了每种关联关系的细节, 包括它们会提供的方法和可以用到的配置项.

#### 4.1 belongs_to 关联关系引用

从数据库的角度来说的话, `belongs_to`的关联关系表达了这个model的表会有一个字段, 该字段用于和其他的表做引用连接. `belongs_to`可以用在一对多,也可以用在一对一的关系上. 如果是一对一的关系, 则应该用`has_one`.

##### 4.1.1 belongs_to增加的方法

当你声明一个`belongs_to`关联关系的时候, 声明的类会自动追加8个方法. 分别如下

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association
- association_changed?
- association_previously_changed?

所有上述的方法, `association`文字描述的位置都要以`belongs_to`的第一个参数的Symbol来替换.比如

```ruby
class Book < ApplicationRecord
  belongs_to :author
end
```

此时,每一个`Book`的model的实例, 都会有如下的方法

```sh
author
author=
build_author
create_author
create_author!
reload_author
author_changed?
author_previously_changed?
```

当初始化一个新的`has_one`或者`belongs_to`关联关系的时候, 你必须使用`build_`前缀来创建关联关系, 而对于`association.build`方法来说, 它更适合用在`has_many`或`has_and_belongs_to_many`关联关系上.如果是`create`,则应该使用`create_`前缀.

###### 4.1.1.1 association

`association`方法会返回存在的所有关联对象. 如果没有找到关联对象, 则返回`nil`

```ruby
@author = @book.author
```

如果关联的对象已经从数据库里被加载, 则第二次要的时候会返回缓存的版本. 为了覆盖这一行为(即强制重新从数据库加载), 可以调用父对象的`reload_association`方法来完成.

再次提醒, 这里的`reload_association`,带下划线的这些方法, 都是给到一对一关系的.

```ruby
@author = @book.reload_author
```

###### 4.1.1.2 association=(associate)

`association=`方法可以将一个关联的对象赋值到这个对象上. 从原理上说, 这意味着提取出关联对象的主键, 并设定对象的外键为这个主键的值.

```ruby
@book.author = @author
```

###### 4.1.1.3 build_association(attributes = {})

