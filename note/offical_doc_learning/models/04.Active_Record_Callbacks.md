### 大纲

- ActiveRecord对象的生命周期
- 如何为Model对象创建适配生命周期函数的方法
- 如何封装通用的回调

### 1.对象生命周期

在正常的Rails应用中, 对象可以被创建, 更新, 删除. ActiveRecord提供了Hooks给到应用里的对象生命周期, 使得你能够控制你的应用和数据.

回调允许你在修改对象的状态后, 触发逻辑.

### 2. 回调概览

回调(Callbacks)是方法, 这些方法会在对象生命周期的特定时机触发. 在回调的帮助下, 可以让你的ActiveRecord对象们在增删改查, 校验, 从数据库加载等的任何阶段触发一定的逻辑.

#### 2.1 注册回调

为了使用回调, 你需要先注册它们. 你可以像写普通的方法一样先写出这些回调, 然后使用宏模式(macro-style)的类方法来注册这些函数为回调函数.

```ruby
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  private

  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
```

宏模式的类方法(如上面的`before_validation`)也可以直接接收一个`block`. 如果你的回调代码只有一行的话, 你可以考虑使用下面这种写法

```ruby
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_create do
    self.name = login.capitalize if name.blank?
  end
end
```

回调同样也可以被注册到指定的对象生命周期事件时触发

```ruby
class User < ApplicationRecord
  before_validation :normalize_name, on: :create

  after_validation :set_location, on: %w[create update]

  private

  def normalize_name
    self.name = name.downcase.titleize
  end

  def set_location
    self.location = LocationService.query(self) 
  end
end
```

如上这些代码所示, 作为ActiveRecord的一个最佳实践, 官方推荐将这些回调逻辑定义为`private`的. 如果为`public`, 那么它们将能被model的外部所调用, 这违反了对象封装的原则.

### 3. 可用的回调

下方是所有可用的ActiveRecord的回调函数, 它们都以对象生命周期的先后顺序进行排列.

#### 3.1 创建一个对象

- before_validation
- after_validation
- before_save
- around_save
- after_save
- before_create
- around_create
- after_create
- after_commit / after_rollback

#### 3.2 更新一个对象

- before_validation
- after_validation
- before_save
- around_save
- after_save
- before_update
- around_update
- after_update
- after_commit / after_rollback

#### 3.3 删除一个对象

- before_destroy
- around_destroy
- after_destroy
- after_commit / after_rollback

注意1: `after_save` 会在`create`和`update`时都触发, 但是其执行时机总是在`after_create`, `after_update`后面.

注意2: 避免在回调里更新和保存属性. 举个例子, 不要在回调里调用`update(attribute: "value")`, 这样在回调里去修改model对象的状态可能会在`commit`时导致无法预期的副作用.相反你应该在`before_create/before_update`或更早的回调处安全的给这些对象赋值(举个例子self.attribute = "value")

注意3: `before_destroy`回调应该在`dependent: :destroy`关系(或者使用了`prepend: true`配置项)的model对象里调用, 以确保它们能在对象被`dependent: :destroy`删除前执行.

#### 3.4 after_initialize 和 after_find

`after_initialize`回调会在一个ActiveRecord对象被实例化时调用, 无论它是被直接`new`出来的, 还是数据库加载出来的. 这个回调能够避免直接覆盖你的ActiveRecord类的`initialize`方法, 因此是有用的.

`after_find`回调会在ActiveRecord从数据库加载到数据时被调用. 当`after_find`与`after_initialize`同时存在时, `after_find`将优先被调用.

`after_initialize`和`after_find`回调都没有`before_*`的版本, 它们在用法上和其他的回调无差别.

```ruby
class User < ApplicationRecord
  after_initialize do |user|
    puts "you have initialized an object!"
  end

  after_find do |user|
    puts "you have found an object!"
  end
end

# 执行结果
User.new
# You have initialized an object!
User.first
# You have found an object!
# You have initialized an object!
```

#### 3.5 after_touch

`after_touch`回调会在对象被`touched`时触发

```ruby
class User < ApplicationRecord
  after_touch do |user|
    puts "you have touched an object"
  end
end

# 执行
u = User.create(name: 'Kuldeep') # 无触发
u.touch # You have touched an object
```

这个回调可以配合`belongs_to`一起使用, 只要配置了`touch:true`,则关联的关系都会受到影响.

```ruby
class Employee < ApplicationRecord
  belongs_to :company, touch: true
  after_touch do
    puts "An Employee was touched"
  end
end

class Company < ApplicationRecord
  has_many :employees
  after_touch :log_when_anyone_touchede

  private
  def log_when_anyone_touchede
    puts "Employee/Company was touched"
  end
end

# 执行结果
@employee = Employee.last
@employee.touch # triggers @employee.company.touch
# An Employee was touched
# Employee/Company was touched
```

### 4. 触发回调
