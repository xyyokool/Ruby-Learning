### 0. 本章内容

- 如何使用内置的ActiveRecord校验helper方法
- 如何创建自定义的validation方法
- 如何处理校验流程中的错误信息

### 1. 校验(Validations)概览

下方是是一个简单的校验的例子

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.create(name: "stan").valid?
# true
Person.create(name: nil).valid?
# false
```

如上代码你可以看到, `Person`实例在创建时会在没有输入`name`属性的情况下返回校验失败, 而这些失败的语句则不会被提交到数据库进行持久化.

在正式挖掘细节之前, 先来看下校验应该如何贴近你的应用.

#### 1.1 为什么需要使用到校验?

校验通常都被用来确保仅有合法的数据能够被保存到数据库里, 举个例子, 对于我们的应用而言确保每个用户都能提供一个有效的电子邮箱地址和邮编地址都是非常重要的. 而Model层的是保证有效数据被存入数据库前最佳的校验位置, 因为Model层独立于数据库, 不能被终端用户绕过, 而且便于测试与维护. rails提供了很多内置的helper方法以用于校验工作, 并且允许你创建你自己的校验方法.

这里也有很多其他方法可以在数据被存入数据库之前校验数据, 包括数据库约束, 客户端校验以及controller层的校验. 下方是这些方法的优缺点汇总

- 数据库约束依赖于具体项目所使用的数据库, 测试与维护麻烦. 然而,如果你的数据库同时还被其他的应用所使用, 那么使用数据库约束的方式可能是个好的选择. 此外, 数据库层面的校验在处理某些内容上更加安全(比如在重度被使用的表上校验数据的唯一性).
- 客户端校验也是很有用的方式, 但是如果单独使用的话不太安全. 如果这些校验机能由JS提供, 用户可能会通过浏览器的关闭JS加载的功能来绕过JS校验, 尽管如此, 如果能结合其他的技术手段, 那么客户端校验可以是一种提升用户体验的良好方式
- Controller层校验也可以被使用, 但是实际开发中难以测试和维护. 在rails的项目中, 无论在任何时候, 都应该保持controllers干净,清晰, 这能帮助你的APP能更加健壮与持久.

基于上述内容的考虑, rails团队因此决定将model层的校验作为最为常用的方式推广.

#### 1.2 什么时候要做校验?

rails的项目中有2种类型的ActiveRecord对象, 一种是与数据库内记录所对应的, 另一种是不对应的. 当你创建一个新的对象时, 举个例子比如说用`new`方法, 那么这些对象将不会属于任何数据库. 一旦你调用了`save`方法则它们才会被保存到数据库的表内. ActiveRecord使用`new_record?`实例方法来确认是否一个对象已经在数据库里被保存了. 比如下方的例子

```ruby
class Person < ApplicationRecord
end
```

我们可以通过`bin/rails console`来观察到它是如何工作的.

```ruby
p = Person.new(name: "John Doe")
p.new_record? # true
p.save
p.new_record? # false
```

创建一个新的记录将会给db发送`INSERT`操作, 更新一个已经存在的记录则会执行`UPDATE`操作. 校验会在这些命令被发送到DB之前被执行, 如果任何校验失败, 则该对象将会被标记为无效并且ActiveRecord将不会执行任何SQL操作.这避免了存储无效的对象到数据库里, 你同样可以在对象被创建,保持,更新时要求执行特定的校验.

注: 有很多种方法可以改变对象的状态, 有些方法会触发校验, 而有些则不会. 这也就意味着你始终存在可能存入无效数据到数据库的可能.

下面这些方法用于触发校验, 并且仅会在object有效时将对象保存到数据库

- create
- create!
- save
- save!
- update
- update!

这些!版本(bang version)会在校验失败时抛出异常, 而非!版本(non-bang)则不会. `save`与`update`会返回`false`, `create`则会返回对象

#### 1.3 跳过校验

下方这些方法可以用于跳过校验, 并且会无视有效性直接保存对象到数据, 使用时需要谨慎.

- decrement!
- decrement_counter
- increment!
- increment_counter
- insert
- insert!
- insert_all
- insert_all!
- toggle!
- touch
- touch_all
- update_all
- update_attribute
- update_column
- update_columns
- update_counters
- upsert
- upsert_all

注意`save`方法在传递`validate: false`作为参数时也会跳过校验. 因此使用上也需要谨慎

- save(validate: false)

#### 1.4 valid? 还是 invalid?

在保存ActiveRecord对象之前, rails会执行你的校验逻辑, 如果这些校验任何一步发生错误, 则rails都不会保存这个对象.

你同样可以手动运行这些校验逻辑, `valid?`方法会触发你写的所有校验并且返回true/false来表示是否通过. 见如下代码

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.create(name: "John Doe").valid? # true
Person.create(name: nil).valid? # false
```

在ActiveRecord执行完校验后, 任何校验中被查出的错误都可以通过`errors`实例方法来拿到, 该方法会返回一个`errors`的集合, 该集合如果为空, 则表示校验通过.

注意使用`new`创建的对象实例将不会报告错误,就算它们校验不通过, 因为校验逻辑仅仅会在对象被保存(saved)时自动执行, 比如`create`和`save`方法.

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
p = Person.new
p.errors.size # 0
p.valid? # false
p.errors.objects.first.full_message # "Name can't be blank"
p = Person.create
p.errors.objects.first.full_message # "Name can't be blank"
p.save # false
p.save! # ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
Person.create! # ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```

`invalid?`方法是`valid?`方法的对面版本. 它会触发你的校验, 并在发现errors集合里有任何数据时返回true, 无数据时返回false

#### 1.5 errors[]

为了验证对象里的某个属性是否是有效的, 我们可以使用`errors[:attribute]`来获取. 它会返回目标属性下的所有错误信息, 如果没有错误, 则返回空的集合.

上述方法仅仅在校验结束之后使用才有效, 因为它只会检查errors集合并且不会触发校验.该方法不同于ActiveRecord::Base#invalid?方法, 因为它并没有校验整个对象的合法性, 而仅仅是检查了对象下某个属性是否有错误.

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.new.errors[:name].any? # 不等于0就返回false 
Person.create.errors[:name].any? # 大于0就返回true
```

我们会在[后续](https://guides.rubyonrails.org/active_record_validations.html#working-with-validation-errors)继续探讨校验失败的情况.

### 2. 校验Helpers

ActiveRecord已经在class定义时提供了很多内置的校验helper方法, 这些方法能完成一些非常通用的校验逻辑. 每当校验失败, 则一个error就会被添加到实例对象的`errors`集合里, 并且会关联到被校验的属性上.

每个helper方法都能接收任意数量的属性名称, 因此只需要一行代码你就可以完成给多个属性添加相同的校验逻辑.

所有的helpers方法都接收`:on`和`:message`option, 其中前者用于定义什么时候执行校验, 后者则定义了如果校验失败时应该往`errors`里添加什么信息. `:on`option接收`:create`或者`:update`作为参数, 而`:message`则自带默认参数.

#### 2.1 acceptance
该校验方法校验view层的checkbox是否被用户选择了, 经常被用在用户需要同意APP的使用条款之类的上面.

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
```

下方代码仅在`terms_of_service`不为空时被使用, 默认错误消息为"must be accepted", 当然此时可以通过`message`option来传递自定义的消息

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'muse be abided' }
end
```

同样也接收一个`:accept`option, 它决定了传递的值是否符合集合内的要求, 默认是['1', true]

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { accept: 'yes' }
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
```

这些校验仅对于web应用而言是需要的, 并且可能不需要被保存到数据库里, 如果你的数据库表内并没有为它专门开一个字段, 则acceptance这个helper方法会创建一个虚拟的属性. 如果该属性在你的表里面有, 那么`accept` option必须要被set或者include `true`, 否则该校验不会被执行.

#### 2.2 validates_associated

当你的model关联了其他的需要被校验的models时, 你应该使用这个helper方法. 当你尝试去保存你的对象时, `valid?`方法将会被所关联的每一个对象所调用.

```ruby
class Library < ApplicationRecord
  has_many :books
  validates_associated :books # 自动调用Book.valid?来执行book model里的所有校验逻辑
end
```

上述校验会在任何种类的关联类型上工作.

注: 请不要使用`validates_associated`在所关联的对象上, 比如A关联B,B也关联了A, 它们会导致死循环问题.

`validates_associated`方法的默认错误信息是`is invalid`, 注意每一个关联的对象都拥有它自己的`errors`集合, 关联对象的errors集合并不会冒泡到调用层的对象上来.

#### 2.3 confirmation

当你需要确切的接收到2个完全相同的text类型字段时, 你应该使用这个helper函数. 举个例子, 在邮箱地址和密码确认等场景下都会有这个需求. 这个校验函数会创建一个虚拟的属性其名字叫做`目标属性名_confirmation`

```ruby
class Person < ApplicationRecord
  validates :email, confirmation: true
end
```

此时在view层你应该如下设定表单

```ruby
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```

上述检查仅会在`email_confirmation`不为空的情况下被执行, 为了让其起作用, 请确保带了presence方法来启用检查


```ruby
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```

还有一个`:case_sensitive`的option可以被选用, 当你需要考虑大小写敏感时可以用, 默认值是true

```ruby
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
```

默认的报错信息是"doesn't match confirmation"

#### 2.4 comparison比较

该helper方法会比较2个可以比较的值, 要求传入比较方式和要比较的内容. 任何类中的属性能被比较的都可以被用上.

```ruby
class Promotion < ApplicationRecord
  validates :start_date, comparison: { greater_than: :end_date }
end
```

比较相关的option如下

- `:greater_than` : 标明校验值必须比提供的的值要大. 默认错误信息是`must be greater than %{count}`
- `:greater_than_or_equal_to` : 标明值必须要大于或者等于提供的值. 默认错误信息是`must be greater than or equal to %{count}`
- `:equal_to` : 标明值必须等于提供的值. 默认错误信息是`must be equal to %{count}`
- `:less_than` : 标明值必须小于提供的值. 默认错误信息是`must be less than %{count}` 
- `:less_than_or_equal_to` : 标明值必须小于或者等于提供的值. 默认错误信息是`must be less than or equal to %{count}`
- `:other_than` : 标明值必须不同于提供的值, 默认错误信息是`must be other than %{count}`

#### 2.5 exclusion排除

该helper方法会校验值是否不在给定的设定值里, 设定值可以无限多.

```ruby
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w[www us ca jp], message: "%{value} is reserved." }
end
```

`exclusion` helper拥有一个option为`:in`用于表示在目标set里的值将不会通过校验. `:in` option 还有个孪生用法叫做 `:within`, 该方法用法和`:in`一摸一样. 而上面的 `:message` option则表达了你应该如何去修改传入的值. 所有关于message的设定可以看[这里](https://guides.rubyonrails.org/active_record_validations.html#message).

默认错误信息为`is reserved`

#### 2.6 format格式

该helper方法会校验属性值是否匹配提供的正则格式, 正则通过`:with` option来提供

```ruby
class Product < ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
```

与此相反, 你也可以通过`:without`option来表达属性值不要和正则相匹配

默认错误信息为"is invalid"

#### 2.7 inclusion

该`helper`option表示属性值必须在所提供的可遍历对象里.

```ruby
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
```

`inclusion`helper拥有`:in`option能够接收一个可遍历对象. 同时其还有一个孪生方法叫做`:within`能起到一样的作用. `:message`则用于报错信息处理.

默认报错信息是"is not included in the list"

#### 2.8 length

用于校验属性值的长度, 支持多种option

```ruby
class Person < ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
```

可选的option包括如下

- `:minimum` - 该属性不得小于多少
- `:maximum` - 该属性不得大于多少
- `:in/:within` - 该属性必须在给定范围内,必须是range值
- `:is` - 该属性长度必须相等

默认的报错信息依赖于校验的option是什么, 比如`:wrong_length / :too_long / :too_short`, 并可以用`%{count}`来获取被校验属性的长度. 当然也能使用`:message`来指定报错信息

```ruby
class Person < ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
```

请注意默认的报错信息都是复数格式, 因此当`:minimum`为1的时候,你应该使用`presence: true`来代替. 而当`:in`或者`:within`的下限为1时, 你应该提供一个自定义的消息或者调用`presence`来代替f使用`length`

#### 2.9 numbericality

用于校验属性值必是数字类型.默认情况下, 正负的整数和浮点数都支持.

为了仅想支持int类型, 可以设定`:only_integer` 为true. 该设定使用了`/\A[+-]?\d+\z/
`正则来做匹配.

在不设定的情况下, 默认是将属性值转为`Float`, 并且会在字段类型要求precison或者15时转为`bigdecimal`

```ruby
class Player < ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
```

`:only_integer`时的默认报错信息是"must be an integer"

除了`:only_integer`之外, 还有以下配置可以被使用

- `:greater_than` - 必须大于所提供的值, 报错信息是"must be greater than %{count}".
- `:greateer_than_or_equal_to` - 必须大于等于所提供的值, 报错信息是"must be greater than or equal to %{count}".
- `:equal_to` - 必须等于所提供的值, 报错信息是"must be equal to %{count}".
- `:less_than` - 必须小于所提供的值, 报错信息是"must be less than %{count}".
- `:less_than_or_equal_to`: 必须小于等于所提供的值, 报错信息是"must be less than or equal to %{count}".
- `:other_than` - 必须和所提供的值不一样, 报错信息是"must be other than %{count}".
- `:in` - 必须要在所提供的range范围内, 报错信息是"must be in %{count}".
- `:odd` - 如果设定为true, 则属性值必须为奇数, 报错信息是"must be odd".
- `:even` - 如果设定为true, 则属性值必须为偶数, 报错信息是"must be even".

注: 默认情况下, `numbericality`不允许空值, 你需要额外使用`allow_nil:true`来开启它

默认报错信息为 "is not a number".

#### 2.10 presence

该helper用于校验特定的属性不为空, 它会调用`blank?`方法阿里确认是否目标属性为`nil`或者为`''`,或者为`'  '`空格.

```ruby
class Person < ApplicationRecord
  validates :name, :login, :email, presence: true
end
```

如果你想确认一个`association`是否存在, 你需要去测试是否关联对象存在, 并且不只是外键关联了而已. 通过`presence`, 不仅可以检查外键不为空, 同时还能检查是否object存在

```ruby
class Supplier < ApplicationRecord
  has_one :account
  validates :account, presence: true
end
```

为了确保校验的关联记录必须存在, 我们必须给目标对象添加`:inverse_of`选项.

note: 如果你想确保association即存在又valid可用, 可以使用`validates_associated`来替换`validates`

```ruby
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```

如果你想校验`has_one`, `has_many`关系的对象, 则`presence`会确认目标对象不是`blank?`, 也不是`marked_for_destruction?`

由于`false.blank?`为真, 因此如果想校验一个boolean`是否存在, 需要通过`inclusion/exclusion`取范围.

```ruby
validates :boolean_field_name, inclusion: [true, false]
validates :boolean_field_name, exclusion: [nil]
```

通过使用上述校验, 我们可以确保值不是`nil`

#### 2.11 absence

用于校验特定的属性是否不存在, 会调用`present?`方法来检查是否目标值为`nil`或者为`空字符串(空字符串或者空格)`, 

```ruby
class Person < ApplicationRecord
  validates :name, :email, :login, absence: true
end
```

如果要校验关联关系不存在, 需要测试是否关联对象不存在, 并且对象不是用来映射的外键.

```ruby
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end
```

为了校验关联的记录, 需要在关联记录上加上`inverse_of`配置项.

```ruby
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```

如果你是通过`has_one`或者`has_many`的关系来校验关联对象是否为`absence`的, 则上述的写法会检查目标对象是否即不处于`present?`也不处于`marked_for_destruction?`

由于`false.present?`永远为`false`, 因此如果你想要校验布尔类型的话, 则需要使用`validates :field_name, exclusion: {in: [true, false]}`

该校验默认的报错信息为`must be blank`

#### 2.12 uniqueness

该校验用于校验属性值是否在`saved`之前为唯一. 该校验不会在数据库里创建唯一限制, 因此可能会发生两个数据库链接的情况下, 出现相同记录保存2次的情况.为了避免这个问题, 你必须在数据库的目标字段上创建一个唯一索引.

```ruby
class Account < ApplicationRecord
  validates :email, uniqueness: true
end
```

该校验会对目标表执行SQL查询, 搜索带校验的字段的记录是否已经在数据库里存在.

这里还有一个额外的配置项叫做`:scope`, 来允许你去声明一到多个属性用来限制唯一性检查.

```ruby
class Holiday < ApplicationRecord
  validates :name, uniqueness: { scope: :year, message: 'should happen once per year'}
end
```

要注意如果使用了`:scope`, 则需要保证在数据库表里, 这些相关的字段都需要加上唯一性索引才行.

此外还有一个叫做`:case_sensitive`的配置项, 允许你可以用来定义是否要检查属性值的大小写敏感, 该配置默认为数据库的`collation`设定

```ruby
class Person < ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end
```

**注意: 某些数据库默认情况下配置的是大小写不敏感, 需要看情况配置.**

默认报错信息为`has already been taken`

#### 2.13 validates_with

该校验用于自定义校验, 可以将校验逻辑拆分到其他的类里.

```ruby
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == 'Evil'
      record.errors.add :base, 'Not Good'
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator
end
```

**注意: Errors会被添加到record.errors[:base]里作为整体错误的一部分, 而不是一个特别的值**

`validates_with`方法接收一个类, 一群类来用来做校验, 并且没有默认的报错信息. 你需要手工添加错误到记录的错误数组里.

为了自动调用校验方法, 自定义校验类里的`validate`方法必须添加`record`参数, 其内容为需要被校验的记录.

正如其他的校验一样, `validates_with`方法接收`:if, :unless, :on`等配置项, 如果你传递了任何配置项, 则它们都会作为参数传入到`validate`方法里作为`options`被使用.

```ruby
class GoodValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any? { |field| record.send(field) == 'Evil' } 
      record.errors.add :base, 'This is not good'
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodValidator, fields: [:first_name, :last_name]
end
```

请注意上面的校验器仅仅会在整个应用的生命周期内被初始化一次, 而不是每运行一次就重新创建一个校验器的实例, 因此需要注意里面所使用的实例变量.

如果你的校验器非常复杂并且你需要实例变量, 则你可以直接用ruby的原生对象来代替使用`ActiveModel::Validator`, 并且替换`validates_with`为`validate`

```ruby
class Person < ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_method?
      @person.errors.add :base, 'May has some issues'
    end
  end
end
```

#### 2.14 validates_each
