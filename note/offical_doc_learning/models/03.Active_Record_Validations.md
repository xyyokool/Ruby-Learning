### 0. 本章内容

- 如何使用内置的ActiveRecord校验helper方法
- 如何创建自定义的validation方法
- 如何处理校验流程中的错误信息

### 1. 校验(Validations)概览

下方是是一个简单的校验的例子

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.create(name: "stan").valid?
# true
Person.create(name: nil).valid?
# false
```

如上代码你可以看到, `Person`实例在创建时会在没有输入`name`属性的情况下返回校验失败, 而这些失败的语句则不会被提交到数据库进行持久化.

在正式挖掘细节之前, 先来看下校验应该如何贴近你的应用.

#### 1.1 为什么需要使用到校验?

校验通常都被用来确保仅有合法的数据能够被保存到数据库里, 举个例子, 对于我们的应用而言确保每个用户都能提供一个有效的电子邮箱地址和邮编地址都是非常重要的. 而Model层的是保证有效数据被存入数据库前最佳的校验位置, 因为Model层独立于数据库, 不能被终端用户绕过, 而且便于测试与维护. rails提供了很多内置的helper方法以用于校验工作, 并且允许你创建你自己的校验方法.

这里也有很多其他方法可以在数据被存入数据库之前校验数据, 包括数据库约束, 客户端校验以及controller层的校验. 下方是这些方法的优缺点汇总

- 数据库约束依赖于具体项目所使用的数据库, 测试与维护麻烦. 然而,如果你的数据库同时还被其他的应用所使用, 那么使用数据库约束的方式可能是个好的选择. 此外, 数据库层面的校验在处理某些内容上更加安全(比如在重度被使用的表上校验数据的唯一性).
- 客户端校验也是很有用的方式, 但是如果单独使用的话不太安全. 如果这些校验机能由JS提供, 用户可能会通过浏览器的关闭JS加载的功能来绕过JS校验, 尽管如此, 如果能结合其他的技术手段, 那么客户端校验可以是一种提升用户体验的良好方式
- Controller层校验也可以被使用, 但是实际开发中难以测试和维护. 在rails的项目中, 无论在任何时候, 都应该保持controllers干净,清晰, 这能帮助你的APP能更加健壮与持久.

基于上述内容的考虑, rails团队因此决定将model层的校验作为最为常用的方式推广.

#### 1.2 什么时候要做校验?

rails的项目中有2种类型的ActiveRecord对象, 一种是与数据库内记录所对应的, 另一种是不对应的. 当你创建一个新的对象时, 举个例子比如说用`new`方法, 那么这些对象将不会属于任何数据库. 一旦你调用了`save`方法则它们才会被保存到数据库的表内. ActiveRecord使用`new_record?`实例方法来确认是否一个对象已经在数据库里被保存了. 比如下方的例子

```ruby
class Person < ApplicationRecord
end
```

我们可以通过`bin/rails console`来观察到它是如何工作的.

```ruby
p = Person.new(name: "John Doe")
p.new_record? # true
p.save
p.new_record? # false
```

创建一个新的记录将会给db发送`INSERT`操作, 更新一个已经存在的记录则会执行`UPDATE`操作. 校验会在这些命令被发送到DB之前被执行, 如果任何校验失败, 则该对象将会被标记为无效并且ActiveRecord将不会执行任何SQL操作.这避免了存储无效的对象到数据库里, 你同样可以在对象被创建,保持,更新时要求执行特定的校验.

注: 有很多种方法可以改变对象的状态, 有些方法会触发校验, 而有些则不会. 这也就意味着你始终存在可能存入无效数据到数据库的可能.

下面这些方法用于触发校验, 并且仅会在object有效时将对象保存到数据库

- create
- create!
- save
- save!
- update
- update!

这些!版本(bang version)会在校验失败时抛出异常, 而非!版本(non-bang)则不会. `save`与`update`会返回`false`, `create`则会返回对象

#### 1.3 跳过校验

下方这些方法可以用于跳过校验, 并且会无视有效性直接保存对象到数据, 使用时需要谨慎.

- decrement!
- decrement_counter
- increment!
- increment_counter
- insert
- insert!
- insert_all
- insert_all!
- toggle!
- touch
- touch_all
- update_all
- update_attribute
- update_column
- update_columns
- update_counters
- upsert
- upsert_all

注意`save`方法在传递`validate: false`作为参数时也会跳过校验. 因此使用上也需要谨慎

- save(validate: false)

#### 1.4 valid? 还是 invalid?

在保存ActiveRecord对象之前, rails会执行你的校验逻辑, 如果这些校验任何一步发生错误, 则rails都不会保存这个对象.

你同样可以手动运行这些校验逻辑, `valid?`方法会触发你写的所有校验并且返回true/false来表示是否通过. 见如下代码

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.create(name: "John Doe").valid? # true
Person.create(name: nil).valid? # false
```

在ActiveRecord执行完校验后, 任何校验中被查出的错误都可以通过`errors`实例方法来拿到, 该方法会返回一个`errors`的集合, 该集合如果为空, 则表示校验通过.

注意使用`new`创建的对象实例将不会报告错误,就算它们校验不通过, 因为校验逻辑仅仅会在对象被保存(saved)时自动执行, 比如`create`和`save`方法.

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
p = Person.new
p.errors.size # 0
p.valid? # false
p.errors.objects.first.full_message # "Name can't be blank"
p = Person.create
p.errors.objects.first.full_message # "Name can't be blank"
p.save # false
p.save! # ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
Person.create! # ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```

`invalid?`方法是`valid?`方法的对面版本. 它会触发你的校验, 并在发现errors集合里有任何数据时返回true, 无数据时返回false

#### 1.5 errors[]

为了验证对象里的某个属性是否是有效的, 我们可以使用`errors[:attribute]`来获取. 它会返回目标属性下的所有错误信息, 如果没有错误, 则返回空的集合.

上述方法仅仅在校验结束之后使用才有效, 因为它只会检查errors集合并且不会触发校验.该方法不同于ActiveRecord::Base#invalid?方法, 因为它并没有校验整个对象的合法性, 而仅仅是检查了对象下某个属性是否有错误.

```ruby
class Person < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
Person.new.errors[:name].any? # 不等于0就返回false 
Person.create.errors[:name].any? # 大于0就返回true
```

我们会在[后续](https://guides.rubyonrails.org/active_record_validations.html#working-with-validation-errors)继续探讨校验失败的情况.

### 2. 校验Helpers

ActiveRecord已经在class定义时提供了很多内置的校验helper方法, 这些方法能完成一些非常通用的校验逻辑. 每当校验失败, 则一个error就会被添加到实例对象的`errors`集合里, 并且会关联到被校验的属性上.

每个helper方法都能接收任意数量的属性名称, 因此只需要一行代码你就可以完成给多个属性添加相同的校验逻辑.

所有的helpers方法都接收`:on`和`:message`option, 其中前者用于定义什么时候执行校验, 后者则定义了如果校验失败时应该往`errors`里添加什么信息. `:on`option接收`:create`或者`:update`作为参数, 而`:message`则自带默认参数.

#### 2.1 acceptance
该校验方法校验view层的checkbox是否被用户选择了, 经常被用在用户需要同意APP的使用条款之类的上面.

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
```

下方代码仅在`terms_of_service`不为空时被使用, 默认错误消息为"must be accepted", 当然此时可以通过`message`option来传递自定义的消息

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'muse be abided' }
end
```

同样也接收一个`:accept`option, 它决定了传递的值是否符合集合内的要求, 默认是['1', true]

```ruby
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { accept: 'yes' }
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
```

这些校验仅对于web应用而言是需要的, 并且可能不需要被保存到数据库里, 如果你的数据库表内并没有为它专门开一个字段, 则acceptance这个helper方法会创建一个虚拟的属性. 如果该属性在你的表里面有, 那么`accept` option必须要被set或者include `true`, 否则该校验不会被执行.

#### 2.2 validates_associated

当你的model关联了其他的需要被校验的models时, 你应该使用这个helper方法. 当你尝试去保存你的对象时, `valid?`方法将会被所关联的每一个对象所调用.

```ruby
class Library < ApplicationRecord
  has_many :books
  validates_associated :books # 自动调用Book.valid?来执行book model里的所有校验逻辑
end
```

上述校验会在任何种类的关联类型上工作.

注: 请不要使用`validates_associated`在所关联的对象上, 比如A关联B,B也关联了A, 它们会导致死循环问题.

`validates_associated`方法的默认错误信息是`is invalid`, 注意每一个关联的对象都拥有它自己的`errors`集合, 关联对象的errors集合并不会冒泡到调用层的对象上来.

#### 2.3 confirmation

当你需要确切的接收到2个完全相同的text类型字段时, 你应该使用这个helper函数. 举个例子, 在邮箱地址和密码确认等场景下都会有这个需求. 这个校验函数会创建一个虚拟的属性其名字叫做`目标属性名_confirmation`

```ruby
class Person < ApplicationRecord
  validates :email, confirmation: true
end
```

此时在view层你应该如下设定表单

```ruby
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```

上述检查仅会在`email_confirmation`不为空的情况下被执行, 为了让其起作用, 请确保带了presence方法来启用检查


```ruby
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```

还有一个`:case_sensitive`的option可以被选用, 当你需要考虑大小写敏感时可以用, 默认值是true

```ruby
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
```

默认的报错信息是"doesn't match confirmation"

#### 2.4 comparison比较

该helper方法会比较2个可以比较的值, 要求传入比较方式和要比较的内容. 任何类中的属性能被比较的都可以被用上.

```ruby
class Promotion < ApplicationRecord
  validates :start_date, comparison: { greater_than: :end_date }
end
```

比较相关的option如下

- `:greater_than` : 标明校验值必须比提供的的值要大. 默认错误信息是`must be greater than %{count}`
- `:greater_than_or_equal_to` : 标明值必须要大于或者等于提供的值. 默认错误信息是`must be greater than or equal to %{count}`
- `:equal_to` : 标明值必须等于提供的值. 默认错误信息是`must be equal to %{count}`
- `:less_than` : 标明值必须小于提供的值. 默认错误信息是`must be less than %{count}` 
- `:less_than_or_equal_to` : 标明值必须小于或者等于提供的值. 默认错误信息是`must be less than or equal to %{count}`
- `:other_than` : 标明值必须不同于提供的值, 默认错误信息是`must be other than %{count}`

#### 2.5 exclusion排除

该helper方法会校验值是否不在给定的设定值里, 设定值可以无限多.

```ruby
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w[www us ca jp], message: "%{value} is reserved." }
end
```

`exclusion` helper拥有一个option为`:in`用于表示在目标set里的值将不会通过校验. `:in` option 还有个孪生用法叫做 `:within`, 该方法用法和`:in`一摸一样. 而上面的 `:message` option则表达了你应该如何去修改传入的值. 所有关于message的设定可以看[这里](https://guides.rubyonrails.org/active_record_validations.html#message).

默认错误信息为`is reserved`

#### 2.6 format格式


