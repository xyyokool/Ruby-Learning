### 账号激活功能

#### 业务逻辑

1. 给users表新增`unactivated`字段, 用于区分未激活与激活账号
2. 当用户注册后, 生成激活用的token以及对应服务器需要拿来识别的digest
3. 保存激活用的digest到db, 之后发送邮件到用户填写的邮箱, 邮件内容里的link包括了激活用的token
4. 当用户点击link之后, 通过email address来查找用户, 并使用生成的识别digest来校验token
5. 如果授权成功, 则将用户的`unactivated`更新为`activated`

本部分主要会涉及到校验和rails的邮件发送功能的使用

#### 账号激活 resource

> controller

账号激活功能可以单独开一个RESTFUL风格的资源来进行管理. 至于原因, 则是因为账号激活可以作为单独的逻辑来进行处理.

执行命令创建Restful的 controller

`rails g controller AccountActivations`

然后在routes里记得加上resources标记, 让rails server能转发请求

```ruby
  resources :account_activations, only: [:edit]
```

> model

准备好controller后就可以开始着手准备model了, 为了防止骇客攻击数据库窃取信息, 因此对于activation_token的保存, 也应该类似于password, 使用activation_digest的形式进行保存, 以提高安全性.

基于此, users新表结构如下

field | datatype
---|---
id | integer
name | string
email | string
created_at | datetime
updated_at | datetime
password_digest | string
remember_digest | string
admin | boolean
activation_digest | string
activated | boolean
activated_at | datetime

执行命令来给users表新增一下需要的字段(注意这里因为项目复用的问题所以还是guests表哈)

`rails g migration add_activation_to_guests activation_digest:string activated:boolean activated_at:datetime`

之后会生成如下代码

```ruby
class AddActivationToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :activation_diest, :string
    add_column :guests, :activated, :boolean, default: false
    add_column :guests, :activated_at, :datetime
  end
end
```

再执行 `rails db:migrate` 完成db的migrate动作

> 激活token的callback

model层有很多的勾子方法能够帮助我们在执行model操作之前做一些事情, 这些model层的钩子除了校验之外, 还能起到很多CRUD的前置操作, 见如下代码

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token, :activation_token\
  before_save { email.downcase! }
  before_create :create_activation_digest
  ...

  # 这些校验方法都不要暴露出去
  private

  def downcase_email
    self.email = email.downcase
  end

  def create_activation_digest
    self.activation_token = Guest.new_token
    self.activation_digest = Guest.digest(activation_token)
  end
  
end
```

之后在seeds里创建一些假数据来进行测试看看

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar',
              # 这里字段新增
              activated: true,
              activated_at: Time.zone.new,
              admin: true)

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                # 这里字段新增
                activated: true,
                activated_at: Time.zone.new,
                password_confirmation: password)
end
```

记得所有test的数据都只能从fixtures里拿

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  activated: true
  activated_at: <%= Time.zone.now %>
  admin: true
```

然后重置数据库,重新把带了新字段的假数据插到qa里试试

`rails db:migrate:reset    rails db:seed`

#### 账号激活邮件

rails自带邮件发送的功能, 该邮件功能能通过内置的Action Mailer Library来完成, 而邮件的模版,则会使用erb文件.

使用命令来创建邮件模版

`rails generate mailer GuestMailer account_activation password_reset`

上述命令会在mailers里生成一个mailer文件同时还会修改application_mailer文件, 此外会在views中产生account_activation,password_reset各2个邮件模版, 格式分别是text和html. 文件内容如下

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end
```

```ruby
# html.erb
<h1>Guest#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/guest_mailer/account_activation.html.erb
</p>

# text.erb
Guest#account_activation

<%= @greeting %>, find me in app/views/guest_mailer/account_activation.text.erb
```

为了实现激活邮件发送, 我们先动手修改一下生成的模版, 添加一些必要的内容

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation(guest)
    @guest = guest
    mail to: guest.email,  subject: 'Account Activation'
  end
  ...
end
```

激活链接需要包含email与即时生成的token. 链接例子如下

` http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit`

上面链接中一堆看不懂的就是base64加密后的内容, 整个链接能起到的内容和

`http://www.example.com/users/1/edit` 一样. 

实现上述逻辑的关键,是 ` edit_account_activation_url(@user.activation_token, ...)` 能回调`edit_user_url(user)`

为了实现此功能, 激活链接后面的部分需要加上查询参数以确认用户

`account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com`

此时当用户点击上述链接, 则方法可以通过query parameter的params[:email]来拿到参数. 并且注意上述foo%40的部分,%40是转义后的内容

之后修改email部分模版内容

```ruby
<h1>Sample App</h1>
<p>Hi <%= @user.name %>,</p>
<p>
Welcome to the Sample App! Click on the link below to activate your account: </p>
<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>
```

#### 邮件预览与测试

rails提供了邮件发送的预览功能, 首先需要在config里先配置一下环境信息

```ruby
# config/environments/development.rb
# 增加以下内容, host改为服务器地址
  host = 'localhost:3000'
  config.action_mailer.default_url_options = { host: host, protocol: 'https' }
```

然后preview走一下,可以在`http://localhost:3000/rails/mailers/guest_mailer/account_activation`查看到邮件渲染出来的模版.

```ruby
# Preview all emails at http://localhost:3000/rails/mailers/guest_mailer
class GuestMailerPreview < ActionMailer::Preview
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/account_activation
  def account_activation
    guest = Guest.first
    guest.activation_token = Guest.new_token
    GuestMailer.account_activation(guest)
  end

  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    GuestMailer.password_reset
  end
end
```

preview没问题的话记得跑测试

```ruby
class GuestMailerTest < ActionMailer::TestCase
  test "account_activation" do
    guest = guests(:michael)
    guest.activation_token = Guest.new_token
    mail = GuestMailer.account_activation(guest)
    assert_equal "Account Activation", mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ["noreply@example.com"], mail.from 
    assert_match guest.name, mail.body.encoded 
    assert_match guest.activation_token, mail.body.encoded 
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
  ...
end

# 还需要添加environment下的test环境下面语句
# 这样就能在测试环境里设定发送邮件的默认尾缀为@example.com
  config.action_mailer.default_url_options = { host: 'example.com' }
```

#### 完成激活功能

> 更新create action

修正之前用户sign up后会直接跳转到profile页面, 中间加入邮件激活功能, 代码修改为如下内容

```ruby
  def create
    @guest = Guest.new(guest_params)
    if @guest.save
      GuestMailer.account_activation(@guest).deliver_now
      flash[:info] = "Please check your email to activate your account"
      redirect_to root_url
    else
      render 'new'
    end
```

> edit启用账号激活

这里需要用到ruby的一个特性`元编程(metaprogramming)`, 该特性的一个关键特点是能够使用对象内置的`send`方法来动态获取对象内部的任何属性. 比如

```ruby
a = [1,2,3,4,5]
# 常规来说, 获取数组长度
a.length # -> 5
# 使用元编程, 则
a.send(:length) # -> 5
```

基于上述认识, 可以来改写`authenticated?`方法, 让其具有能够解析带token的url的能力

```ruby
# model/guest.rb, 原
  def authenticated?(remember_token)
    return false if remember_digest.nil?

    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
# 改写后

  def authenticated?(attribute, token)
  # 此处send等价于self.send, 只要处在model对象内,就能省略self
    digest = send("#{attribute}_digest")
    return false if digest.nil?
    BCrypt::Password.new(digest).is_password?(token)
  end
```

之后修改一下session_helper.rb里用到了该方法的地方

```ruby
  def current_guest
    if (guest_id = session[:guest_id])
      @current_guest ||= Guest.find_by(id: cookies.encrypted[:guest_id])
    elsif (guest_id = cookies.encrypted[:guest_id])
      guest = Guest.find_by(id: guest_id)
      # 修改了这里
      if guest&.authenticated?(:remember, cookies[:remember_token])
        log_in guest
        @current_guest = guest
      end
    end
  end
```

然后我们在新增的用于账号激活的controller里新增edit方法以用来处理激活

```ruby
class AccountActivationsController < ApplicationController
  def edit
  # 先找到guest
    guest = Guest.find_by(email: params[:email])
    # 如果guest存在,同时没激活有授权, 则 更新激活属性
    if guest && !guest.activated? && guest.authenticated?(:activation, params[:id])
      guest.update_attribute(:activated, true)
      guest.update_attribute(:activated_at, Time.zone.now)
      log_in guest
      flash[:success] = "Account activated!"
      # 激活完毕,返回主页
      redirect_to guest
    else
      flash[:danger] = "Invalid activation link"
      redirect_to root_url
    end
  end
end
```

最后再来修改一下session_controller里用户创建成功时的逻辑

```ruby
  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    if guest&.authenticate(params[:session][:password])
    # 增加了这里, 用于处理用户激活功能
      if guest.activated?
        log_in guest
        # rails提供的重定向方法, 会自动转成 guest_url(guest)
        params[:session][:remember_me] == '1' ? remember(guest) : forget(guest)
        remember guest
        # redirect_back_or guest
        redirect_to guest
      else
        message = 'Account not activated.'
        message += 'Check your email for the activation link.'
        flash[:warning] = message
      end
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end
```

#### 邮件整合测试

```ruby
require 'test_helper'
class UsersSignupTest < ActionDispatch::IntegrationTest
def setup 
  ActionMailer::Base.deliveries.clear
end

test "invalid signup information" do 
  get signup_path
  assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password: "foo",
                                         password_confirmation: "bar" } }  
  end
  assert_template 'users/new' 
  assert_select 'div#error_explanation' 
  assert_select 'div.field_with_errors'
end


test "valid signup information with account activation" do 
  get signup_path
  assert_difference 'User.count', 1 do
    post users_path, params: { user: { name: "Example User", 
                                       email: "user@example.com",
                                       password:              "password",
                                       password_confirmation: "password" } }
  end
  assert_equal 1, ActionMailer::Base.deliveries.size 
  user = assigns(:user)
  assert_not user.activated?
  # Try to log in before activation.
  log_in_as(user)
  assert_not is_logged_in?
  # Invalid activation token
  get edit_account_activation_path("invalid token", email: user.email) 
  assert_not is_logged_in?
  # Valid token, wrong email
  get edit_account_activation_path(user.activation_token, email: 'wrong')
  assert_not is_logged_in?
      # Valid activation token
  get edit_account_activation_path(user.activation_token, email: user.email) 
  assert user.reload.activated?
  follow_redirect!
  assert_template 'users/show'
  assert is_logged_in?
  end 
end
```

#### 生产环境中的email

1. 需要能发送邮件的服务器.(heroku有sendGrid好像能每天免费发400封)
2. 之后在config/environments/production.rb里配置发送的host
3. 账号密码通过环境变量来获取, 不配置在本地.
具体设定代码下面还有

#### 该部分总结

1. 和sessions功能一样, 账号激活功能也可以被当作一种resource来处理(在routes.rb内为resource), 而不是一个ActiveRecord的对象.
2. rails可以生成ActionMailer的actions与views,并能用来发送邮件.
3. Action Mailer支持纯文本和HTML2种邮件格式.
4. 被定义在mailer的actions里的实例变量在mailer的views中是可随时被调用的.
5. 账号激活功能使用一个生成的token来创建唯一的URL以让用户激活.
6. 账号激活功能使用hash的activation_digest来确保校验有效的激活请求(即给到用户的token本身是密中密,直接破解不可能).
7. 功能测试与e2e测试对于校验mailer功能的正确性非常重要.
8. 生产环境可以使用`SendGrid`来发送邮件.

### 密码重置功能

需求场景

1. 当用户请求密码重置, 通过用户提交的email地址来找到用户信息
2. 如果email地址在数据库中存在, 则生成一个重置用的token与其对应的digest
3. 保存重置用的digest到数据库, 之后邮件发送给用户重置用的token
4. 当用户点击链接时, 通过email查找用户, 并匹配token和数据库里的digest是否匹配, 如果匹配则授权用户
5. 如果用户已授权, 则展现密码修改的表单给到用户.

#### 密码重置resource

密码重置不应该关联任何AcitveRecord的model, 应该作为一个独立的功能, 因此应该作为一个resource, 以REST URLs的形式进行功能上的交互. 在这里我们只需要`edit`和`new`两个功能用来展示修改密码的页面和进行修改动作.

> 配置controller

首先是生成用于匹配密码重置resource的controller, 执行如下命令

`rails generate controller PasswordResets new edit --no-test-framework`

之后是配置routes.rb,设定resource对应的controller

```ruby
# 只要这4个资源, 记得默认resources是带7个资源吗
  resources :password_resets, only: [:new, :create, :update, :edit]
# 上述4个分别对应, 注意链接别名都是action_password_reset_path
# GET  ->  /password_resets/new -> new -> new_password_reset_path
# POST ->  /password_resets -> create -> password_resets_path
# GET -> /password_resets/<token>/edit -> edit -> edit_password_reset_url(token)
# PATCH -> /password_resets/<token> -> update -> password_reset_path(token)
```

之后在页面登录的位置加上新的链接

```ruby
<%= link_to "(forgot password)", new_password_reset_path %>
```

> 新密码重置

为了实现密码重置功能, 我们需要给目标model新增密码重置用的digest字段, 以便能安全的对用户进行密码重置工作.

一定要注意, 在rails中任何敏感信息都应该使用digest来代替直接校验和保存密码.

同时,密码重置的链接应该考虑加上过期时间, 这也就要求给目标model得再加上`reset_sent_at`字段来标记邮件发送时间.

执行如下命令来先新增几个字段

`rails g migration add_reset_to_guests reset_digest:string reset_sent_at:datetime`

```ruby
class AddResetToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :reset_digest, :string
    add_column :guests, :reset_sent_at, :datetime
  end
end
```

再执行 `rails db:migrate` 进行写入动作.

之后搞一个页面给重置密码用的

```ruby
<% provide(:title, "Forgot password") %> 
<h1>Forgot password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(url: password_resets_path, scope: :password_reset, local: true) do |f| %>
<%= f.label :email %>
<%= f.email_field :email, class: 'form-control' %>
<%= f.submit "Submit", class: "btn btn-primary" %> <% end %>
</div> 
</div>
```

> create action

基于最开始对重置密码的逻辑, 可以给controller添加create action

```ruby
  def create
    @guest = Guest.find_by(email: params[:password_reset][:email].downcase)
    if @guest
      @guest.create_reset_digest
      @guest.send_password_reset_email
      flash[:info] = "Email sent with password reset instructions"
      redirect_to root_url
    else
      flash.now[:danger] = "Email address not found"
      render 'new'
    end
```

从上面的代码中可以看到, 需要2个方法`create_reset_digest`与`send_password_reset_email`, 之后去model里添加, 

```ruby
# 增加取出记录的 :reset_token 字段, 用于校验
  attr_accessor :remember_token, :activation_token, :reset_token

# 添加对应方法
  def create_reset_digest
    # 为对象生成一个token
    self.reset_token = Guest.new_token
    # digest后更新到数据库
    update_attribute(:reset_digest, Guest.digest(reset_token))
    # 更新邮件发送时间
    update_attribute(:reset_sent_at, Time.zone.new)
  end
  
  def send_password_reset_email
    # 执行重置邮件发送逻辑
    GuestMailer.password_reset(self).deliver_now
  end
```

#### 密码重置邮件

先到mailers/guest_mailer.rb填充之前创建的用于发送邮件的方法

```ruby
  def password_reset(guest)
    @guest = guest
    mail to: guest.email, subject: 'Password reset'
  end
```

之后改一下邮件模版

```ruby
# text
To reset your password click the link below:
<%= edit_password_reset_url(@user.reset_token, email: @user.email) %>
This link will expire in two hours.
If you did not request your password to be reset, please ignore this email and your password will stay as it is.

# html
<h1>Password reset</h1>
<p>To reset your password click the link below:</p>
<%= link_to "Reset password", edit_password_reset_url(@user.reset_token, email: @user.email) %>
<p>This link will expire in two hours.</p>
<p>
If you did not request your password to be reset, please ignore this email and your password will stay as it is.
</p>
```

然后就可以到test/mailers/previews/guest_mailer_preview.rb里新增如下方法, 进行邮件预览了

```ruby
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    guest = Guest.first
    guest.reset_token = Guest.new_token
    GuestMailer.password_reset(guest)
  end
```

> 邮件测试

功能完成后记得写test case.

```ruby
require 'test_helper'

class GuestMailerTest < ActionMailer::TestCase
  ...
  test 'password_reset' do
    guest = guests(:michael)
    guest.reset_token = Guest.new_token
    mail = GuestMailer.password_reset(guest)
    assert_equal 'Password reset', mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ['noreply@example.com'], mail.from
    # 只要字符串有, 匹配到就行
    assert_match guest.reset_token, mail.body.encoded
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
end
```

之后执行命令`rails test`来跑全部的测试, 或者执行`rails test:mailers`来指定只跑mailers文件夹内的测试

#### 重置密码

现在来新增`edit`这个方法, 用来执行跳转到修改页面的逻辑

> 重置edit action

密码重置邮件里的链接长这样

`https://localhost:3000/password_resets/8vP9pJb_a4FB4tBzMHvUrQ/edit?email=example%40rails.com`

为了让这个链接工作起来, 我们需要一个表单来让这个链接能跳转过去(注意这个链接的组成格式和之前是一样的,rails都会自动识别并当作edit方法来处理)

表单提交有一个默认行为是会清空表单数据, 为了避免这个行为, 可以在view模版里添加下面的内容

```ruby
      <%= hidden_field_tag :email, @user.email %>
```

然后修改对应的view模版如下

```ruby
<% provide(:title, 'Reset password') %> <h1>Reset password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(model: @user, url: password_reset_path(params[:id]), local: true) do |f| %>
      <%= render 'shared/error_messages' %>
      <%= hidden_field_tag :email, @user.email %>
<%= f.label :password %>
<%= f.password_field :password, class: 'form-control' %>
<%= f.label :password_confirmation, "Confirmation" %>
<%= f.password_field :password_confirmation, class: 'form-control' %>
<%= f.submit "Update password", class: "btn btn-primary" %> <% end %>
</div> </div>
```
修改密码时,肯定是希望数据已经被挂好了放在页面的输入框上的, 此时就需要用到controller里的filters了

```ruby
class PasswordResetsController < ApplicationController
# 拿到前端给的参数后, 会在执行指定的action之前调用
  before_action :get_guest, only: %i[edit update]
  before_action :valid_guest, only: %i[edit update]

  ...

  private

  def get_guest
    @guest = Guest.find_by(email: params[:email])
  end

  # 如果用户不存在, 未激活, 未授权则返回到根目录
  def valid_guest
    # params[:id] 会拿到前端传递的token
    redirect_to root_url unless @guest &&@guest.activated? && @guest.authenticated?(:reset, params[:id])
  end
end
```

> update方法

在能成功通过链接跳转到edit方法对应的表单后, 需要做的就是增加提交用的方法了, 此方法需要考虑以下几种情况

1. 超过了设定时间的密码重置怎么办?
2. 无效密码更新怎么办?
3. 空密码更新怎么办?
4. 成功更新密码

基于以上Cases, 来对controller代码做对应的变动. 首先是要加上新的filter来判断超时, 然后再在update方法里增加判断逻辑.

```ruby
class PasswordResetsController < ApplicationController
  before_action :check_expiration, only: %i[edit update]
  ...
  def update
    # 如果密码为空则往model对象里加error,加了就不是valid的了
    if params[:guest][:password].empty?
      @guest.errors.add(:password, "can't be empty")
      render 'edit'
    elsif @guest.update(guest_params)
      log_in @guest
      flash[:success] = "Password has been reset"
      redirect_to @guest
    else
      render 'edit'
    end
  end

  private
  # 只要是表单, 一定有严格参数模式
  def guest_params
    params.require(:guest).permit(:password, :password_confirmation)
  end

  def check_expiration
    # 该model方法新增, 到model层去加
    if @guest.password_reset_expired?
      flash[:danger] = 'Password reset has expired'
      redirect_to new_password_reset_url
    end
  end
end
```

Guest的model增加一个controller需要的校验方法

```ruby
  def password_reset_expired?
    reset_sent_at < 2.hours.ago
  end
```

> 密码重置测试

基于上述的内容, 基本完成了密码重置功能, 接下来开始写测试, 首先执行命令生成E2E测试(因为涉及到了view的交互)

`rails g integration_test password_resets`

E2E代码如下

```ruby
require 'test_helper'

class PasswordResetsTest < ActionDispatch::IntegrationTest
  def setup
    ActionMailer::Base.deliveries.clear
    @guest = guests(:michael)
  end

  test 'password resets' do
    # 1. 用户点击忘记密码后
    get new_password_reset_path
    assert_template 'password_resets/new'
    assert_select 'input[name=?]', 'password_reset[email]'
    # 2.1 无效的邮件
    post password_resets_path, params: { password_reset: { email: '' } }
    assert_not flash.empty?
    assert_template 'password_resets/new'
    # 2.2 有效的邮件
    post password_resets_path, params: { password_reset: { email: @guest.email } }
    assert_not_equal @guest.reset_digest, @guest.reload.reset_digest
    assert_equal 1, ActionMailer::Base.deliveries.size
    assert_not flash.empty?
    assert_redirected_to root_url
    # 3. 当通过邮件跳转时
    guest = assigns(:guest)
    # 3.1 如果邮件地址错误
    get edit_password_reset_path(guest.reset_token, email: '')
    assert_redirected_to root_url
    # 3.2 如果是未激活的用户
    guest.toggle!(:activated)
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_redirected_to root_url
    guest.toggle!(:activated)
    # 3.3 如果是正确的email, 错误的token
    get edit_password_reset_path('wrong token', email: guest.email)
    assert_redirected_to root_url
    # 3.4 如果是正确的email, 正确的token
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_template 'password_resets/edit'
    assert_select 'input[name=email][type=hidden][value=?]', guest.email
    # 4.1 此时填写的如果是无效的密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foobaz', password_confirmation: 'barqqq' } }
    assert_select 'div#error_explanation'
    # 4.2 如果填写的是空密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: '', password_confirmation: '' } }
    assert_select 'div#error_explanation'
    # 4.3 如果密码有效
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foofoo', password_confirmation: 'foofoo' } }
    assert is_logged_in?
    assert_not flash.empty?
    assert_redirected_to guest
  end
end
```

#### 生产环境的邮件

生产环境邮件发送需要做的事情.

1. 找到config/enviroments/production.rb
2. 配置生产环境smtp邮件服务器相关代码

```ruby
Rails.application.configure do
...
  config.action_mailer.perform_caching = false
  config.action_mailer.raise_delivery_errors = true
  config.action_mailer.delivery_method = :smtp
  # from发送方地址
  host = 'noreply@abc.com'
  config.action_mailer.default_url_options = { host: host }
  ActionMailer::Base.smtp_settings = {
    :address        => 'smtp.sendgrid.net',
    :port           => '587',
    :authentication => :plain,
    :user_name      => ENV['SENDGRID_USERNAME'],
    :password       => ENV['SENDGRID_PASSWORD'],
    :domain         => 'heroku.com',
    :enable_starttls_auto => true
  }
end
```

#### 功能总结

1. 和sessions与账号激活功能一样, 密码重置也能被当作resources来处理, 而不用绑定为ActiveRecord对象
2. rails可以生成ActionMailer的actions,并且能预览要发送的邮件
3. ActionMailer支持纯本文和html格式
4. 定义在mailerAction里的变量在mailer的views里可用
5. 密码重置功能使用生成token创建唯一URL来重置密码
6. 密码重置功能使用一个哈希的reset_digest来确保token没被伪造
7. E2E测试很重要, 一定要写
8. 生产环境可以用SendGrid发送邮件

### 用户发推功能

#### 推文Model
