### 账号激活功能

#### 业务逻辑

1. 给users表新增`unactivated`字段, 用于区分未激活与激活账号
2. 当用户注册后, 生成激活用的token以及对应服务器需要拿来识别的digest
3. 保存激活用的digest到db, 之后发送邮件到用户填写的邮箱, 邮件内容里的link包括了激活用的token
4. 当用户点击link之后, 通过email address来查找用户, 并使用生成的识别digest来校验token
5. 如果授权成功, 则将用户的`unactivated`更新为`activated`

本部分主要会涉及到校验和rails的邮件发送功能的使用

#### 账号激活 resource

> controller

账号激活功能可以单独开一个RESTFUL风格的资源来进行管理. 至于原因, 则是因为账号激活可以作为单独的逻辑来进行处理.

执行命令创建Restful的 controller

`rails g controller AccountActivations`

然后在routes里记得加上resources标记, 让rails server能转发请求

```ruby
  resources :account_activations, only: [:edit]
```

> model

准备好controller后就可以开始着手准备model了, 为了防止骇客攻击数据库窃取信息, 因此对于activation_token的保存, 也应该类似于password, 使用activation_digest的形式进行保存, 以提高安全性.

基于此, users新表结构如下

field | datatype
---|---
id | integer
name | string
email | string
created_at | datetime
updated_at | datetime
password_digest | string
remember_digest | string
admin | boolean
activation_digest | string
activated | boolean
activated_at | datetime

执行命令来给users表新增一下需要的字段(注意这里因为项目复用的问题所以还是guests表哈)

`rails g migration add_activation_to_guests activation_digest:string activated:boolean activated_at:datetime`

之后会生成如下代码

```ruby
class AddActivationToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :activation_diest, :string
    add_column :guests, :activated, :boolean, default: false
    add_column :guests, :activated_at, :datetime
  end
end
```

再执行 `rails db:migrate` 完成db的migrate动作

> 激活token的callback

model层有很多的勾子方法能够帮助我们在执行model操作之前做一些事情, 这些model层的钩子除了校验之外, 还能起到很多CRUD的前置操作, 见如下代码

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token, :activation_token\
  before_save { email.downcase! }
  before_create :create_activation_digest
  ...

  # 这些校验方法都不要暴露出去
  private

  def downcase_email
    self.email = email.downcase
  end

  def create_activation_digest
    self.activation_token = Guest.new_token
    self.activation_digest = Guest.digest(activation_token)
  end
  
end
```

之后在seeds里创建一些假数据来进行测试看看

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar',
              # 这里字段新增
              activated: true,
              activated_at: Time.zone.new,
              admin: true)

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                # 这里字段新增
                activated: true,
                activated_at: Time.zone.new,
                password_confirmation: password)
end
```

记得所有test的数据都只能从fixtures里拿

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  activated: true
  activated_at: <%= Time.zone.now %>
  admin: true
```

然后重置数据库,重新把带了新字段的假数据插到qa里试试

`rails db:migrate:reset    rails db:seed`

#### 账号激活邮件

rails自带邮件发送的功能, 该邮件功能能通过内置的Action Mailer Library来完成, 而邮件的模版,则会使用erb文件.

使用命令来创建邮件模版

`rails generate mailer GuestMailer account_activation password_reset`

上述命令会在mailers里生成一个mailer文件同时还会修改application_mailer文件, 此外会在views中产生account_activation,password_reset各2个邮件模版, 格式分别是text和html. 文件内容如下

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end
```

```ruby
# html.erb
<h1>Guest#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/guest_mailer/account_activation.html.erb
</p>

# text.erb
Guest#account_activation

<%= @greeting %>, find me in app/views/guest_mailer/account_activation.text.erb
```

为了实现激活邮件发送, 我们先动手修改一下生成的模版, 添加一些必要的内容

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation(guest)
    @guest = guest
    mail to: guest.email,  subject: 'Account Activation'
  end
  ...
end
```

激活链接需要包含email与即时生成的token. 链接例子如下

` http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit`

上面链接中一堆看不懂的就是base64加密后的内容, 整个链接能起到的内容和

`http://www.example.com/users/1/edit` 一样. 

实现上述逻辑的关键,是 ` edit_account_activation_url(@user.activation_token, ...)` 能回调`edit_user_url(user)`

为了实现此功能, 激活链接后面的部分需要加上查询参数以确认用户

`account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com`

此时当用户点击上述链接, 则方法可以通过query parameter的params[:email]来拿到参数. 并且注意上述foo%40的部分,%40是转义后的内容

之后修改email部分模版内容

```ruby
<h1>Sample App</h1>
<p>Hi <%= @user.name %>,</p>
<p>
Welcome to the Sample App! Click on the link below to activate your account: </p>
<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>
```

#### 邮件预览与测试

rails提供了邮件发送的预览功能, 首先需要在config里先配置一下环境信息

```ruby
# config/environments/development.rb
# 增加以下内容, host改为服务器地址
  host = 'localhost:3000'
  config.action_mailer.default_url_options = { host: host, protocol: 'https' }
```

然后preview走一下,可以在`http://localhost:3000/rails/mailers/guest_mailer/account_activation`查看到邮件渲染出来的模版.

```ruby
# Preview all emails at http://localhost:3000/rails/mailers/guest_mailer
class GuestMailerPreview < ActionMailer::Preview
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/account_activation
  def account_activation
    guest = Guest.first
    guest.activation_token = Guest.new_token
    GuestMailer.account_activation(guest)
  end

  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    GuestMailer.password_reset
  end
end
```

preview没问题的话记得跑测试

```ruby
class GuestMailerTest < ActionMailer::TestCase
  test "account_activation" do
    guest = guests(:michael)
    guest.activation_token = Guest.new_token
    mail = GuestMailer.account_activation(guest)
    assert_equal "Account Activation", mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ["noreply@example.com"], mail.from 
    assert_match guest.name, mail.body.encoded 
    assert_match guest.activation_token, mail.body.encoded 
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
  ...
end

# 还需要添加environment下的test环境下面语句
# 这样就能在测试环境里设定发送邮件的默认尾缀为@example.com
  config.action_mailer.default_url_options = { host: 'example.com' }
```

#### 完成激活功能

> 更新create action

修正之前用户sign up后会直接跳转到profile页面, 中间加入邮件激活功能, 代码修改为如下内容

```ruby
  def create
    @guest = Guest.new(guest_params)
    if @guest.save
      GuestMailer.account_activation(@guest).deliver_now
      flash[:info] = "Please check your email to activate your account"
      redirect_to root_url
    else
      render 'new'
    end
```

> edit启用账号激活

这里需要用到ruby的一个特性`元编程(metaprogramming)`, 该特性的一个关键特点是能够使用对象内置的`send`方法来动态获取对象内部的任何属性. 比如

```ruby
a = [1,2,3,4,5]
# 常规来说, 获取数组长度
a.length # -> 5
# 使用元编程, 则
a.send(:length) # -> 5
```

基于上述认识, 可以来改写`authenticated?`方法, 让其具有能够解析带token的url的能力

```ruby
# model/guest.rb, 原
  def authenticated?(remember_token)
    return false if remember_digest.nil?

    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
# 改写后

  def authenticated?(attribute, token)
  # 此处send等价于self.send, 只要处在model对象内,就能省略self
    digest = send("#{attribute}_digest")
    return false if digest.nil?
    BCrypt::Password.new(digest).is_password?(token)
  end
```

之后修改一下session_helper.rb里用到了该方法的地方

```ruby
  def current_guest
    if (guest_id = session[:guest_id])
      @current_guest ||= Guest.find_by(id: cookies.encrypted[:guest_id])
    elsif (guest_id = cookies.encrypted[:guest_id])
      guest = Guest.find_by(id: guest_id)
      # 修改了这里
      if guest&.authenticated?(:remember, cookies[:remember_token])
        log_in guest
        @current_guest = guest
      end
    end
  end
```

然后我们在新增的用于账号激活的controller里新增edit方法以用来处理激活

```ruby
class AccountActivationsController < ApplicationController
  def edit
  # 先找到guest
    guest = Guest.find_by(email: params[:email])
    # 如果guest存在,同时没激活有授权, 则 更新激活属性
    if guest && !guest.activated? && guest.authenticated?(:activation, params[:id])
      guest.update_attribute(:activated, true)
      guest.update_attribute(:activated_at, Time.zone.now)
      log_in guest
      flash[:success] = "Account activated!"
      # 激活完毕,返回主页
      redirect_to guest
    else
      flash[:danger] = "Invalid activation link"
      redirect_to root_url
    end
  end
end
```

最后再来修改一下session_controller里用户创建成功时的逻辑

```ruby
  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    if guest&.authenticate(params[:session][:password])
    # 增加了这里, 用于处理用户激活功能
      if guest.activated?
        log_in guest
        # rails提供的重定向方法, 会自动转成 guest_url(guest)
        params[:session][:remember_me] == '1' ? remember(guest) : forget(guest)
        remember guest
        # redirect_back_or guest
        redirect_to guest
      else
        message = 'Account not activated.'
        message += 'Check your email for the activation link.'
        flash[:warning] = message
      end
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end
```

#### 邮件整合测试

```ruby
require 'test_helper'
class UsersSignupTest < ActionDispatch::IntegrationTest
def setup 
  ActionMailer::Base.deliveries.clear
end

test "invalid signup information" do 
  get signup_path
  assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password: "foo",
                                         password_confirmation: "bar" } }  
  end
  assert_template 'users/new' 
  assert_select 'div#error_explanation' 
  assert_select 'div.field_with_errors'
end


test "valid signup information with account activation" do 
  get signup_path
  assert_difference 'User.count', 1 do
    post users_path, params: { user: { name: "Example User", 
                                       email: "user@example.com",
                                       password:              "password",
                                       password_confirmation: "password" } }
  end
  assert_equal 1, ActionMailer::Base.deliveries.size 
  user = assigns(:user)
  assert_not user.activated?
  # Try to log in before activation.
  log_in_as(user)
  assert_not is_logged_in?
  # Invalid activation token
  get edit_account_activation_path("invalid token", email: user.email) 
  assert_not is_logged_in?
  # Valid token, wrong email
  get edit_account_activation_path(user.activation_token, email: 'wrong')
  assert_not is_logged_in?
      # Valid activation token
  get edit_account_activation_path(user.activation_token, email: user.email) 
  assert user.reload.activated?
  follow_redirect!
  assert_template 'users/show'
  assert is_logged_in?
  end 
end
```

#### 生产环境中的email

1. 需要能发送邮件的服务器.(heroku有sendGrid好像能每天免费发400封)
2. 之后在config/environments/production.rb里配置发送的host
3. 账号密码通过环境变量来获取, 不配置在本地.
具体设定代码下面还有

#### 该部分总结

1. 和sessions功能一样, 账号激活功能也可以被当作一种resource来处理(在routes.rb内为resource), 而不是一个ActiveRecord的对象.
2. rails可以生成ActionMailer的actions与views,并能用来发送邮件.
3. Action Mailer支持纯文本和HTML2种邮件格式.
4. 被定义在mailer的actions里的实例变量在mailer的views中是可随时被调用的.
5. 账号激活功能使用一个生成的token来创建唯一的URL以让用户激活.
6. 账号激活功能使用hash的activation_digest来确保校验有效的激活请求(即给到用户的token本身是密中密,直接破解不可能).
7. 功能测试与e2e测试对于校验mailer功能的正确性非常重要.
8. 生产环境可以使用`SendGrid`来发送邮件.

### 密码重置功能

需求场景

1. 当用户请求密码重置, 通过用户提交的email地址来找到用户信息
2. 如果email地址在数据库中存在, 则生成一个重置用的token与其对应的digest
3. 保存重置用的digest到数据库, 之后邮件发送给用户重置用的token
4. 当用户点击链接时, 通过email查找用户, 并匹配token和数据库里的digest是否匹配, 如果匹配则授权用户
5. 如果用户已授权, 则展现密码修改的表单给到用户.

#### 密码重置resource

密码重置不应该关联任何AcitveRecord的model, 应该作为一个独立的功能, 因此应该作为一个resource, 以REST URLs的形式进行功能上的交互. 在这里我们只需要`edit`和`new`两个功能用来展示修改密码的页面和进行修改动作.

> 配置controller

首先是生成用于匹配密码重置resource的controller, 执行如下命令

`rails generate controller PasswordResets new edit --no-test-framework`

之后是配置routes.rb,设定resource对应的controller

```ruby
# 只要这4个资源, 记得默认resources是带7个资源吗
  resources :password_resets, only: [:new, :create, :update, :edit]
# 上述4个分别对应, 注意链接别名都是action_password_reset_path
# GET  ->  /password_resets/new -> new -> new_password_reset_path
# POST ->  /password_resets -> create -> password_resets_path
# GET -> /password_resets/<token>/edit -> edit -> edit_password_reset_url(token)
# PATCH -> /password_resets/<token> -> update -> password_reset_path(token)
```

之后在页面登录的位置加上新的链接

```ruby
<%= link_to "(forgot password)", new_password_reset_path %>
```

> 新密码重置

为了实现密码重置功能, 我们需要给目标model新增密码重置用的digest字段, 以便能安全的对用户进行密码重置工作.

一定要注意, 在rails中任何敏感信息都应该使用digest来代替直接校验和保存密码.

同时,密码重置的链接应该考虑加上过期时间, 这也就要求给目标model得再加上`reset_sent_at`字段来标记邮件发送时间.

执行如下命令来先新增几个字段

`rails g migration add_reset_to_guests reset_digest:string reset_sent_at:datetime`

```ruby
class AddResetToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :reset_digest, :string
    add_column :guests, :reset_sent_at, :datetime
  end
end
```

再执行 `rails db:migrate` 进行写入动作.

之后搞一个页面给重置密码用的

```ruby
<% provide(:title, "Forgot password") %> 
<h1>Forgot password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(url: password_resets_path, scope: :password_reset, local: true) do |f| %>
<%= f.label :email %>
<%= f.email_field :email, class: 'form-control' %>
<%= f.submit "Submit", class: "btn btn-primary" %> <% end %>
</div> 
</div>
```

> create action

基于最开始对重置密码的逻辑, 可以给controller添加create action

```ruby
  def create
    @guest = Guest.find_by(email: params[:password_reset][:email].downcase)
    if @guest
      @guest.create_reset_digest
      @guest.send_password_reset_email
      flash[:info] = "Email sent with password reset instructions"
      redirect_to root_url
    else
      flash.now[:danger] = "Email address not found"
      render 'new'
    end
```

从上面的代码中可以看到, 需要2个方法`create_reset_digest`与`send_password_reset_email`, 之后去model里添加, 

```ruby
# 增加取出记录的 :reset_token 字段, 用于校验
  attr_accessor :remember_token, :activation_token, :reset_token

# 添加对应方法
  def create_reset_digest
    # 为对象生成一个token
    self.reset_token = Guest.new_token
    # digest后更新到数据库
    update_attribute(:reset_digest, Guest.digest(reset_token))
    # 更新邮件发送时间
    update_attribute(:reset_sent_at, Time.zone.new)
  end
  
  def send_password_reset_email
    # 执行重置邮件发送逻辑
    GuestMailer.password_reset(self).deliver_now
  end
```

#### 密码重置邮件

先到mailers/guest_mailer.rb填充之前创建的用于发送邮件的方法

```ruby
  def password_reset(guest)
    @guest = guest
    mail to: guest.email, subject: 'Password reset'
  end
```

之后改一下邮件模版

```ruby
# text
To reset your password click the link below:
<%= edit_password_reset_url(@user.reset_token, email: @user.email) %>
This link will expire in two hours.
If you did not request your password to be reset, please ignore this email and your password will stay as it is.

# html
<h1>Password reset</h1>
<p>To reset your password click the link below:</p>
<%= link_to "Reset password", edit_password_reset_url(@user.reset_token, email: @user.email) %>
<p>This link will expire in two hours.</p>
<p>
If you did not request your password to be reset, please ignore this email and your password will stay as it is.
</p>
```

然后就可以到test/mailers/previews/guest_mailer_preview.rb里新增如下方法, 进行邮件预览了

```ruby
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    guest = Guest.first
    guest.reset_token = Guest.new_token
    GuestMailer.password_reset(guest)
  end
```

> 邮件测试

功能完成后记得写test case.

```ruby
require 'test_helper'

class GuestMailerTest < ActionMailer::TestCase
  ...
  test 'password_reset' do
    guest = guests(:michael)
    guest.reset_token = Guest.new_token
    mail = GuestMailer.password_reset(guest)
    assert_equal 'Password reset', mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ['noreply@example.com'], mail.from
    # 只要字符串有, 匹配到就行
    assert_match guest.reset_token, mail.body.encoded
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
end
```

之后执行命令`rails test`来跑全部的测试, 或者执行`rails test:mailers`来指定只跑mailers文件夹内的测试

#### 重置密码

现在来新增`edit`这个方法, 用来执行跳转到修改页面的逻辑

> 重置edit action

密码重置邮件里的链接长这样

`https://localhost:3000/password_resets/8vP9pJb_a4FB4tBzMHvUrQ/edit?email=example%40rails.com`

为了让这个链接工作起来, 我们需要一个表单来让这个链接能跳转过去(注意这个链接的组成格式和之前是一样的,rails都会自动识别并当作edit方法来处理)

表单提交有一个默认行为是会清空表单数据, 为了避免这个行为, 可以在view模版里添加下面的内容

```ruby
      <%= hidden_field_tag :email, @user.email %>
```

然后修改对应的view模版如下

```ruby
<% provide(:title, 'Reset password') %> <h1>Reset password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(model: @user, url: password_reset_path(params[:id]), local: true) do |f| %>
      <%= render 'shared/error_messages' %>
      <%= hidden_field_tag :email, @user.email %>
<%= f.label :password %>
<%= f.password_field :password, class: 'form-control' %>
<%= f.label :password_confirmation, "Confirmation" %>
<%= f.password_field :password_confirmation, class: 'form-control' %>
<%= f.submit "Update password", class: "btn btn-primary" %> <% end %>
</div> </div>
```
修改密码时,肯定是希望数据已经被挂好了放在页面的输入框上的, 此时就需要用到controller里的filters了

```ruby
class PasswordResetsController < ApplicationController
# 拿到前端给的参数后, 会在执行指定的action之前调用
  before_action :get_guest, only: %i[edit update]
  before_action :valid_guest, only: %i[edit update]

  ...

  private

  def get_guest
    @guest = Guest.find_by(email: params[:email])
  end

  # 如果用户不存在, 未激活, 未授权则返回到根目录
  def valid_guest
    # params[:id] 会拿到前端传递的token
    redirect_to root_url unless @guest &&@guest.activated? && @guest.authenticated?(:reset, params[:id])
  end
end
```

> update方法

在能成功通过链接跳转到edit方法对应的表单后, 需要做的就是增加提交用的方法了, 此方法需要考虑以下几种情况

1. 超过了设定时间的密码重置怎么办?
2. 无效密码更新怎么办?
3. 空密码更新怎么办?
4. 成功更新密码

基于以上Cases, 来对controller代码做对应的变动. 首先是要加上新的filter来判断超时, 然后再在update方法里增加判断逻辑.

```ruby
class PasswordResetsController < ApplicationController
  before_action :check_expiration, only: %i[edit update]
  ...
  def update
    # 如果密码为空则往model对象里加error,加了就不是valid的了
    if params[:guest][:password].empty?
      @guest.errors.add(:password, "can't be empty")
      render 'edit'
    elsif @guest.update(guest_params)
      log_in @guest
      flash[:success] = "Password has been reset"
      redirect_to @guest
    else
      render 'edit'
    end
  end

  private
  # 只要是表单, 一定有严格参数模式
  def guest_params
    params.require(:guest).permit(:password, :password_confirmation)
  end

  def check_expiration
    # 该model方法新增, 到model层去加
    if @guest.password_reset_expired?
      flash[:danger] = 'Password reset has expired'
      redirect_to new_password_reset_url
    end
  end
end
```

Guest的model增加一个controller需要的校验方法

```ruby
  def password_reset_expired?
    reset_sent_at < 2.hours.ago
  end
```

> 密码重置测试

基于上述的内容, 基本完成了密码重置功能, 接下来开始写测试, 首先执行命令生成E2E测试(因为涉及到了view的交互)

`rails g integration_test password_resets`

E2E代码如下

```ruby
require 'test_helper'

class PasswordResetsTest < ActionDispatch::IntegrationTest
  def setup
    ActionMailer::Base.deliveries.clear
    @guest = guests(:michael)
  end

  test 'password resets' do
    # 1. 用户点击忘记密码后
    get new_password_reset_path
    assert_template 'password_resets/new'
    assert_select 'input[name=?]', 'password_reset[email]'
    # 2.1 无效的邮件
    post password_resets_path, params: { password_reset: { email: '' } }
    assert_not flash.empty?
    assert_template 'password_resets/new'
    # 2.2 有效的邮件
    post password_resets_path, params: { password_reset: { email: @guest.email } }
    assert_not_equal @guest.reset_digest, @guest.reload.reset_digest
    assert_equal 1, ActionMailer::Base.deliveries.size
    assert_not flash.empty?
    assert_redirected_to root_url
    # 3. 当通过邮件跳转时
    guest = assigns(:guest)
    # 3.1 如果邮件地址错误
    get edit_password_reset_path(guest.reset_token, email: '')
    assert_redirected_to root_url
    # 3.2 如果是未激活的用户
    guest.toggle!(:activated)
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_redirected_to root_url
    guest.toggle!(:activated)
    # 3.3 如果是正确的email, 错误的token
    get edit_password_reset_path('wrong token', email: guest.email)
    assert_redirected_to root_url
    # 3.4 如果是正确的email, 正确的token
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_template 'password_resets/edit'
    assert_select 'input[name=email][type=hidden][value=?]', guest.email
    # 4.1 此时填写的如果是无效的密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foobaz', password_confirmation: 'barqqq' } }
    assert_select 'div#error_explanation'
    # 4.2 如果填写的是空密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: '', password_confirmation: '' } }
    assert_select 'div#error_explanation'
    # 4.3 如果密码有效
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foofoo', password_confirmation: 'foofoo' } }
    assert is_logged_in?
    assert_not flash.empty?
    assert_redirected_to guest
  end
end
```

#### 生产环境的邮件

生产环境邮件发送需要做的事情.

1. 找到config/enviroments/production.rb
2. 配置生产环境smtp邮件服务器相关代码

```ruby
Rails.application.configure do
...
  config.action_mailer.perform_caching = false
  config.action_mailer.raise_delivery_errors = true
  config.action_mailer.delivery_method = :smtp
  # from发送方地址
  host = 'noreply@abc.com'
  config.action_mailer.default_url_options = { host: host }
  ActionMailer::Base.smtp_settings = {
    :address        => 'smtp.sendgrid.net',
    :port           => '587',
    :authentication => :plain,
    :user_name      => ENV['SENDGRID_USERNAME'],
    :password       => ENV['SENDGRID_PASSWORD'],
    :domain         => 'heroku.com',
    :enable_starttls_auto => true
  }
end
```

#### 功能总结

1. 和sessions与账号激活功能一样, 密码重置也能被当作resources来处理, 而不用绑定为ActiveRecord对象
2. rails可以生成ActionMailer的actions,并且能预览要发送的邮件
3. ActionMailer支持纯本文和html格式
4. 定义在mailerAction里的变量在mailer的views里可用
5. 密码重置功能使用生成token创建唯一URL来重置密码
6. 密码重置功能使用一个哈希的reset_digest来确保token没被伪造
7. E2E测试很重要, 一定要写
8. 生产环境可以用SendGrid发送邮件

### 用户发推功能

#### 推文Model
先来看下最简单的推文表应该有哪些字段

microposts

field | type
--- |---|
id | integer
content | text
user_id | integer
created_at | datetime
updated_at | datetime

可以看到推文必须属于某一个用户, 并当用户炸掉时全部被删除掉.

它仅需要2个字段, 一个是content, 一个是user_id. 当中content使用的是text类型, 能比string存储更多的内容, 并且在生产上性能基本无差异.

之后来生成model, 使用命令

`rails g model Micropost content:text guest:references` 

上述命令会生成如下ActiveRecord的model

```ruby
class Micropost < ApplicationRecord
  # 使用guest:references, 会添加belongs_to
  belongs_to :guest
end
```

并生成如下的migration, 为了优化联表查询, 在这里给user_id和创建时间加一个联合索引

```ruby
class CreateMicroposts < ActiveRecord::Migration[7.0]
  def change
    create_table :microposts do |t|
      t.text :content
      t.references :guest, null: false, foreign_key: true

      t.timestamps
    end
    # 数组形式则是联合索引, 非数组普通symbol则单索引
    add_index :microposts, [:guest_id, :created_at]
  end
end
```

之后执行 `rails db:migrate`来写到数据库, 并可以使用控制台,输入`Micropost.new({content: "abc", guest_id: 1}).save` 来试着插入一条数据, 此时可以再使用`Micropost.first.guest`来直接拿到用户的信息.

也就是说, 创建时references写在哪一个model里, 那个model就是多方, 此时会自动添加上belongs_to, 但是另外的一方,则需要手动添加has_many :xxx来完成对应关系.

#### 增加校验

记得先加上基本的校验
```ruby
class Micropost < ApplicationRecord
  belongs_to :guest
  validates :guest_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

记得测试

```ruby
require "test_helper"

class MicropostTest < ActiveSupport::TestCase
  def setup
    @guest = guests(:michael)
    @micropost = Micropost.new(content: "asdasd", guest_id: @guest.id)
  end

  test 'should be valid' do
    assert @micropost.valid?
  end

  test 'user id should be present' do
    @micropost.guest_id = nil
    assert_not @micropost.valid?
  end

  test 'content should be present' do
    @micropost.content = ''
    assert_not @micropost.valid?
  end

  test 'content should be at most 140 characters' do
    @micropost.content = 'a' * 141
    assert_not @micropost.valid?
  end
end
```

#### 添加associations

如上面的代码所述, 关联关系在创建model时通过references来进行创建, 而many方则需要手动添加has_many来建立关系.

此外, 只有建立了关系后, 才可以从一方通过调用build来构建内容, build方法带缓存, 但是不会存到数据库里, 方便用于测试.而new,create之类的则会和db发生关系,不太合适.

```ruby
# test下的setup方法
  def setup
    @guest = guests(:michael)
    # @micropost = Micropost.new(content: "asdasd", guest_id: @guest.id)
    @micropost = @guest.microposts.build(content: 'Loasd')
  end
```

#### 推文优化

> Default scope

默认情况下, `user.microposts`方法不会保证返回集合的顺序, 但是如果一定要排序的场景下, 就需要往model里面加上SQL语句才能实现. 

`default_scope` 方法就是在model里用于做SQL扩展用的方法, 可以用于设定default order之类的默认功能,如下

```ruby
class Micropost < ApplicationRecord
  ...
  # 这样相当于是设定默认order方法会传递按创建时间降序排序
  # 会在键表的时候起作用, 修改SQL语句配置
  default_scope -> { order(create_at: :desc) }
end
```

上述代码介绍了一种在rails里被叫做`stabby lambda`的语法, 也叫做lambda表达式或者Proc(procedure). 当中的内容被叫做`匿名函数`. 格式为

`The stabby lambda -> takes in a block`

其block内的代码会被`call`方法调用, 比如

```ruby
3.0.0 :001 > -> { puts "foo" }
 => #<Proc:0x00007f7b5caa9e78 (irb):1 (lambda)> 
3.0.0 :002 > -> { puts "foo" }.call
foo
 => nil                                          
```

从上面的代码可以看出, 被 ` -> { }`所包裹的部分是一个完整的代码块,  只要call调用就会执行里面的匿名函数代码.

> destroy

关联关系下, 一个用户如果被destroy, 则关联表里的相关内容都应该被destroy.

为了达成这个效果, 需要在目标model上增加如下代码

```ruby
  has_many :microposts, dependent: :destroy
```

dependent为destroy表示当该model被destroy时,则相关的microposts表里的内容也会被destroy, 这一特性避免了孤儿数据的存在.

可以通过test来验证其确实是做了删除动作

```ruby
  test 'associated microposts should be destroyed' do
    @guest.save
    @guest.micropost.create!(content: "asdasd")
    assert_difference "Micropost.count", -1 do
      @guest.destroy
    end
  end
```

#### 展示推文

先来生成controller吧

`rails g controller Microposts`

然后增加下面的view

```ruby
# _micropost.html.erb
<li id="micropost-<%= micropost.id %>">
<%= link_to gravatar_for(micropost.user, size: 50), micropost.user %>
<span class="user"><%= link_to micropost.user.name, micropost.user %></span> <span class="content"><%= micropost.content %></span>
<span class="timestamp">
Posted <%= time_ago_in_words(micropost.created_at) %> ago. </span>
</li>
```

并且改一下展示用户的方法

```ruby
  def show
    @guest = Guest.find(params[:id])
    @microposts = @guest.microposts.paginate(page: params[:page])
  end
```

同样的改下展示用户时的view

```ruby
  <div class="col-md-8">
  <% if @user.microposts.any? %>
  <h3>Microposts (<%= @user.microposts.count %>)</h3>
      <ol class="microposts">
  <%= render @microposts %>
  </ol>
  <%= will_paginate @microposts %> <% end %>
  </div>
```

> 添加测试microposts数据

关联表的测试数据一般都比较难造, 首先可以使用`take`方法来从一方挑一些用户出来

```ruby
# 该方法会按照创建时间升序取前6个
guests = Guest.order(:created_at).take(6)
```

然后每个用户我们加50条推文进去.

```ruby
50.times do
  content = Faker::Lorem.sentence(word_count: 5)
  guests.each { |guest| guest.microposts.create!(content: content) }
end
```

上述操作后使用`db:seed`就能生成数据, 为了完成测试功能, 记得往对应的fixture也加上数据.

```yml
# fixtures
<% 30.times do |n| %> micropost_<%= n %>:
  content: <%= Faker::Lorem.sentence(word_count:5)%>
  created_at: <%= 42.days.ago %>
  user: michael <% end %>
```

因为涉及到了view展示,写e2e测试

```ruby
require 'test_helper'

class GuestsProfileTest < ActionDispatch::IntegrationTest
  include ApplicationHelper

  def setup
    @guest = guests(:michael)
  end

  test 'profile display' do
    get guest_path(@guest)
    assert_template 'guests/show'
    assert_select 'title', full_title(@guest.name)
    assert_select 'h1', text: @guest.name
    assert_select 'h1>img.gravatar'
    # response.body会拿到整个html响应的内容
    assert_match @guest.microposts.count.to_s, response.body
    assert_select 'div.pagination'
    @guest.microposts.paginate(page: 1).each do |micropost|
      assert_match micropost.content, response.body
    end
  end
end
```

#### 操作推文

对于操作推文内容用的API, 查已经关联到user了, 因此只需要增加用的post和删除用的delete.为此可以往route.rb里添加resource

```ruby
  resources :microposts, only: %i[create destroy]
```

此时增加的相关resources如下

request|url|action|named route
---|---|---|---|
POST|/microposts|create|microposts_path
DELETE|/microposts/1|destroy|micropost_path(micropost)

> 推文访问控制

操作推文功能都需要用户登录后才能实现, 可以基于此考虑功能的test case, 此时如下

```ruby
require "test_helper"

class MicropostsControllerTest < ActionDispatch::IntegrationTest
  def setup
    @micropost = microposts(:orange)
  end
  # 考虑点: 1. 数据库不会发生变化, 2. 重定向到登录的位置
  test 'should redirect create when not logged in' do
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: "Lorem ipsum" } }
    end
    assert_redirected_to login_url
  end

  test 'should redirect destroy when not logged in' do
    assert_no_difference 'Micropost.count' do
      delete micropost_path(@micropost)
    end
    assert_redirected_to login_url
  end
end
```

为了实现上述test case描述的功能, 只需要思考在这些功能前增加登录校验即可. 登录校验方法之前已经完成在UserController上了, 为了实现复用, 我们可以将其挪动到ApplicationController上让所有controller都用到

```ruby
class ApplicationController < ActionController::Base
  before_action :count_requests_in_session

  # 通过include加载controller文件夹下helper里的模块, 能直接使用里面的方法
  include SessionsHelper

  def count_requests_in_session
    # 当每次访问整个项目所有的controller的时候
    # 如果session中没有requests，则初始化requests参数为0
    # 如果有requests参数，则每访问一次就+1
    session[:requests] ||= 0
    session[:requests] += 1
  end

  def hello
    render html: 'hello, rails'
  end

  def bye
    render html: 'bye, rails'
  end

  private 
    # 加在这里, 在application_xxx里的,默认就会可以被所有xxx用
    # 如果用户未登录,则提供后重定向到登录页
    def logged_in_guest
      unless logged_in?
        store_location
        flash[:danger] = 'Please log in.'
        redirect_to login_url
      end
    end
end
```

> 创建microposts

在microposts_controllerl里增加routes的resources需要的方法

```ruby
class MicropostsController < ApplicationController
  before_action logged_in_guest, only: %i[create destroy]

  def create
    # build形式创建的数据在内存里,不会马上提交到数据库
    @micropost = current_guest.microposts.build(micropost_params)
    if @micropost.save
      flash[:success] = 'Micropost created'
      redirect_to root_url
    else
      render 'static_pages/home'
    end
  end

  def destroy; end

  private

  # strong_params, 只要content
  def micropost_params
    params.require(:micropost).permit(:content)
  end
end
```

> feed原型

在twitter等社交应用中, to have a feed of microposts 意味着获取到某个用户的指定推文. 基于此概念, 先来创建一个最简单的feed原型

```ruby
# User model
  def feed
    Micropost.where('user_id = ?', id)
  end
```

上述代码中的id会被安全的转义到`?`中进行填充, 以避免SQL注入问题的发生.

之后可以搞下controller的部分

```ruby
class StaticPagesController < ApplicationController
  def home
    return unless logged_in?

    @micropost = current_guest.microposts.build
    @feed_items = current_guest.feed.paginate(page: params[:page])
  end
  ...
end
```

然后再搞下view的部分

```ruby
# 注意: 如果是使用 form_with的方式提供的 f.object的形式,则rails7.0版本不用加@
<% if @feed_items.any? %>
  <ol class="microposts">
  # render这里, 每个@feed_items都带有Micropost类, 
  # 因此rails会自动在view文件夹下找同名的模版
  # 即_micropost.html.erb
    <%= render @feed_items %>
  </ol>
  <%= will_paginate @feed_items %>
<% end %>
```

如果此时尝试错误添加一个micropost再进行页面跳转动作, 则会碰`No route`的一个bug, 原因是因为当报错时, 其调用的create action是在Microposts controller里, 当报错后会将URL地址更换为`http://localhost:3000/microposts`, 而原来的地址为`http://localhost:3000/`, 而因为`will_paginate`的上下页是翻动是基于当前URL地址来做的, 这就导致了找不到`get /microposts?page=2`这样的问题

该问题可以通过显式的提供给在Home页面的`will_paginate`默认值来解决, 如下

```ruby
<% if @feed_items.any? %>
  <ol class="microposts">
    <%= render @feed_items %>
  </ol>
  # 这里加了参数, 指定翻页器用的路由和方法是什么
  <%= will_paginate @feed_items, params: { controller: :static_pages, action: :home } %>
<% end %>
```

> 删除(destroy)推文

先来给view加上删除按钮, 需要判断是自己的推文

```ruby
<li id="micropost-<%= micropost.id %>">
<%= link_to gravatar_for(micropost.guest), micropost.guest %>
<span class="user"><%= link_to micropost.guest.name, micropost.guest %></span> 
<span class="content"><%= micropost.content %></span>
<span class="timestamp">
# 时间计算显示文字这个方法
Posted <%= time_ago_in_words(micropost.created_at) %> ago. 
# 加这里
<% if current_guest?(micropost.guest) %>
# 注意link_to 在rails7版本存在bug, 不能用delete方法, 此时只能改用button_to
  <%= button_to "delete", micropost, method: :delete, data: { confirm: "Are You Sure?" } %>
<% end %>
</span>
</li>
```

然后增加对应的delete要用的destroy action. 注意delete方法需要增加身份校验.

```ruby
class MicropostsController < ApplicationController
  before_action :correct_guest, only: :destroy

  def destroy
    @micropost.destroy
    flash[:success] = 'Micropost deleted'
    # request.referrer方法关系到request.original_url变量
    # 当referrer存在, 则会返回请求前的url, 当referrer不存, 则返回首页
    redirect_to request.referrer || root_url
    # rails 5后的另一种写法
    redirect_back(fallback_location: root_url)
  end

  private

    def correct_guest
    # 查询是否是用户自己的推,不是就回到首页
      @micropost = current_guest.microposts.find_by(id: params[:id])
      redirect_to root_url if @micropost.nil?
    end
end
```

> 测试

功能基本写完了, 来写测试了. 先找到fixtures来增加一些测试数据

```ruby
# microposts.yml
ants:
  content: "Oh, is that what you want? Because that's how you get ants!" 
  created_at: <%= 2.years.ago %>
  user: archer
zone:
  content: "Danger zone!"
  created_at: <%= 3.days.ago %>
  user: archer
tone:
  content: "I'm sorry. Your words made sense, but your sarcastic tone did not." 
  created_at: <%= 10.minutes.ago %>
  user: lana
van:
  content: "Dude, this van's, like, rolling probable cause." 
  created_at: <%= 4.hours.ago %>
  user: lana
```

然后先写delete删除功能的测试, 其需要确保

1. 用户不能删除其他用户的推文

```ruby
  test 'should redirect destroy for wrong micropost' do
  # 作为michael登录
    log_in_as(guests(:michael))
    # 拿ants的推文
    micropost = microposts(:ants)
    # 删不掉
    assert_no_difference 'Micropost.count' do
      delete micropost_path(micropost)
    end
    # 返回到首页
    assert_redirected_to root_url
  end
```

之后再来搞下推文功能的E2E测试, 先生成文件

`rails g integration_test microposts_interface`

然后把E2E测试代码加上

```ruby
require 'test_helper'

class MicropostsInterfaceTest < ActionDispatch::IntegrationTest
  def setup
    @guest = guests(:michael)
  end

  test 'micropost interface' do
    # 登录
    log_in_as(@guest)
    # 登录后会转到首页
    get root_path
    # 首页能获取到分页器
    assert_select 'div.pagination'
    # 1. 当用户提交创建无效的post时
    # 1.1 此时posts总数应该没有变化
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: '' } }
    end
    # 1.2 此时应该会有报错框出来
    assert_select 'div#error_explanation'
    # 1.3 此时应该处于正确的分页link
    assert_select 'a[href=?]', '/?page=2'
    # 2. 当提交有效的post时
    content = 'This micropost is very good'
    # 2.1 此时posts总数应该会有1条的差异
    assert_difference 'Micropost.count', 1 do
      post microposts_path, params: { micropost: { content: content } }
    end
    # 2.2 成功后重定向到首页
    assert_redirected_to root_url
    # 2.3 重定向, 匹配刚才提交的post在页面里
    follow_redirect!
    assert_match content, response.body
    # 3. 删除post
    # 3.1 删除按钮应该存在
    assert_select 'button', text: 'delete'
    # 3.2 获取第一条post, 声明存在-1的差异
    first_post = @guest.microposts.paginate(page: 1).first
    assert_difference 'Micropost.count', -1 do
      delete micropost_path(first_post)
    end
    # 4. 访问其他用户, 应该不存在删除操作
    get guest_path(guests(:archer))
    assert_select 'button', text: 'delete', count: 0
  end

  test 'micropost sidebar count' do
    log_in_as(@guest)
    get root_path
    assert_match "#{Micropost.count} microposts", response.body
    other_guest = guests(:malory)
    log_in_as(other_guest)
    get root_path
    assert_match "0 microposts", response.body
    other_guest.microposts.create!(content: "A micropost")
    get root_path
    assert_match "1 microposts", response.body
  end
end
```

之后 `rails test` 以下过了就OK

#### 推文照片

图片上传的功能需要使用到rails的另一个特性, 叫做ActiveStorage, 该类可以将与图片相关的model类轻松的绑定在一起, 并且可以处理除了图片之外的多种二进制或者文本文件, 比如PDF, 音视频文件等.

可以通过简单的命令来完成ActiveStorage的添加(默认是不启用的)

`rails active_storage:install`

执行后控制台会输出如下内容

`Copied migration 20221015060050_create_active_storage_tables.active_storage.rb from active_storage`

表示生成了一个database migration会专门用于存储文件, 并且屏蔽了所有用于存储的细节, 只暴露了API给开发者用, 因此我们只需要执行

`rails db:migrate`

就会在数据库里创建三张表: 

1. :active_storage_blobs
2. :active_storage_attachments
3. :active_storage_variant_records

然后来简单看下需要知道的用于操作它们的API

1. has_one_attached: 允许我们用于将一个上传的文件关联到某一个model对象
2. has_many_attached: 允许我们绑定多个文件到某一个model对象

比如

```ruby
class Micropost < ApplicationRecord
  ...
  has_one_attached :image
  ...
end
```

然后修改下view, 使用新的form表单构建方法, `file_field`

```ruby
<%= form_with(model: @micropost, local: true) do |f| %> 
  <%= render 'shared/error_messages', object: f.object %> 
  <div class="field">
  <%= f.text_area :content, placeholder: "Compose new micropost..." %> 
  </div>
  <%= f.submit "Post", class: "btn btn-primary" %> 
  # add new field here
  <span class="image">
    <%= f.file_field :image %>
  </span>
<% end %>
```

推文里的图片展示则可以使用`image_tag`来渲染

```ruby
  <%= image_tag micropost.image if micropost.image.attached? %>
```

最后再修改下controller用于处理上传即可, 方便的是ActiveStorage提供了API-`attach`能直接进行上传操作, 详细如下

```ruby
  def create
    @micropost = current_guest.microposts.build(micropost_params)
    # 新增这里, 直接attach拿到图片对象即可
    @micropost.image.attach(params[:micropost][:image])
    ...
  end

  private
    def micropost_params
      # 表单多放开一个image
      params.require(:micropost).permit(:content, :image)
    end
```

之后来完成test的编码工作. 由于涉及到了文件上传的功能, 因此这块涉及到的测试要用的文件内容, 需要本地保存在fixtures文件夹下才能实现测试功能.

`curl -o test/fixtures/kitten.jpg -OL https://cdn.learnenough.com/kitten.jpg`

先准备一张图片, 然后写test case, 由于之前已经写过了E2E,这里只需要加上图片相关的校验就好了, 注意在test中需要mock上传方法, 可以使用`fixture_file_upload`来实现

```ruby
    # 首页能获取到上传用的input框
    assert_select 'input[type=image]'
    image = fixture_file_upload('test/fixtures/kitten.jpg', 'image/jpeg')
    # 2.1 此时posts总数应该会有1条的差异
    assert_difference 'Micropost.count', 1 do
      post microposts_path, params: { micropost: { content: content, image: image } }
    end
    assert Micropost.first.image.attached?
```

> 图片校验

这部分来说明一下文件上传时的校验问题. ActiveStorage并没有提供任何用于校验文件格式和大小之类的方法, 但是有别的gem可以帮助我们完成这个工作,其为

`active_storage_validations`

我们可以先把其加入到gemfile里, 然后`gem install`安装 

该GEM会增强ActiveRecord对象, 使其能对二进制文件类型进行校验, 比如新增加content_type, size等来对目标表单字段进行校验. 如下

```ruby
class Micropost < ApplicationRecord
  belongs_to :guest
  has_one_attached :image
  default_scope -> { order(created_at: :desc) }
  validates :guest_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
  # 新增这里
  validates :image, content_type: { in: %i[image/jpeg image/gif image/png], 
                                    message: "must be a valid image format" },
                    size: { less_than: 5.megabytes, 
                            message: "should be less than 5MB" }
end
```

当然, 这里是后端在model层做了校验限制, 为了尽可能的截住流量, 前端部分也应该做相应的处理.

一是增加相应的js脚本来计算是否有超5MB的限制, 超了就提示并清空上传栏
```html
<script type="text/javascript">
  $("#micropost_image").bind("change", function() {
    const size_in_megabytes = this.files[0].size / 1024 /1024;
    if (size_in_megabytes > 5) {
      alert("Maximum file size is 5MB. Please choose a smaller file.")
      $("#micropost_image").val("");
    } 
  })
</script>
```
二是限制上传的文件类型, 如下

```ruby
  <span class="image">
    <%= f.file_field :image, accept: "image/jpeg, image/gif, image/png" %>
  </span>
```

> 图片大小调整(resize)

上述代码完成了图片的上传和校验工作, 但是对于大图片的显示应该还需要做人工上的大小调整才符合逻辑, 对于rails而言, 这块的功能并没有内置在框架里, 因此我们需要调用第三方应用来帮我们处理, 并且在自己的应用里装上对应的接口调用的gem来完成工作

这里推荐的用于图片处理的应用有2个

1. ImageMagick (老, 属于CLI工具, 没有容器化支持, 配套gem和程序需要运行在一个机器环境上)
2. ImageProxy(新, 支持容器化, 通过RPC调用实现图片修改)

至于安装, MacOS只需要`brew install imagemagick`就行, 如果是linux平台, 则`yum install imagemagick`

安装完毕并启动后, 继续往项目的gemfile里增加如下gem用于接口使用

```ruby
gem 'image_processing', '1.9.3'
gem 'mini_magick', '4.9.5'
```

之后执行`bundle install` 进行gem的安装

以上程序完成后, 则会增强ActiveStorage的功能, 使其可以对图片进行大小缩放控制, 此时能调用`variant`方法来实现这个功能.如下

```ruby
class Micropost < ApplicationRecord
  ...
  # image会拿到object里的image,调整后返回
  def display_image
    image.variant(resize_to_limit: [100, 100])
  end
end

# 此时view展示层修改一下, 从micropost.image 改为micropost.display_image
  <%= image_tag micropost.display_image if micropost.image.attached? %>
```

> 生产环境图片上传

对于生产环境的图片和文件等的存储, 肯定是需要和主程序分开保存的, 比如cloud storage, heroku提供一个临时的文件存储系统, 但是该系统会在每次app重新部署之后清除.

AWS的S3(Simple Storage Service)云存储服务在国外比较常用, 一般都使用这个

在rails项目中, 为了在生产中使用云存储功能, 需要增加 `aws-sdk-s3` 这个gem到生产环境配置中, 如下

```ruby
# Gemfile
group :production do
  gem "pg", "1.1.4"
  # require在这里有2个作用, 1是当写成false时, 表示项目跑起来的时候, 不会被bundler 自动require, 而是需要在项目里手动require才能调用
  # 2是当写成, 比如 require: 'awsstroage'的时候, 则依旧会自动被bundler加载, 但是加载名字会变成awsstorage
  # 因此require的作用1是重命名gem在项目里的name, 2是取消自动加载为手动加载
  gem 'aws-sdk-s3', '1.46.0', require: false
end
```

然后执行`bundle install`安装该gem. 注意这里的group只是限定了rails启动时,bundler会按照环境选择去加载哪些gem而已, 并不是说不会安装, 而是都会安装上的.

生产环境直接将S3的key和token等配置在项目代码里是非常危险的事情. 在没有用到k8s的情况下, 如果使用的heroku, 则可以按照如下命令在heroku的控制台手动设定环境密钥

```sh
$ heroku config:set AWS_ACCESS_KEY_ID=<access key>
$ heroku config:set AWS_SECRET_ACCESS_KEY=<secret key> $ heroku config:set AWS_REGION=<region>
$ heroku config:set AWS_BUCKET=<bucket name>
```

这些需要被rails使用到的环境变量, 则应该配置在项目的config文件夹下, 基于这里是存储, 所以可以找到storage.yml来进行管理

```yml
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# 新增这里.
# rails服务器启动时通过ENV[]全局变量类来拿到全局变量
amazon:
  service: S3
  access_key_id: <%= ENV['AWS_ACCESS_KEY_ID'] %>
  secret_access_key: <%= ENV['AWS_SECRET_ACCESS_KEY'] %> 
  region: <%= ENV['AWS_REGION'] %>
  bucket: <%= ENV['AWS_BUCKET'] %>
```

然后再找到config/environments/production.rb 来配置rails服务器启动时生产环境的加载文件, 处在该文件夹下的所有环境配置文件, 能配置所有rails从属子框架的所有设定, 比如如下的active_storage, 还有之前的active_mailer, 还有active_record等等...

```ruby
require 'active_support/core_ext/integer/time'

Rails.application.configure do
  ...
  # Store uploaded files on the local file system (see config/storage.yml for options).
  # config.active_storage.service = :local
  config.active_storage.service = :amazon
  ...
end
```

基于以上配置后, 就可以放心的推送到服务器打包部署了

#### 该部分功能总结

1. 推文和用户一样, 都可以以resource的形式被ActiveRecord管理起来
2. 可以在model里使用`has_many`与`belongs_to`方法来管理model之间一对多的关系
3. has_many/belongs_to 的组合能通过model之间的association来给予各种便利的方法完成有难度的关联表业务逻辑
4. `user.microposts.build(...)`方法会返回一个新的Micropost对象并且关联其user, 但是不会立刻提交到数据库
5. rails可以通过给model设定`default_scope`来修改model的默认设定, 比如修改order排序
6. Scopes接收一个匿名函数(lambda)来作为参数, 比如 scope aaa: -> { where("created_at > ?", Time.now) }, 这里的 -> {} 就是匿名函数
7. dependent: :destroy的option会让model所关联的其他对象的记录同时被删除.比如: `has_many :microposts, dependent: :destroy`
8. 翻页器和对象count, 也可以通过关联对象的形式查询实现, 而无需分开写
9. Fixtures中也能实现关联model的创建
10. view的partials也能传递变量使用
11. `where`方法用于ActiveRecord的查询功能
12. 我们可以通过总是同时创建和同时删除model对象所依赖的关联关系来提升操作上的安全性.
13. 可以通过`ActiveStorage`来完成图片等二进制文件资源的上传功能.
14. rails支持通过代码来增加联合索引

### Following 用户功能

#### RelationShip Model

follow用户的功能相对其他功能而言都比较复杂, 由于用户和用户之间是多对多的关系, 这就意味着我们需要使用一些之前没有被使用到的方式来完成

其中需要思考的关键点是follower与followed之间的关系, 一位用户可能是别的用户的follower, 当然自己也有可能被别人following, 这一行为一方是主动的,一方是被动的, 因此我们需要第三张表来专门管理这一关系.

先输入如下命令创建这张表Relationship

`rails g model Relationship follower_id:integer followed_id:integer
`

该表的关键字段如下

field | type
--- | --- |
id | integer
follower_id | integer
followed_id | integer
created_at | datetime
updated_at | datetime

而rails中所有这种多对多关系的model, 都应该如此以第三张表为基准建立many关系,才能实现多对多的model.

由于多对多的关系的第第三张表承载的数据量及其巨大, 特别是big star的follower海量的时候尤其可怕, 因此对于这种多对多的表都必须要加满索引和联合索引来提升查询速度, 如下

```ruby
class CreateRelationships < ActiveRecord::Migration[7.0]
  def change
    create_table :relationships do |t|
      t.integer :follower_id
      t.integer :followed_id

      t.timestamps
    end
    add_index :relationships, :follower_id
    add_index :relationships, :followed_id
    # 这里添加了联合索引, 并确保了其唯一性, 以避免重复添加相同对象导致bug的产生.
    # 这里就产生一个思考, 对于这类联合索引, 今后如果碰到任何类似的模式, 都应该让其唯一
    add_index :relationships, %i[follower_id followed_id], unique: true
  end
end
```

之后执行migrate命令创建表`rails db:migrate`

这里稍微复习一下这种写法

```ruby
# symbol to proc
guest.following.map { |g| g.id }
# 等价于, 只会返回id组成的数组ids
guest.following.map(&:id)
```

> User / RelationShip associations

首先我们需要明确

1. 一个用户会 has_many 很多个relationships
2. 一个relationship会belongs_to所属的2个用户

因此先从User对象会有很多个microposts来思考为什么它们能建立association

```ruby
# rails内部调用了classify方法, 来将symbol :microposts 转换成了Micropost, 并会去查找Micropost这个model
  has_many :microposts, dependent: :destroy
```

再从Micropost对象来看

```ruby
# rails能从技术上建立外键关系, 是因为这里rails的belongs_to方法调用了underscore方法, 来将类名先转化为短横线方式的拼接, 之后再拼接_id来组成外键字段的变量名.
# 比如ProductImport.underscore == product_import, 然后再拼上_id, 就变成了product_import_id, 这个变量名就是外键
  belongs_to :user
```

基于以上, 我们可以知道外键的变量名在rails里是如何产生的, 并且其规则一定是<class>_id的形式(这里的class是小写的classname)

因此, 可以得出relation会有如下方法, 用于处理多对多关系, 重命名手动指定的原因是因为都属于同一个对象, 这些命名会直接变成可以被执行的方法, 特别是下面的relationship对象, 一看就知道为什么要重命名了

method | purpose
---| ---|
active_relationship.follower | 返回follower
active_relationship.followed | 返回followed用户
user.active_relationships.create(followed_id: other_user.id) | 与其它user创建一个active_relationship association
user.active_relationships.create!(followed_id: other_user.id) | 上面的带报错版本
user.active_relationships.build(followed_id: other_user.id) | 创建一个新的relationship对象

此时User对象与relationship的关系如下

```ruby
  has_many :active_relationships, class_name: "Relationship",
                                  foreign_key: "follower_id",
                                  dependent: :destroy
```

此时Relationship对象如下

```ruby
class Relationship < ApplicationRecord
  belongs_to :follower, class_name: 'Guest'
  belongs_to :followed, class_name: 'Guest'
  validates :follower_id, presence: true
  validates :followed_id, presence: true
end
```

并且此时如果尝试执行active_relationships.create方法, 则会输出如下内容

```ruby
3.0.0 :013 > Guest.third.active_relationships.create!(followed_id: 4)
  Guest Load (0.4ms)  SELECT `guests`.* FROM `guests` ORDER BY `guests`.`id` ASC LIMIT 1 OFFSET 2                                                                         
  TRANSACTION (0.1ms)  BEGIN                                     # 这里会先找到自己的id
  Guest Load (1.6ms)  SELECT `guests`.* FROM `guests` WHERE `guests`.`id` = 3 LIMIT 1
  # 然后再找到另一个user的id
  Guest Load (0.7ms)  SELECT `guests`.* FROM `guests` WHERE `guests`.`id` = 4 LIMIT 1
  # 然后插入Relationship表
  Relationship Create (1.9ms)  INSERT INTO `relationships` (`follower_id`, `followed_id`, `created_at`, `updated_at`) VALUES (3, 4, '2022-10-15 12:16:11.891577', '2022-10-15 12:16:11.891577')                                                                
  TRANSACTION (2.0ms)  COMMIT                                                        
 =>                                                                                  
#<Relationship:0x00007fb9f70f60c8                                                    
 id: 1,                                                                              
 follower_id: 3,                                                                     
 followed_id: 4,                                                                     
 created_at: Sat, 15 Oct 2022 12:16:11.891577000 UTC +00:00,                         
 updated_at: Sat, 15 Oct 2022 12:16:11.891577000 UTC +00:00> 
```

之后写下单元测试, 看下刚才写的功能是不是对的

```ruby
require "test_helper"

class RelationshipTest < ActiveSupport::TestCase
  def setup
    @relationship = Relationship.new(follower_id: guests(:michael).id,
                                     followed_id: guests(:archer).id)
  end

  test 'should be valid' do
    assert @relationship.valid?
  end

  test 'should require a follower_id' do
    @relationship.follower_id = nil
    assert_not @relationship.valid?
  end

  test 'should require a followed_id' do
    @relationship.followed_id = nil
    assert_not @relationship.valid?
  end
end
```

> followed users

为了完成多对多+都是同一个对象关系的情况, 这里需要使用到一个核心方法, 叫做`has_many :through`, 表示某一个对象能通过(through)某个其它对象来建立多对多的关系.

默认情况下, `has_many :through` 是告诉rails通过单数形式去查找, 比如如下写法

`has_many :followeds, through: :active_relationships`

这种写法下rails会将followeds转为followed, 并在relationships表里收集followed_id, 当然followeds这种英文写法明显有语法错误, 所以可以手动使用`source` option来改一改, 比如如下

```ruby
# 这里表示显示的告诉rails, following_id是表里followed_id的集合
  has_many :following, through: :active_relationships, source: :followed
```

上述这种写法很强大, 能让我们可以确认一个被followed的用户是否包含了其它用户.比如

```ruby
# user model对象可以直接通过following(即followed_id的数组)来判断是否包含某一个user_id
user.following.include?(other_user)
user.following.find(other_user)

# 往followed_id的数组末尾加一个user_id
user.following << other_user
user.following.delete(other_user)
```

尽管上述的内容来看following是被当作数组来进行操作, 但是实际上,rails会自动在调用数据库相关方法时, 转换为数据库能使用的对象来处理, 比如

```ruby
# 这里的count就是直接在数据库里掉count函数来实现的
user.microposts.count
```

为了更好实现业务逻辑, 这里可以增加follow和unfollow,following?等方法来帮助功能的实现.

如果没有实现逻辑的话, 可以从test case的角度思考下这些方法要怎么被使用, 比如

```ruby
  test 'should follow and unfollow a user' do
    michael = guests(:michael)
    archer = guests(:archer)
    assert_not michael.following?(archer)

    michael.follow(archer)
    assert michael.following?(archer)

    michael.unfollow(archer)
    assert_not michael.following?(archer)
  end
```

上面的test case其实很直观, 真实开发项目时, 其实也可以参照这样的思路, 从业务/功能交互上会产生什么结果来想, 先把test case撸出来, 这样至少主干道不会偏

在model里的实现如下

```ruby
  def follow(other_guest)
    following << other_guest
  end

  def unfollow(other_guest)
    following.delete(other_guest)
  end

  def following?(other_guest)
    following.include?(other_guest)
  end
```

> followers

followers(我有多少粉) 的功能刚好和following(我追了多少人)的功能相反, 后一个是主动的, 前一个则是被动的. 而其实现逻辑其实也是反转而已, 为了区分, 可以取另外一个手动指定的关系为`:passive_relationships`来和前面的`:positive_relationships`区分开来(这里就明白为什么前面要搞个这个别名了, 如果都直接用:relationships, 那这里就没法区分开了). 

此时user的model新增如下关系

```ruby
  has_many :active_relationships, class_name: 'Relationship',
                                  foreign_key: 'follower_id',
                                  dependent: :destroy
  has_many :following, through: :active_relationships, source: :followed
  # 新增了这里, 刚好可以对比一下
  has_many :passive_relationships, class_name: 'Relationship',
                                   foreign_key: 'followed_id',
                                   dependent: :destroy
  # 这个位置的source option可以省略不写
  # 当使用了through的时候, 默认这里的source和前面的:followers属性一样. rails会自动转为去查找follower_id
  has_many :followers, through: :passive_relationships, source: :follower
```

此时可以确认下联表的SQL

```ruby
  aaa.followers.count 
  Guest Count (0.5ms)  SELECT COUNT(*) FROM `guests` INNER JOIN `relationships` ON `guests`.`id` = `relationships`.`follower_id` WHERE `relationships`.`followed_id` = 3  
 => 0              
```

#### following接口

