### 账号激活功能

#### 业务逻辑

1. 给users表新增`unactivated`字段, 用于区分未激活与激活账号
2. 当用户注册后, 生成激活用的token以及对应服务器需要拿来识别的digest
3. 保存激活用的digest到db, 之后发送邮件到用户填写的邮箱, 邮件内容里的link包括了激活用的token
4. 当用户点击link之后, 通过email address来查找用户, 并使用生成的识别digest来校验token
5. 如果授权成功, 则将用户的`unactivated`更新为`activated`

本部分主要会涉及到校验和rails的邮件发送功能的使用

#### 账号激活 resource

> controller

账号激活功能可以单独开一个RESTFUL风格的资源来进行管理. 至于原因, 则是因为账号激活可以作为单独的逻辑来进行处理.

执行命令创建Restful的 controller

`rails g controller AccountActivations`

然后在routes里记得加上resources标记, 让rails server能转发请求

```ruby
  resources :account_activations, only: [:edit]
```

> model

准备好controller后就可以开始着手准备model了, 为了防止骇客攻击数据库窃取信息, 因此对于activation_token的保存, 也应该类似于password, 使用activation_digest的形式进行保存, 以提高安全性.

基于此, users新表结构如下

field | datatype
---|---
id | integer
name | string
email | string
created_at | datetime
updated_at | datetime
password_digest | string
remember_digest | string
admin | boolean
activation_digest | string
activated | boolean
activated_at | datetime

执行命令来给users表新增一下需要的字段(注意这里因为项目复用的问题所以还是guests表哈)

`rails g migration add_activation_to_guests activation_digest:string activated:boolean activated_at:datetime`

之后会生成如下代码

```ruby
class AddActivationToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :activation_diest, :string
    add_column :guests, :activated, :boolean, default: false
    add_column :guests, :activated_at, :datetime
  end
end
```

再执行 `rails db:migrate` 完成db的migrate动作

> 激活token的callback

model层有很多的勾子方法能够帮助我们在执行model操作之前做一些事情, 这些model层的钩子除了校验之外, 还能起到很多CRUD的前置操作, 见如下代码

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token, :activation_token\
  before_save { email.downcase! }
  before_create :create_activation_digest
  ...

  # 这些校验方法都不要暴露出去
  private

  def downcase_email
    self.email = email.downcase
  end

  def create_activation_digest
    self.activation_token = Guest.new_token
    self.activation_digest = Guest.digest(activation_token)
  end
  
end
```

之后在seeds里创建一些假数据来进行测试看看

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar',
              # 这里字段新增
              activated: true,
              activated_at: Time.zone.new,
              admin: true)

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                # 这里字段新增
                activated: true,
                activated_at: Time.zone.new,
                password_confirmation: password)
end
```

记得所有test的数据都只能从fixtures里拿

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  activated: true
  activated_at: <%= Time.zone.now %>
  admin: true
```

然后重置数据库,重新把带了新字段的假数据插到qa里试试

`rails db:migrate:reset    rails db:seed`

#### 账号激活邮件

rails自带邮件发送的功能, 该邮件功能能通过内置的Action Mailer Library来完成, 而邮件的模版,则会使用erb文件.

使用命令来创建邮件模版

`rails generate mailer GuestMailer account_activation password_reset`

上述命令会在mailers里生成一个mailer文件同时还会修改application_mailer文件, 此外会在views中产生account_activation,password_reset各2个邮件模版, 格式分别是text和html. 文件内容如下

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end
```

```ruby
# html.erb
<h1>Guest#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/guest_mailer/account_activation.html.erb
</p>

# text.erb
Guest#account_activation

<%= @greeting %>, find me in app/views/guest_mailer/account_activation.text.erb
```

为了实现激活邮件发送, 我们先动手修改一下生成的模版, 添加一些必要的内容

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation(guest)
    @guest = guest
    mail to: guest.email,  subject: 'Account Activation'
  end
  ...
end
```

激活链接需要包含email与即时生成的token. 链接例子如下

` http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit`

上面链接中一堆看不懂的就是base64加密后的内容, 整个链接能起到的内容和

`http://www.example.com/users/1/edit` 一样. 

实现上述逻辑的关键,是 ` edit_account_activation_url(@user.activation_token, ...)` 能回调`edit_user_url(user)`

为了实现此功能, 激活链接后面的部分需要加上查询参数以确认用户

`account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com`

此时当用户点击上述链接, 则方法可以通过query parameter的params[:email]来拿到参数. 并且注意上述foo%40的部分,%40是转义后的内容

之后修改email部分模版内容

```ruby
<h1>Sample App</h1>
<p>Hi <%= @user.name %>,</p>
<p>
Welcome to the Sample App! Click on the link below to activate your account: </p>
<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>
```

#### 邮件预览与测试

rails提供了邮件发送的预览功能, 首先需要在config里先配置一下环境信息

```ruby
# config/environments/development.rb
# 增加以下内容, host改为服务器地址
  host = 'localhost:3000'
  config.action_mailer.default_url_options = { host: host, protocol: 'https' }
```

然后preview走一下,可以在`http://localhost:3000/rails/mailers/guest_mailer/account_activation`查看到邮件渲染出来的模版.

```ruby
# Preview all emails at http://localhost:3000/rails/mailers/guest_mailer
class GuestMailerPreview < ActionMailer::Preview
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/account_activation
  def account_activation
    guest = Guest.first
    guest.activation_token = Guest.new_token
    GuestMailer.account_activation(guest)
  end

  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    GuestMailer.password_reset
  end
end
```

preview没问题的话记得跑测试

```ruby
class GuestMailerTest < ActionMailer::TestCase
  test "account_activation" do
    guest = guests(:michael)
    guest.activation_token = Guest.new_token
    mail = GuestMailer.account_activation(guest)
    assert_equal "Account Activation", mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ["noreply@example.com"], mail.from 
    assert_match guest.name, mail.body.encoded 
    assert_match guest.activation_token, mail.body.encoded 
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
  ...
end

# 还需要添加environment下的test环境下面语句
# 这样就能在测试环境里设定发送邮件的默认尾缀为@example.com
  config.action_mailer.default_url_options = { host: 'example.com' }
```

