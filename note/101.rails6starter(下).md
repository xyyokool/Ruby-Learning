### 账号激活功能

#### 业务逻辑

1. 给users表新增`unactivated`字段, 用于区分未激活与激活账号
2. 当用户注册后, 生成激活用的token以及对应服务器需要拿来识别的digest
3. 保存激活用的digest到db, 之后发送邮件到用户填写的邮箱, 邮件内容里的link包括了激活用的token
4. 当用户点击link之后, 通过email address来查找用户, 并使用生成的识别digest来校验token
5. 如果授权成功, 则将用户的`unactivated`更新为`activated`

本部分主要会涉及到校验和rails的邮件发送功能的使用

#### 账号激活 resource

> controller

账号激活功能可以单独开一个RESTFUL风格的资源来进行管理. 至于原因, 则是因为账号激活可以作为单独的逻辑来进行处理.

执行命令创建Restful的 controller

`rails g controller AccountActivations`

然后在routes里记得加上resources标记, 让rails server能转发请求

```ruby
  resources :account_activations, only: [:edit]
```

> model

准备好controller后就可以开始着手准备model了, 为了防止骇客攻击数据库窃取信息, 因此对于activation_token的保存, 也应该类似于password, 使用activation_digest的形式进行保存, 以提高安全性.

基于此, users新表结构如下

field | datatype
---|---
id | integer
name | string
email | string
created_at | datetime
updated_at | datetime
password_digest | string
remember_digest | string
admin | boolean
activation_digest | string
activated | boolean
activated_at | datetime

执行命令来给users表新增一下需要的字段(注意这里因为项目复用的问题所以还是guests表哈)

`rails g migration add_activation_to_guests activation_digest:string activated:boolean activated_at:datetime`

之后会生成如下代码

```ruby
class AddActivationToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :activation_diest, :string
    add_column :guests, :activated, :boolean, default: false
    add_column :guests, :activated_at, :datetime
  end
end
```

再执行 `rails db:migrate` 完成db的migrate动作

> 激活token的callback

model层有很多的勾子方法能够帮助我们在执行model操作之前做一些事情, 这些model层的钩子除了校验之外, 还能起到很多CRUD的前置操作, 见如下代码

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token, :activation_token\
  before_save { email.downcase! }
  before_create :create_activation_digest
  ...

  # 这些校验方法都不要暴露出去
  private

  def downcase_email
    self.email = email.downcase
  end

  def create_activation_digest
    self.activation_token = Guest.new_token
    self.activation_digest = Guest.digest(activation_token)
  end
  
end
```

之后在seeds里创建一些假数据来进行测试看看

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar',
              # 这里字段新增
              activated: true,
              activated_at: Time.zone.new,
              admin: true)

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                # 这里字段新增
                activated: true,
                activated_at: Time.zone.new,
                password_confirmation: password)
end
```

记得所有test的数据都只能从fixtures里拿

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  activated: true
  activated_at: <%= Time.zone.now %>
  admin: true
```

然后重置数据库,重新把带了新字段的假数据插到qa里试试

`rails db:migrate:reset    rails db:seed`

#### 账号激活邮件

rails自带邮件发送的功能, 该邮件功能能通过内置的Action Mailer Library来完成, 而邮件的模版,则会使用erb文件.

使用命令来创建邮件模版

`rails generate mailer GuestMailer account_activation password_reset`

上述命令会在mailers里生成一个mailer文件同时还会修改application_mailer文件, 此外会在views中产生account_activation,password_reset各2个邮件模版, 格式分别是text和html. 文件内容如下

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end
```

```ruby
# html.erb
<h1>Guest#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/guest_mailer/account_activation.html.erb
</p>

# text.erb
Guest#account_activation

<%= @greeting %>, find me in app/views/guest_mailer/account_activation.text.erb
```

为了实现激活邮件发送, 我们先动手修改一下生成的模版, 添加一些必要的内容

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation(guest)
    @guest = guest
    mail to: guest.email,  subject: 'Account Activation'
  end
  ...
end
```

激活链接需要包含email与即时生成的token. 链接例子如下

` http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit`

上面链接中一堆看不懂的就是base64加密后的内容, 整个链接能起到的内容和

`http://www.example.com/users/1/edit` 一样. 

实现上述逻辑的关键,是 ` edit_account_activation_url(@user.activation_token, ...)` 能回调`edit_user_url(user)`

为了实现此功能, 激活链接后面的部分需要加上查询参数以确认用户

`account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com`

此时当用户点击上述链接, 则方法可以通过query parameter的params[:email]来拿到参数. 并且注意上述foo%40的部分,%40是转义后的内容

之后修改email部分模版内容

```ruby
<h1>Sample App</h1>
<p>Hi <%= @user.name %>,</p>
<p>
Welcome to the Sample App! Click on the link below to activate your account: </p>
<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>
```

#### 邮件预览与测试

rails提供了邮件发送的预览功能, 首先需要在config里先配置一下环境信息

```ruby
# config/environments/development.rb
# 增加以下内容, host改为服务器地址
  host = 'localhost:3000'
  config.action_mailer.default_url_options = { host: host, protocol: 'https' }
```

然后preview走一下,可以在`http://localhost:3000/rails/mailers/guest_mailer/account_activation`查看到邮件渲染出来的模版.

```ruby
# Preview all emails at http://localhost:3000/rails/mailers/guest_mailer
class GuestMailerPreview < ActionMailer::Preview
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/account_activation
  def account_activation
    guest = Guest.first
    guest.activation_token = Guest.new_token
    GuestMailer.account_activation(guest)
  end

  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    GuestMailer.password_reset
  end
end
```

preview没问题的话记得跑测试

```ruby
class GuestMailerTest < ActionMailer::TestCase
  test "account_activation" do
    guest = guests(:michael)
    guest.activation_token = Guest.new_token
    mail = GuestMailer.account_activation(guest)
    assert_equal "Account Activation", mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ["noreply@example.com"], mail.from 
    assert_match guest.name, mail.body.encoded 
    assert_match guest.activation_token, mail.body.encoded 
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
  ...
end

# 还需要添加environment下的test环境下面语句
# 这样就能在测试环境里设定发送邮件的默认尾缀为@example.com
  config.action_mailer.default_url_options = { host: 'example.com' }
```

#### 完成激活功能

> 更新create action

修正之前用户sign up后会直接跳转到profile页面, 中间加入邮件激活功能, 代码修改为如下内容

```ruby
  def create
    @guest = Guest.new(guest_params)
    if @guest.save
      GuestMailer.account_activation(@guest).deliver_now
      flash[:info] = "Please check your email to activate your account"
      redirect_to root_url
    else
      render 'new'
    end
```

> edit启用账号激活

这里需要用到ruby的一个特性`元编程(metaprogramming)`, 该特性的一个关键特点是能够使用对象内置的`send`方法来动态获取对象内部的任何属性. 比如

```ruby
a = [1,2,3,4,5]
# 常规来说, 获取数组长度
a.length # -> 5
# 使用元编程, 则
a.send(:length) # -> 5
```

基于上述认识, 可以来改写`authenticated?`方法, 让其具有能够解析带token的url的能力

```ruby
# model/guest.rb, 原
  def authenticated?(remember_token)
    return false if remember_digest.nil?

    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
# 改写后

  def authenticated?(attribute, token)
  # 此处send等价于self.send, 只要处在model对象内,就能省略self
    digest = send("#{attribute}_digest")
    return false if digest.nil?
    BCrypt::Password.new(digest).is_password?(token)
  end
```

之后修改一下session_helper.rb里用到了该方法的地方

```ruby
  def current_guest
    if (guest_id = session[:guest_id])
      @current_guest ||= Guest.find_by(id: cookies.encrypted[:guest_id])
    elsif (guest_id = cookies.encrypted[:guest_id])
      guest = Guest.find_by(id: guest_id)
      # 修改了这里
      if guest&.authenticated?(:remember, cookies[:remember_token])
        log_in guest
        @current_guest = guest
      end
    end
  end
```

然后我们在新增的用于账号激活的controller里新增edit方法以用来处理激活

```ruby
class AccountActivationsController < ApplicationController
  def edit
  # 先找到guest
    guest = Guest.find_by(email: params[:email])
    # 如果guest存在,同时没激活有授权, 则 更新激活属性
    if guest&.!activated?&.authenticated?(:activation, params[:id])
      guest.update_attribute(:activated, true)
      guest.update_attribute(:activated_at, Time.zone.now)
      log_in guest
      flash[:success] = "Account activated!"
      # 激活完毕,返回主页
      redirect_to guest
    else
      flash[:danger] = "Invalid activation link"
      redirect_to root_url
    end
  end
end
```

最后再来修改一下session_controller里用户创建成功时的逻辑

```ruby
  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    if guest&.authenticate(params[:session][:password])
    # 增加了这里, 用于处理用户激活功能
      if guest.activated?
        log_in guest
        # rails提供的重定向方法, 会自动转成 guest_url(guest)
        params[:session][:remember_me] == '1' ? remember(guest) : forget(guest)
        remember guest
        # redirect_back_or guest
        redirect_to guest
      else
        message = 'Account not activated.'
        message += 'Check your email for the activation link.'
        flash[:warning] = message
      end
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end
```

#### 邮件整合测试

```ruby
require 'test_helper'
class UsersSignupTest < ActionDispatch::IntegrationTest
def setup 
  ActionMailer::Base.deliveries.clear
end

test "invalid signup information" do 
  get signup_path
  assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password: "foo",
                                         password_confirmation: "bar" } }  
  end
  assert_template 'users/new' 
  assert_select 'div#error_explanation' 
  assert_select 'div.field_with_errors'
end


test "valid signup information with account activation" do 
  get signup_path
  assert_difference 'User.count', 1 do
    post users_path, params: { user: { name: "Example User", 
                                       email: "user@example.com",
                                       password:              "password",
                                       password_confirmation: "password" } }
  end
  assert_equal 1, ActionMailer::Base.deliveries.size 
  user = assigns(:user)
  assert_not user.activated?
  # Try to log in before activation.
  log_in_as(user)
  assert_not is_logged_in?
  # Invalid activation token
  get edit_account_activation_path("invalid token", email: user.email) 
  assert_not is_logged_in?
  # Valid token, wrong email
  get edit_account_activation_path(user.activation_token, email: 'wrong')
  assert_not is_logged_in?
      # Valid activation token
  get edit_account_activation_path(user.activation_token, email: user.email) 
  assert user.reload.activated?
  follow_redirect!
  assert_template 'users/show'
  assert is_logged_in?
  end 
end
```

#### 生产环境中的email

1. 需要能发送邮件的服务器.(heroku有sendGrid好像能每天免费发400封)
2. 之后在config/environments/production.rb里配置发送的host
3. 账号密码通过环境变量来获取, 不配置在本地.

```ruby
  host = 'xxx.herokuapp.com'
```

#### 该部分总结

1. 和sessions功能一样, 账号激活功能也可以被当作一种resource来处理(在routes.rb内为resource), 而不是一个ActiveRecord的对象.
2. rails可以生成ActionMailer的actions与views,并能用来发送邮件.
3. Action Mailer支持纯文本和HTML2种邮件格式.
4. 被定义在mailer的actions里的实例变量在mailer的views中是可随时被调用的.
5. 账号激活功能使用一个生成的token来创建唯一的URL以让用户激活.
6. 账号激活功能使用hash的activation_digest来确保校验有效的激活请求(即给到用户的token本身是密中密,直接破解不可能).
7. 功能测试与e2e测试对于校验mailer功能的正确性非常重要.
8. 生产环境可以使用`SendGrid`来发送邮件.