### 账号激活功能

#### 业务逻辑

1. 给users表新增`unactivated`字段, 用于区分未激活与激活账号
2. 当用户注册后, 生成激活用的token以及对应服务器需要拿来识别的digest
3. 保存激活用的digest到db, 之后发送邮件到用户填写的邮箱, 邮件内容里的link包括了激活用的token
4. 当用户点击link之后, 通过email address来查找用户, 并使用生成的识别digest来校验token
5. 如果授权成功, 则将用户的`unactivated`更新为`activated`

本部分主要会涉及到校验和rails的邮件发送功能的使用

#### 账号激活 resource

> controller

账号激活功能可以单独开一个RESTFUL风格的资源来进行管理. 至于原因, 则是因为账号激活可以作为单独的逻辑来进行处理.

执行命令创建Restful的 controller

`rails g controller AccountActivations`

然后在routes里记得加上resources标记, 让rails server能转发请求

```ruby
  resources :account_activations, only: [:edit]
```

> model

准备好controller后就可以开始着手准备model了, 为了防止骇客攻击数据库窃取信息, 因此对于activation_token的保存, 也应该类似于password, 使用activation_digest的形式进行保存, 以提高安全性.

基于此, users新表结构如下

field | datatype
---|---
id | integer
name | string
email | string
created_at | datetime
updated_at | datetime
password_digest | string
remember_digest | string
admin | boolean
activation_digest | string
activated | boolean
activated_at | datetime

执行命令来给users表新增一下需要的字段(注意这里因为项目复用的问题所以还是guests表哈)

`rails g migration add_activation_to_guests activation_digest:string activated:boolean activated_at:datetime`

之后会生成如下代码

```ruby
class AddActivationToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :activation_diest, :string
    add_column :guests, :activated, :boolean, default: false
    add_column :guests, :activated_at, :datetime
  end
end
```

再执行 `rails db:migrate` 完成db的migrate动作

> 激活token的callback

model层有很多的勾子方法能够帮助我们在执行model操作之前做一些事情, 这些model层的钩子除了校验之外, 还能起到很多CRUD的前置操作, 见如下代码

```ruby
class Guest < ApplicationRecord
  attr_accessor :remember_token, :activation_token\
  before_save { email.downcase! }
  before_create :create_activation_digest
  ...

  # 这些校验方法都不要暴露出去
  private

  def downcase_email
    self.email = email.downcase
  end

  def create_activation_digest
    self.activation_token = Guest.new_token
    self.activation_digest = Guest.digest(activation_token)
  end
  
end
```

之后在seeds里创建一些假数据来进行测试看看

```ruby
Guest.create!(name: 'Example Guest',
              email: 'example@rails.com',
              password: 'foobar',
              password_confirmation: 'foobar',
              # 这里字段新增
              activated: true,
              activated_at: Time.zone.new,
              admin: true)

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n + 1}@rails.com"
  password = 'password'
  Guest.create!(name: name,
                email: email,
                password: password,
                # 这里字段新增
                activated: true,
                activated_at: Time.zone.new,
                password_confirmation: password)
end
```

记得所有test的数据都只能从fixtures里拿

```yml
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= Guest.digest('password') %>
  activated: true
  activated_at: <%= Time.zone.now %>
  admin: true
```

然后重置数据库,重新把带了新字段的假数据插到qa里试试

`rails db:migrate:reset    rails db:seed`

#### 账号激活邮件

rails自带邮件发送的功能, 该邮件功能能通过内置的Action Mailer Library来完成, 而邮件的模版,则会使用erb文件.

使用命令来创建邮件模版

`rails generate mailer GuestMailer account_activation password_reset`

上述命令会在mailers里生成一个mailer文件同时还会修改application_mailer文件, 此外会在views中产生account_activation,password_reset各2个邮件模版, 格式分别是text和html. 文件内容如下

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation
    @greeting = "Hi"

    mail to: "to@example.org"
  end

  def password_reset
    @greeting = "Hi"

    mail to: "to@example.org"
  end
end
```

```ruby
# html.erb
<h1>Guest#account_activation</h1>

<p>
  <%= @greeting %>, find me in app/views/guest_mailer/account_activation.html.erb
</p>

# text.erb
Guest#account_activation

<%= @greeting %>, find me in app/views/guest_mailer/account_activation.text.erb
```

为了实现激活邮件发送, 我们先动手修改一下生成的模版, 添加一些必要的内容

```ruby
class ApplicationMailer < ActionMailer::Base
  default from: "noreply@example.com"
  layout "mailer"
end

class GuestMailer < ApplicationMailer
  def account_activation(guest)
    @guest = guest
    mail to: guest.email,  subject: 'Account Activation'
  end
  ...
end
```

激活链接需要包含email与即时生成的token. 链接例子如下

` http://www.example.com/account_activations/q5lt38hQDc_959PVoo6b7A/edit`

上面链接中一堆看不懂的就是base64加密后的内容, 整个链接能起到的内容和

`http://www.example.com/users/1/edit` 一样. 

实现上述逻辑的关键,是 ` edit_account_activation_url(@user.activation_token, ...)` 能回调`edit_user_url(user)`

为了实现此功能, 激活链接后面的部分需要加上查询参数以确认用户

`account_activations/q5lt38hQDc_959PVoo6b7A/edit?email=foo%40example.com`

此时当用户点击上述链接, 则方法可以通过query parameter的params[:email]来拿到参数. 并且注意上述foo%40的部分,%40是转义后的内容

之后修改email部分模版内容

```ruby
<h1>Sample App</h1>
<p>Hi <%= @user.name %>,</p>
<p>
Welcome to the Sample App! Click on the link below to activate your account: </p>
<%= link_to "Activate", edit_account_activation_url(@user.activation_token, email: @user.email) %>
```

#### 邮件预览与测试

rails提供了邮件发送的预览功能, 首先需要在config里先配置一下环境信息

```ruby
# config/environments/development.rb
# 增加以下内容, host改为服务器地址
  host = 'localhost:3000'
  config.action_mailer.default_url_options = { host: host, protocol: 'https' }
```

然后preview走一下,可以在`http://localhost:3000/rails/mailers/guest_mailer/account_activation`查看到邮件渲染出来的模版.

```ruby
# Preview all emails at http://localhost:3000/rails/mailers/guest_mailer
class GuestMailerPreview < ActionMailer::Preview
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/account_activation
  def account_activation
    guest = Guest.first
    guest.activation_token = Guest.new_token
    GuestMailer.account_activation(guest)
  end

  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    GuestMailer.password_reset
  end
end
```

preview没问题的话记得跑测试

```ruby
class GuestMailerTest < ActionMailer::TestCase
  test "account_activation" do
    guest = guests(:michael)
    guest.activation_token = Guest.new_token
    mail = GuestMailer.account_activation(guest)
    assert_equal "Account Activation", mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ["noreply@example.com"], mail.from 
    assert_match guest.name, mail.body.encoded 
    assert_match guest.activation_token, mail.body.encoded 
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
  ...
end

# 还需要添加environment下的test环境下面语句
# 这样就能在测试环境里设定发送邮件的默认尾缀为@example.com
  config.action_mailer.default_url_options = { host: 'example.com' }
```

#### 完成激活功能

> 更新create action

修正之前用户sign up后会直接跳转到profile页面, 中间加入邮件激活功能, 代码修改为如下内容

```ruby
  def create
    @guest = Guest.new(guest_params)
    if @guest.save
      GuestMailer.account_activation(@guest).deliver_now
      flash[:info] = "Please check your email to activate your account"
      redirect_to root_url
    else
      render 'new'
    end
```

> edit启用账号激活

这里需要用到ruby的一个特性`元编程(metaprogramming)`, 该特性的一个关键特点是能够使用对象内置的`send`方法来动态获取对象内部的任何属性. 比如

```ruby
a = [1,2,3,4,5]
# 常规来说, 获取数组长度
a.length # -> 5
# 使用元编程, 则
a.send(:length) # -> 5
```

基于上述认识, 可以来改写`authenticated?`方法, 让其具有能够解析带token的url的能力

```ruby
# model/guest.rb, 原
  def authenticated?(remember_token)
    return false if remember_digest.nil?

    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
# 改写后

  def authenticated?(attribute, token)
  # 此处send等价于self.send, 只要处在model对象内,就能省略self
    digest = send("#{attribute}_digest")
    return false if digest.nil?
    BCrypt::Password.new(digest).is_password?(token)
  end
```

之后修改一下session_helper.rb里用到了该方法的地方

```ruby
  def current_guest
    if (guest_id = session[:guest_id])
      @current_guest ||= Guest.find_by(id: cookies.encrypted[:guest_id])
    elsif (guest_id = cookies.encrypted[:guest_id])
      guest = Guest.find_by(id: guest_id)
      # 修改了这里
      if guest&.authenticated?(:remember, cookies[:remember_token])
        log_in guest
        @current_guest = guest
      end
    end
  end
```

然后我们在新增的用于账号激活的controller里新增edit方法以用来处理激活

```ruby
class AccountActivationsController < ApplicationController
  def edit
  # 先找到guest
    guest = Guest.find_by(email: params[:email])
    # 如果guest存在,同时没激活有授权, 则 更新激活属性
    if guest && !guest.activated? && guest.authenticated?(:activation, params[:id])
      guest.update_attribute(:activated, true)
      guest.update_attribute(:activated_at, Time.zone.now)
      log_in guest
      flash[:success] = "Account activated!"
      # 激活完毕,返回主页
      redirect_to guest
    else
      flash[:danger] = "Invalid activation link"
      redirect_to root_url
    end
  end
end
```

最后再来修改一下session_controller里用户创建成功时的逻辑

```ruby
  def create
    guest = Guest.find_by(email: params[:session][:email].downcase)
    if guest&.authenticate(params[:session][:password])
    # 增加了这里, 用于处理用户激活功能
      if guest.activated?
        log_in guest
        # rails提供的重定向方法, 会自动转成 guest_url(guest)
        params[:session][:remember_me] == '1' ? remember(guest) : forget(guest)
        remember guest
        # redirect_back_or guest
        redirect_to guest
      else
        message = 'Account not activated.'
        message += 'Check your email for the activation link.'
        flash[:warning] = message
      end
    else
      flash.now[:danger] = 'Invalid combination'
      render 'new'
    end
  end
```

#### 邮件整合测试

```ruby
require 'test_helper'
class UsersSignupTest < ActionDispatch::IntegrationTest
def setup 
  ActionMailer::Base.deliveries.clear
end

test "invalid signup information" do 
  get signup_path
  assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password: "foo",
                                         password_confirmation: "bar" } }  
  end
  assert_template 'users/new' 
  assert_select 'div#error_explanation' 
  assert_select 'div.field_with_errors'
end


test "valid signup information with account activation" do 
  get signup_path
  assert_difference 'User.count', 1 do
    post users_path, params: { user: { name: "Example User", 
                                       email: "user@example.com",
                                       password:              "password",
                                       password_confirmation: "password" } }
  end
  assert_equal 1, ActionMailer::Base.deliveries.size 
  user = assigns(:user)
  assert_not user.activated?
  # Try to log in before activation.
  log_in_as(user)
  assert_not is_logged_in?
  # Invalid activation token
  get edit_account_activation_path("invalid token", email: user.email) 
  assert_not is_logged_in?
  # Valid token, wrong email
  get edit_account_activation_path(user.activation_token, email: 'wrong')
  assert_not is_logged_in?
      # Valid activation token
  get edit_account_activation_path(user.activation_token, email: user.email) 
  assert user.reload.activated?
  follow_redirect!
  assert_template 'users/show'
  assert is_logged_in?
  end 
end
```

#### 生产环境中的email

1. 需要能发送邮件的服务器.(heroku有sendGrid好像能每天免费发400封)
2. 之后在config/environments/production.rb里配置发送的host
3. 账号密码通过环境变量来获取, 不配置在本地.
具体设定代码下面还有

#### 该部分总结

1. 和sessions功能一样, 账号激活功能也可以被当作一种resource来处理(在routes.rb内为resource), 而不是一个ActiveRecord的对象.
2. rails可以生成ActionMailer的actions与views,并能用来发送邮件.
3. Action Mailer支持纯文本和HTML2种邮件格式.
4. 被定义在mailer的actions里的实例变量在mailer的views中是可随时被调用的.
5. 账号激活功能使用一个生成的token来创建唯一的URL以让用户激活.
6. 账号激活功能使用hash的activation_digest来确保校验有效的激活请求(即给到用户的token本身是密中密,直接破解不可能).
7. 功能测试与e2e测试对于校验mailer功能的正确性非常重要.
8. 生产环境可以使用`SendGrid`来发送邮件.

### 密码重置功能

需求场景

1. 当用户请求密码重置, 通过用户提交的email地址来找到用户信息
2. 如果email地址在数据库中存在, 则生成一个重置用的token与其对应的digest
3. 保存重置用的digest到数据库, 之后邮件发送给用户重置用的token
4. 当用户点击链接时, 通过email查找用户, 并匹配token和数据库里的digest是否匹配, 如果匹配则授权用户
5. 如果用户已授权, 则展现密码修改的表单给到用户.

#### 密码重置resource

密码重置不应该关联任何AcitveRecord的model, 应该作为一个独立的功能, 因此应该作为一个resource, 以REST URLs的形式进行功能上的交互. 在这里我们只需要`edit`和`new`两个功能用来展示修改密码的页面和进行修改动作.

> 配置controller

首先是生成用于匹配密码重置resource的controller, 执行如下命令

`rails generate controller PasswordResets new edit --no-test-framework`

之后是配置routes.rb,设定resource对应的controller

```ruby
# 只要这4个资源, 记得默认resources是带7个资源吗
  resources :password_resets, only: [:new, :create, :update, :edit]
# 上述4个分别对应, 注意链接别名都是action_password_reset_path
# GET  ->  /password_resets/new -> new -> new_password_reset_path
# POST ->  /password_resets -> create -> password_resets_path
# GET -> /password_resets/<token>/edit -> edit -> edit_password_reset_url(token)
# PATCH -> /password_resets/<token> -> update -> password_reset_path(token)
```

之后在页面登录的位置加上新的链接

```ruby
<%= link_to "(forgot password)", new_password_reset_path %>
```

> 新密码重置

为了实现密码重置功能, 我们需要给目标model新增密码重置用的digest字段, 以便能安全的对用户进行密码重置工作.

一定要注意, 在rails中任何敏感信息都应该使用digest来代替直接校验和保存密码.

同时,密码重置的链接应该考虑加上过期时间, 这也就要求给目标model得再加上`reset_sent_at`字段来标记邮件发送时间.

执行如下命令来先新增几个字段

`rails g migration add_reset_to_guests reset_digest:string reset_sent_at:datetime`

```ruby
class AddResetToGuests < ActiveRecord::Migration[7.0]
  def change
    add_column :guests, :reset_digest, :string
    add_column :guests, :reset_sent_at, :datetime
  end
end
```

再执行 `rails db:migrate` 进行写入动作.

之后搞一个页面给重置密码用的

```ruby
<% provide(:title, "Forgot password") %> 
<h1>Forgot password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(url: password_resets_path, scope: :password_reset, local: true) do |f| %>
<%= f.label :email %>
<%= f.email_field :email, class: 'form-control' %>
<%= f.submit "Submit", class: "btn btn-primary" %> <% end %>
</div> 
</div>
```

> create action

基于最开始对重置密码的逻辑, 可以给controller添加create action

```ruby
  def create
    @guest = Guest.find_by(email: params[:password_reset][:email].downcase)
    if @guest
      @guest.create_reset_digest
      @guest.send_password_reset_email
      flash[:info] = "Email sent with password reset instructions"
      redirect_to root_url
    else
      flash.now[:danger] = "Email address not found"
      render 'new'
    end
```

从上面的代码中可以看到, 需要2个方法`create_reset_digest`与`send_password_reset_email`, 之后去model里添加, 

```ruby
# 增加取出记录的 :reset_token 字段, 用于校验
  attr_accessor :remember_token, :activation_token, :reset_token

# 添加对应方法
  def create_reset_digest
    # 为对象生成一个token
    self.reset_token = Guest.new_token
    # digest后更新到数据库
    update_attribute(:reset_digest, Guest.digest(reset_token))
    # 更新邮件发送时间
    update_attribute(:reset_sent_at, Time.zone.new)
  end
  
  def send_password_reset_email
    # 执行重置邮件发送逻辑
    GuestMailer.password_reset(self).deliver_now
  end
```

#### 密码重置邮件

先到mailers/guest_mailer.rb填充之前创建的用于发送邮件的方法

```ruby
  def password_reset(guest)
    @guest = guest
    mail to: guest.email, subject: 'Password reset'
  end
```

之后改一下邮件模版

```ruby
# text
To reset your password click the link below:
<%= edit_password_reset_url(@user.reset_token, email: @user.email) %>
This link will expire in two hours.
If you did not request your password to be reset, please ignore this email and your password will stay as it is.

# html
<h1>Password reset</h1>
<p>To reset your password click the link below:</p>
<%= link_to "Reset password", edit_password_reset_url(@user.reset_token, email: @user.email) %>
<p>This link will expire in two hours.</p>
<p>
If you did not request your password to be reset, please ignore this email and your password will stay as it is.
</p>
```

然后就可以到test/mailers/previews/guest_mailer_preview.rb里新增如下方法, 进行邮件预览了

```ruby
  # Preview this email at http://localhost:3000/rails/mailers/guest_mailer/password_reset
  def password_reset
    guest = Guest.first
    guest.reset_token = Guest.new_token
    GuestMailer.password_reset(guest)
  end
```

> 邮件测试

功能完成后记得写test case.

```ruby
require 'test_helper'

class GuestMailerTest < ActionMailer::TestCase
  ...
  test 'password_reset' do
    guest = guests(:michael)
    guest.reset_token = Guest.new_token
    mail = GuestMailer.password_reset(guest)
    assert_equal 'Password reset', mail.subject
    assert_equal [guest.email], mail.to
    assert_equal ['noreply@example.com'], mail.from
    # 只要字符串有, 匹配到就行
    assert_match guest.reset_token, mail.body.encoded
    assert_match CGI.escape(guest.email), mail.body.encoded
  end
end
```

之后执行命令`rails test`来跑全部的测试, 或者执行`rails test:mailers`来指定只跑mailers文件夹内的测试

#### 重置密码

现在来新增`edit`这个方法, 用来执行跳转到修改页面的逻辑

> 重置edit action

密码重置邮件里的链接长这样

`https://localhost:3000/password_resets/8vP9pJb_a4FB4tBzMHvUrQ/edit?email=example%40rails.com`

为了让这个链接工作起来, 我们需要一个表单来让这个链接能跳转过去(注意这个链接的组成格式和之前是一样的,rails都会自动识别并当作edit方法来处理)

表单提交有一个默认行为是会清空表单数据, 为了避免这个行为, 可以在view模版里添加下面的内容

```ruby
      <%= hidden_field_tag :email, @user.email %>
```

然后修改对应的view模版如下

```ruby
<% provide(:title, 'Reset password') %> <h1>Reset password</h1>
<div class="row">
<div class="col-md-6 col-md-offset-3">
<%= form_with(model: @user, url: password_reset_path(params[:id]), local: true) do |f| %>
      <%= render 'shared/error_messages' %>
      <%= hidden_field_tag :email, @user.email %>
<%= f.label :password %>
<%= f.password_field :password, class: 'form-control' %>
<%= f.label :password_confirmation, "Confirmation" %>
<%= f.password_field :password_confirmation, class: 'form-control' %>
<%= f.submit "Update password", class: "btn btn-primary" %> <% end %>
</div> </div>
```
修改密码时,肯定是希望数据已经被挂好了放在页面的输入框上的, 此时就需要用到controller里的filters了

```ruby
class PasswordResetsController < ApplicationController
# 拿到前端给的参数后, 会在执行指定的action之前调用
  before_action :get_guest, only: %i[edit update]
  before_action :valid_guest, only: %i[edit update]

  ...

  private

  def get_guest
    @guest = Guest.find_by(email: params[:email])
  end

  # 如果用户不存在, 未激活, 未授权则返回到根目录
  def valid_guest
    # params[:id] 会拿到前端传递的token
    redirect_to root_url unless @guest &&@guest.activated? && @guest.authenticated?(:reset, params[:id])
  end
end
```

> update方法

在能成功通过链接跳转到edit方法对应的表单后, 需要做的就是增加提交用的方法了, 此方法需要考虑以下几种情况

1. 超过了设定时间的密码重置怎么办?
2. 无效密码更新怎么办?
3. 空密码更新怎么办?
4. 成功更新密码

基于以上Cases, 来对controller代码做对应的变动. 首先是要加上新的filter来判断超时, 然后再在update方法里增加判断逻辑.

```ruby
class PasswordResetsController < ApplicationController
  before_action :check_expiration, only: %i[edit update]
  ...
  def update
    # 如果密码为空则往model对象里加error,加了就不是valid的了
    if params[:guest][:password].empty?
      @guest.errors.add(:password, "can't be empty")
      render 'edit'
    elsif @guest.update(guest_params)
      log_in @guest
      flash[:success] = "Password has been reset"
      redirect_to @guest
    else
      render 'edit'
    end
  end

  private
  # 只要是表单, 一定有严格参数模式
  def guest_params
    params.require(:guest).permit(:password, :password_confirmation)
  end

  def check_expiration
    # 该model方法新增, 到model层去加
    if @guest.password_reset_expired?
      flash[:danger] = 'Password reset has expired'
      redirect_to new_password_reset_url
    end
  end
end
```

Guest的model增加一个controller需要的校验方法

```ruby
  def password_reset_expired?
    reset_sent_at < 2.hours.ago
  end
```

> 密码重置测试

基于上述的内容, 基本完成了密码重置功能, 接下来开始写测试, 首先执行命令生成E2E测试(因为涉及到了view的交互)

`rails g integration_test password_resets`

E2E代码如下

```ruby
require 'test_helper'

class PasswordResetsTest < ActionDispatch::IntegrationTest
  def setup
    ActionMailer::Base.deliveries.clear
    @guest = guests(:michael)
  end

  test 'password resets' do
    # 1. 用户点击忘记密码后
    get new_password_reset_path
    assert_template 'password_resets/new'
    assert_select 'input[name=?]', 'password_reset[email]'
    # 2.1 无效的邮件
    post password_resets_path, params: { password_reset: { email: '' } }
    assert_not flash.empty?
    assert_template 'password_resets/new'
    # 2.2 有效的邮件
    post password_resets_path, params: { password_reset: { email: @guest.email } }
    assert_not_equal @guest.reset_digest, @guest.reload.reset_digest
    assert_equal 1, ActionMailer::Base.deliveries.size
    assert_not flash.empty?
    assert_redirected_to root_url
    # 3. 当通过邮件跳转时
    guest = assigns(:guest)
    # 3.1 如果邮件地址错误
    get edit_password_reset_path(guest.reset_token, email: '')
    assert_redirected_to root_url
    # 3.2 如果是未激活的用户
    guest.toggle!(:activated)
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_redirected_to root_url
    guest.toggle!(:activated)
    # 3.3 如果是正确的email, 错误的token
    get edit_password_reset_path('wrong token', email: guest.email)
    assert_redirected_to root_url
    # 3.4 如果是正确的email, 正确的token
    get edit_password_reset_path(guest.reset_token, email: guest.email)
    assert_template 'password_resets/edit'
    assert_select 'input[name=email][type=hidden][value=?]', guest.email
    # 4.1 此时填写的如果是无效的密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foobaz', password_confirmation: 'barqqq' } }
    assert_select 'div#error_explanation'
    # 4.2 如果填写的是空密码
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: '', password_confirmation: '' } }
    assert_select 'div#error_explanation'
    # 4.3 如果密码有效
    patch password_reset_path(guest.reset_token),
          params: { email: guest.email, guest: { password: 'foofoo', password_confirmation: 'foofoo' } }
    assert is_logged_in?
    assert_not flash.empty?
    assert_redirected_to guest
  end
end
```

#### 生产环境的邮件

生产环境邮件发送需要做的事情.

1. 找到config/enviroments/production.rb
2. 配置生产环境smtp邮件服务器相关代码

```ruby
Rails.application.configure do
...
  config.action_mailer.perform_caching = false
  config.action_mailer.raise_delivery_errors = true
  config.action_mailer.delivery_method = :smtp
  # from发送方地址
  host = 'noreply@abc.com'
  config.action_mailer.default_url_options = { host: host }
  ActionMailer::Base.smtp_settings = {
    :address        => 'smtp.sendgrid.net',
    :port           => '587',
    :authentication => :plain,
    :user_name      => ENV['SENDGRID_USERNAME'],
    :password       => ENV['SENDGRID_PASSWORD'],
    :domain         => 'heroku.com',
    :enable_starttls_auto => true
  }
end
```

#### 功能总结

1. 和sessions与账号激活功能一样, 密码重置也能被当作resources来处理, 而不用绑定为ActiveRecord对象
2. rails可以生成ActionMailer的actions,并且能预览要发送的邮件
3. ActionMailer支持纯本文和html格式
4. 定义在mailerAction里的变量在mailer的views里可用
5. 密码重置功能使用生成token创建唯一URL来重置密码
6. 密码重置功能使用一个哈希的reset_digest来确保token没被伪造
7. E2E测试很重要, 一定要写
8. 生产环境可以用SendGrid发送邮件

### 用户发推功能

#### 推文Model
先来看下最简单的推文表应该有哪些字段

microposts

field | type
--- |---|
id | integer
content | text
user_id | integer
created_at | datetime
updated_at | datetime

可以看到推文必须属于某一个用户, 并当用户炸掉时全部被删除掉.

它仅需要2个字段, 一个是content, 一个是user_id. 当中content使用的是text类型, 能比string存储更多的内容, 并且在生产上性能基本无差异.

之后来生成model, 使用命令

`rails g model Micropost content:text guest:references` 

上述命令会生成如下ActiveRecord的model

```ruby
class Micropost < ApplicationRecord
  # 使用guest:references, 会添加belongs_to
  belongs_to :guest
end
```

并生成如下的migration, 为了优化联表查询, 在这里给user_id和创建时间加一个联合索引

```ruby
class CreateMicroposts < ActiveRecord::Migration[7.0]
  def change
    create_table :microposts do |t|
      t.text :content
      t.references :guest, null: false, foreign_key: true

      t.timestamps
    end
    # 数组形式则是联合索引, 非数组普通symbol则单索引
    add_index :microposts, [:guest_id, :created_at]
  end
end
```

之后执行 `rails db:migrate`来写到数据库, 并可以使用控制台,输入`Micropost.new({content: "abc", guest_id: 1}).save` 来试着插入一条数据, 此时可以再使用`Micropost.first.guest`来直接拿到用户的信息.

也就是说, 创建时references写在哪一个model里, 那个model就是多方, 此时会自动添加上belongs_to, 但是另外的一方,则需要手动添加has_many :xxx来完成对应关系.

#### 增加校验

记得先加上基本的校验
```ruby
class Micropost < ApplicationRecord
  belongs_to :guest
  validates :guest_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

记得测试

```ruby
require "test_helper"

class MicropostTest < ActiveSupport::TestCase
  def setup
    @guest = guests(:michael)
    @micropost = Micropost.new(content: "asdasd", guest_id: @guest.id)
  end

  test 'should be valid' do
    assert @micropost.valid?
  end

  test 'user id should be present' do
    @micropost.guest_id = nil
    assert_not @micropost.valid?
  end

  test 'content should be present' do
    @micropost.content = ''
    assert_not @micropost.valid?
  end

  test 'content should be at most 140 characters' do
    @micropost.content = 'a' * 141
    assert_not @micropost.valid?
  end
end
```

#### 添加associations

如上面的代码所述, 关联关系在创建model时通过references来进行创建, 而many方则需要手动添加has_many来建立关系.

此外, 只有建立了关系后, 才可以从一方通过调用build来构建内容, build方法带缓存, 但是不会存到数据库里, 方便用于测试.而new,create之类的则会和db发生关系,不太合适.

```ruby
# test下的setup方法
  def setup
    @guest = guests(:michael)
    # @micropost = Micropost.new(content: "asdasd", guest_id: @guest.id)
    @micropost = @guest.microposts.build(content: 'Loasd')
  end
```

#### 推文优化

> Default scope

默认情况下, `user.microposts`方法不会保证返回集合的顺序, 但是如果一定要排序的场景下, 就需要往model里面加上SQL语句才能实现. 

`default_scope` 方法就是在model里用于做SQL扩展用的方法, 可以用于设定default order之类的默认功能,如下

```ruby
class Micropost < ApplicationRecord
  ...
  # 这样相当于是设定默认order方法会传递按创建时间降序排序
  # 会在键表的时候起作用, 修改SQL语句配置
  default_scope -> { order(create_at: :desc) }
end
```

上述代码介绍了一种在rails里被叫做`stabby lambda`的语法, 也叫做lambda表达式或者Proc(procedure). 当中的内容被叫做`匿名函数`. 格式为

`The stabby lambda -> takes in a block`

其block内的代码会被`call`方法调用, 比如

```ruby
3.0.0 :001 > -> { puts "foo" }
 => #<Proc:0x00007f7b5caa9e78 (irb):1 (lambda)> 
3.0.0 :002 > -> { puts "foo" }.call
foo
 => nil                                          
```

从上面的代码可以看出, 被 ` -> { }`所包裹的部分是一个完整的代码块,  只要call调用就会执行里面的匿名函数代码.

> destroy

关联关系下, 一个用户如果被destroy, 则关联表里的相关内容都应该被destroy.

为了达成这个效果, 需要在目标model上增加如下代码

```ruby
  has_many :microposts, dependent: :destroy
```

dependent为destroy表示当该model被destroy时,则相关的microposts表里的内容也会被destroy, 这一特性避免了孤儿数据的存在.

可以通过test来验证其确实是做了删除动作

```ruby
  test 'associated microposts should be destroyed' do
    @guest.save
    @guest.micropost.create!(content: "asdasd")
    assert_difference "Micropost.count", -1 do
      @guest.destroy
    end
  end
```

#### 展示推文

先来生成controller吧

`rails g controller Microposts`

然后增加下面的view

```ruby
# _micropost.html.erb
<li id="micropost-<%= micropost.id %>">
<%= link_to gravatar_for(micropost.user, size: 50), micropost.user %>
<span class="user"><%= link_to micropost.user.name, micropost.user %></span> <span class="content"><%= micropost.content %></span>
<span class="timestamp">
Posted <%= time_ago_in_words(micropost.created_at) %> ago. </span>
</li>
```

并且改一下展示用户的方法

```ruby
  def show
    @guest = Guest.find(params[:id])
    @microposts = @guest.microposts.paginate(page: params[:page])
  end
```

同样的改下展示用户时的view

```ruby
  <div class="col-md-8">
  <% if @user.microposts.any? %>
  <h3>Microposts (<%= @user.microposts.count %>)</h3>
      <ol class="microposts">
  <%= render @microposts %>
  </ol>
  <%= will_paginate @microposts %> <% end %>
  </div>
```

> 添加测试microposts数据

关联表的测试数据一般都比较难造, 首先可以使用`take`方法来从一方挑一些用户出来

```ruby
# 该方法会按照创建时间升序取前6个
guests = Guest.order(:created_at).take(6)
```

然后每个用户我们加50条推文进去.

```ruby
50.times do
  content = Faker::Lorem.sentence(word_count: 5)
  guests.each { |guest| guest.microposts.create!(content: content) }
end
```

上述操作后使用`db:seed`就能生成数据, 为了完成测试功能, 记得往对应的fixture也加上数据.

```yml
# fixtures
<% 30.times do |n| %> micropost_<%= n %>:
  content: <%= Faker::Lorem.sentence(word_count:5)%>
  created_at: <%= 42.days.ago %>
  user: michael <% end %>
```

因为涉及到了view展示,写e2e测试

```ruby
require 'test_helper'

class GuestsProfileTest < ActionDispatch::IntegrationTest
  include ApplicationHelper

  def setup
    @guest = guests(:michael)
  end

  test 'profile display' do
    get guest_path(@guest)
    assert_template 'guests/show'
    assert_select 'title', full_title(@guest.name)
    assert_select 'h1', text: @guest.name
    assert_select 'h1>img.gravatar'
    # response.body会拿到整个html响应的内容
    assert_match @guest.microposts.count.to_s, response.body
    assert_select 'div.pagination'
    @guest.microposts.paginate(page: 1).each do |micropost|
      assert_match micropost.content, response.body
    end
  end
end
```

#### 操作推文

对于操作推文内容用的API, 查已经关联到user了, 因此只需要增加用的post和删除用的delete.为此可以往route.rb里添加resource

```ruby
  resources :microposts, only: %i[create destroy]
```

此时增加的相关resources如下

request|url|action|named route
---|---|---|---|
POST|/microposts|create|microposts_path
DELETE|/microposts/1|destroy|micropost_path(micropost)

> 推文访问控制

操作推文功能都需要用户登录后才能实现, 可以基于此考虑功能的test case, 此时如下

```ruby
require "test_helper"

class MicropostsControllerTest < ActionDispatch::IntegrationTest
  def setup
    @micropost = microposts(:orange)
  end
  # 考虑点: 1. 数据库不会发生变化, 2. 重定向到登录的位置
  test 'should redirect create when not logged in' do
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: "Lorem ipsum" } }
    end
    assert_redirected_to login_url
  end

  test 'should redirect destroy when not logged in' do
    assert_no_difference 'Micropost.count' do
      delete micropost_path(@micropost)
    end
    assert_redirected_to login_url
  end
end
```

为了实现上述test case描述的功能, 只需要思考在这些功能前增加登录校验即可. 登录校验方法之前已经完成在UserController上了, 为了实现复用, 我们可以将其挪动到ApplicationController上让所有controller都用到

```ruby
class ApplicationController < ActionController::Base
  before_action :count_requests_in_session

  # 通过include加载controller文件夹下helper里的模块, 能直接使用里面的方法
  include SessionsHelper

  def count_requests_in_session
    # 当每次访问整个项目所有的controller的时候
    # 如果session中没有requests，则初始化requests参数为0
    # 如果有requests参数，则每访问一次就+1
    session[:requests] ||= 0
    session[:requests] += 1
  end

  def hello
    render html: 'hello, rails'
  end

  def bye
    render html: 'bye, rails'
  end

  private 
    # 加在这里, 在application_xxx里的,默认就会可以被所有xxx用
    # 如果用户未登录,则提供后重定向到登录页
    def logged_in_guest
      unless logged_in?
        store_location
        flash[:danger] = 'Please log in.'
        redirect_to login_url
      end
    end
end
```

> 创建microposts

在microposts_controllerl里增加routes的resources需要的方法

```ruby
class MicropostsController < ApplicationController
  before_action logged_in_guest, only: %i[create destroy]

  def create
    # build形式创建的数据在内存里,不会马上提交到数据库
    @micropost = current_guest.microposts.build(micropost_params)
    if @micropost.save
      flash[:success] = 'Micropost created'
      redirect_to root_url
    else
      render 'static_pages/home'
    end
  end

  def destroy; end

  private

  # strong_params, 只要content
  def micropost_params
    params.require(:micropost).permit(:content)
  end
end
```

> feed原型

在twitter等社交应用中, to have a feed of microposts 意味着获取到某个用户的指定推文. 基于此概念, 先来创建一个最简单的feed原型

```ruby
  def feed
    Micropost.where('user_id = ?', id)
  end
```

上述代码中的id会被安全的转义到`?`中进行填充, 以避免SQL注入问题的发生.

之后可以搞下controller的部分

```ruby
class StaticPagesController < ApplicationController
  def home
    return unless logged_in?

    @micropost = current_guest.microposts.build
    @feed_items = current_guest.feed.paginate(page: params[:page])
  end
  ...
end
```

然后再搞下view的部分

```ruby
# 注意: 如果是使用 form_with的方式提供的 f.object的形式,则rails7.0版本不用加@
<% if @feed_items.any? %>
  <ol class="microposts">
  # render这里, 每个@feed_items都带有Micropost类, 
  # 因此rails会自动在view文件夹下找同名的模版
  # 即_micropost.html.erb
    <%= render @feed_items %>
  </ol>
  <%= will_paginate @feed_items %>
<% end %>
```

